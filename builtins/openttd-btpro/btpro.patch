 projects/openttd_vs140.vcxproj         |  23 ++
 projects/openttd_vs140.vcxproj.filters |  41 ++
 projects/openttd_vs142.vcxproj         |  23 ++
 projects/openttd_vs142.vcxproj.filters |  41 ++
 source.list                            |  15 +
 src/base64.cpp                         | 124 ++++++
 src/base64.h                           |   4 +
 src/bridge_gui.cpp                     |   2 +
 src/build_vehicle_gui.cpp              |  19 +-
 src/cargo_table_gui.cpp                | 216 +++++++++++
 src/cargo_table_gui.h                  |  14 +
 src/command.cpp                        |  34 +-
 src/command_type.h                     |   1 +
 src/commands_token_gui.cpp             | 130 +++++++
 src/commands_token_gui.h               |  12 +
 src/company_base.h                     |   8 +
 src/company_cmd.cpp                    |  23 ++
 src/company_func.h                     |   1 +
 src/crashlog.cpp                       |   4 +-
 src/depot_gui.cpp                      |  78 ++--
 src/economy.cpp                        |  19 +
 src/gfx.cpp                            |   1 +
 src/gfx_func.h                         |   1 +
 src/gfxinit.cpp                        |   2 +
 src/graph_gui.cpp                      | 167 +++++++-
 src/gui.h                              |   2 +-
 src/industry_gui.cpp                   | 188 +++++++--
 src/intro_gui.cpp                      | 295 ++++++++++++++
 src/lang/english.txt                   | 320 +++++++++++++++
 src/main_gui.cpp                       | 104 ++++-
 src/misc.cpp                           |   1 +
 src/misc_gui.cpp                       | 350 ++++++++++++++++-
 src/network/network.cpp                | 317 +++++++++++++++
 src/network/network.h                  |  13 +-
 src/network/network_client.cpp         |  10 +
 src/network/network_gui.cpp            |  64 ++-
 src/order_cmd.cpp                      |   2 +
 src/order_gui.cpp                      | 146 ++++++-
 src/rail_cmd.cpp                       |   5 +
 src/rail_gui.cpp                       | 126 +++++-
 src/rail_map.h                         |  18 +
 src/rev.cpp.in                         |  12 +-
 src/road_gui.cpp                       | 148 ++++++-
 src/roadveh_cmd.cpp                    |   2 +-
 src/saveload/town_sl.cpp               |  14 +-
 src/script/api/game/game_window.hpp.sq |   1 +
 src/script/api/script_window.hpp       |   1 +
 src/settings_gui.cpp                   |  20 +
 src/settings_type.h                    |  18 +
 src/smallmap_gui.cpp                   |  34 +-
 src/statusbar_gui.cpp                  |  24 ++
 src/table/misc_settings.ini            |   4 +-
 src/table/settings.ini                 | 177 +++++++++
 src/table/sprites.h                    |  17 +-
 src/terraform_gui.cpp                  |  20 +
 src/tile_cmd.h                         |   1 +
 src/tilehighlight_func.h               |   4 +
 src/tilehighlight_type.h               |   5 +
 src/timetable_cmd.cpp                  |   1 +
 src/toolbar_gui.cpp                    | 106 ++++-
 src/town.h                             |  88 +++++
 src/town_cmd.cpp                       | 330 +++++++++++++++-
 src/town_gui.cpp                       | 531 ++++++++++++++++++++++++-
 src/train_cmd.cpp                      |   8 +-
 src/transparency.h                     |   1 +
 src/transparency_gui.cpp               |   5 +-
 src/triphistory.h                      |  75 ++++
 src/triphistory_cmd.cpp                | 100 +++++
 src/triphistory_gui.cpp                | 214 ++++++++++
 src/vehicle.cpp                        |  18 +-
 src/vehicle_base.h                     |   9 +
 src/vehicle_gui.cpp                    |  66 +++-
 src/vehicle_gui.h                      |   2 +
 src/video/sdl_v.cpp                    |   2 +
 src/video/win32_v.cpp                  |   2 +
 src/viewport.cpp                       | 689 ++++++++++++++++++++++++++-------
 src/viewport_func.h                    |   2 +-
 src/viewport_gui.cpp                   |  98 +++++
 src/viewport_type.h                    |   3 +
 src/watch_gui_1.cpp                    | 535 +++++++++++++++++++++++++
 src/watch_gui_1.h                      |  67 ++++
 src/widget.cpp                         |   1 +
 src/widgets/cargo_table_widget.h       |  21 +
 src/widgets/industry_widget.h          |   2 +
 src/widgets/intro_widget.h             |  49 +++
 src/widgets/network_widget.h           |   5 +
 src/widgets/rail_widget.h              |   2 +
 src/widgets/road_widget.h              |   3 +
 src/widgets/statusbar_widget.h         |   2 +
 src/widgets/terraform_widget.h         |   1 +
 src/widgets/toolbar_widget.h           |   1 +
 src/widgets/town_widget.h              |  31 ++
 src/widgets/transparency_widget.h      |   1 +
 src/widgets/vehicle_widget.h           |   1 +
 src/window.cpp                         |   7 +-
 src/window_gui.h                       |   1 +
 src/window_type.h                      |  13 +
 src/zoning.h                           |  33 ++
 src/zoning_cmd.cpp                     | 295 ++++++++++++++
 src/zoning_gui.cpp                     | 198 ++++++++++
 src/zoom_type.h                        |   3 +-
 101 files changed, 6770 insertions(+), 318 deletions(-)

diff --git a/projects/openttd_vs140.vcxproj b/projects/openttd_vs140.vcxproj
index 9a741f28d..4e013e8ab 100644
--- a/projects/openttd_vs140.vcxproj
+++ b/projects/openttd_vs140.vcxproj
@@ -92,6 +92,14 @@
     <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
     <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)..\objs\$(Platform)\$(Configuration)\</OutDir>
     <LocalDebuggerWorkingDirectory>$(ProjectDir)..\bin</LocalDebuggerWorkingDirectory>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">C:\OpenTTD_essentials\shared\include;C:\OpenTTD_DMusic\shared\include;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">C:\OpenTTD_essentials\shared\include;C:\OpenTTD_DMusic\shared\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">C:\OpenTTD_essentials\win32\library;C:\OpenTTD_DMusic\win32\library;$(LibraryPath)</LibraryPath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">C:\OpenTTD_essentials\win32\library;C:\OpenTTD_DMusic\win32\library;$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">C:\OpenTTD_essentials\shared\include;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\OpenTTD_essentials\shared\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">C:\OpenTTD_essentials\win64\library;$(LibraryPath)</LibraryPath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\OpenTTD_essentials\win64\library;$(LibraryPath)</LibraryPath>
   </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
     <Midl>
@@ -342,13 +350,16 @@
     <ClCompile Include="..\src\animated_tile.cpp" />
     <ClCompile Include="..\src\articulated_vehicles.cpp" />
     <ClCompile Include="..\src\autoreplace.cpp" />
+    <ClCompile Include="..\src\base64.cpp" />
     <ClCompile Include="..\src\bmp.cpp" />
     <ClCompile Include="..\src\cargoaction.cpp" />
     <ClCompile Include="..\src\cargomonitor.cpp" />
     <ClCompile Include="..\src\cargopacket.cpp" />
     <ClCompile Include="..\src\cargotype.cpp" />
+    <ClCompile Include="..\src\cargo_table_gui.cpp" />
     <ClCompile Include="..\src\cheat.cpp" />
     <ClCompile Include="..\src\command.cpp" />
+    <ClCompile Include="..\src\commands_token_gui.cpp" />
     <ClCompile Include="..\src\console.cpp" />
     <ClCompile Include="..\src\console_cmds.cpp" />
     <ClCompile Include="..\src\cpu.cpp" />
@@ -429,10 +440,12 @@
     <ClCompile Include="..\src\tile_map.cpp" />
     <ClCompile Include="..\src\tilearea.cpp" />
     <ClCompile Include="..\src\townname.cpp" />
+    <ClCompile Include="..\src\triphistory_cmd.cpp" />
     <ClCompile Include="..\src\vehicle.cpp" />
     <ClCompile Include="..\src\vehiclelist.cpp" />
     <ClCompile Include="..\src\viewport.cpp" />
     <ClCompile Include="..\src\viewport_sprite_sorter_sse4.cpp" />
+    <ClCompile Include="..\src\watch_gui_1.cpp" />
     <ClCompile Include="..\src\waypoint.cpp" />
     <ClCompile Include="..\src\widget.cpp" />
     <ClCompile Include="..\src\window.cpp" />
@@ -445,11 +458,13 @@
     <ClInclude Include="..\src\autoreplace_gui.h" />
     <ClInclude Include="..\src\autoreplace_type.h" />
     <ClInclude Include="..\src\autoslope.h" />
+    <ClInclude Include="..\src\base64.h" />
     <ClInclude Include="..\src\base_media_base.h" />
     <ClInclude Include="..\src\base_media_func.h" />
     <ClInclude Include="..\src\base_station_base.h" />
     <ClInclude Include="..\src\bmp.h" />
     <ClInclude Include="..\src\bridge.h" />
+    <ClInclude Include="..\src\cargo_table_gui.h" />
     <ClInclude Include="..\src\cargo_type.h" />
     <ClInclude Include="..\src\cargoaction.h" />
     <ClInclude Include="..\src\cargomonitor.h" />
@@ -461,6 +476,7 @@
     <ClInclude Include="..\src\cmd_helper.h" />
     <ClInclude Include="..\src\command_func.h" />
     <ClInclude Include="..\src\command_type.h" />
+    <ClInclude Include="..\src\commands_token_gui.h" />
     <ClInclude Include="..\src\company_base.h" />
     <ClInclude Include="..\src\company_func.h" />
     <ClInclude Include="..\src\company_gui.h" />
@@ -549,6 +565,7 @@
     <ClInclude Include="..\src\map_func.h" />
     <ClInclude Include="..\src\map_type.h" />
     <ClInclude Include="..\src\mixer.h" />
+    <ClInclude Include="..\src\triphistory.h" />
     <ClInclude Include="..\src\network\network.h" />
     <ClInclude Include="..\src\network\network_admin.h" />
     <ClInclude Include="..\src\network\network_base.h" />
@@ -599,6 +616,7 @@
     <ClInclude Include="..\src\sound\null_s.h" />
     <ClInclude Include="..\src\video\null_v.h" />
     <ClInclude Include="..\src\object.h" />
+    <ClCompile Include="..\src\triphistory_gui.cpp" />
     <ClInclude Include="..\src\object_base.h" />
     <ClInclude Include="..\src\object_type.h" />
     <ClInclude Include="..\src\openttd.h" />
@@ -697,6 +715,7 @@
     <ClInclude Include="..\src\viewport_func.h" />
     <ClInclude Include="..\src\viewport_sprite_sorter.h" />
     <ClInclude Include="..\src\viewport_type.h" />
+    <ClInclude Include="..\src\watch_gui_1.h" />
     <ClInclude Include="..\src\water.h" />
     <ClInclude Include="..\src\waypoint_base.h" />
     <ClInclude Include="..\src\waypoint_func.h" />
@@ -711,6 +730,7 @@
     <ClInclude Include="..\src\sound\xaudio2_s.h" />
     <ClInclude Include="..\src\zoom_func.h" />
     <ClInclude Include="..\src\zoom_type.h" />
+    <ClInclude Include="..\src\zoning.h" />
     <ClCompile Include="..\src\core\alloc_func.cpp" />
     <ClInclude Include="..\src\core\alloc_func.hpp" />
     <ClInclude Include="..\src\core\alloc_type.hpp" />
@@ -797,12 +817,14 @@
     <ClCompile Include="..\src\vehicle_gui.cpp" />
     <ClCompile Include="..\src\viewport_gui.cpp" />
     <ClCompile Include="..\src\waypoint_gui.cpp" />
+    <ClCompile Include="..\src\zoning_gui.cpp" />
     <ClInclude Include="..\src\widgets\airport_widget.h" />
     <ClInclude Include="..\src\widgets\ai_widget.h" />
     <ClInclude Include="..\src\widgets\autoreplace_widget.h" />
     <ClInclude Include="..\src\widgets\bootstrap_widget.h" />
     <ClInclude Include="..\src\widgets\bridge_widget.h" />
     <ClInclude Include="..\src\widgets\build_vehicle_widget.h" />
+    <ClInclude Include="..\src\widgets\cargo_table_widget.h" />
     <ClInclude Include="..\src\widgets\cheat_widget.h" />
     <ClInclude Include="..\src\widgets\company_widget.h" />
     <ClInclude Include="..\src\widgets\console_widget.h" />
@@ -881,6 +903,7 @@
     <ClCompile Include="..\src\void_cmd.cpp" />
     <ClCompile Include="..\src\water_cmd.cpp" />
     <ClCompile Include="..\src\waypoint_cmd.cpp" />
+    <ClCompile Include="..\src\zoning_cmd.cpp" />
     <ClCompile Include="..\src\saveload\afterload.cpp" />
     <ClCompile Include="..\src\saveload\ai_sl.cpp" />
     <ClCompile Include="..\src\saveload\airport_sl.cpp" />
diff --git a/projects/openttd_vs140.vcxproj.filters b/projects/openttd_vs140.vcxproj.filters
index 751e54887..a31029df2 100644
--- a/projects/openttd_vs140.vcxproj.filters
+++ b/projects/openttd_vs140.vcxproj.filters
@@ -375,6 +375,9 @@
     <ClCompile Include="..\src\townname.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\triphistory_cmd.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\vehicle.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -735,6 +738,9 @@
     <ClInclude Include="..\src\mixer.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\triphistory.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\network\network.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -885,6 +891,9 @@
     <ClInclude Include="..\src\object.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClCompile Include="..\src\triphistory_gui.cpp">
+      <Filter>Header Files</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\object_base.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -1221,6 +1230,9 @@
     <ClInclude Include="..\src\zoom_type.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\zoning.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClCompile Include="..\src\core\alloc_func.cpp">
       <Filter>Core Source Code</Filter>
     </ClCompile>
@@ -1479,6 +1491,9 @@
     <ClCompile Include="..\src\waypoint_gui.cpp">
       <Filter>GUI Source Code</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\zoning_gui.cpp">
+      <Filter>GUI Source Code</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\widgets\airport_widget.h">
       <Filter>Widgets</Filter>
     </ClInclude>
@@ -1731,6 +1746,9 @@
     <ClCompile Include="..\src\waypoint_cmd.cpp">
       <Filter>Command handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\zoning_cmd.cpp">
+      <Filter>Command handlers</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\saveload\afterload.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
@@ -3087,9 +3105,32 @@
     <ClCompile Include="..\src\thread\thread_win32.cpp">
       <Filter>Threading</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\watch_gui_1.cpp">
+      <Filter>GUI Source Code</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\commands_token_gui.cpp">
+      <Filter>GUI Source Code</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\base64.cpp">
+      <Filter>Command handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\cargo_table_gui.cpp" />
   </ItemGroup>
   <ItemGroup>
     <None Include="..\media\openttd.ico" />
     <None Include="..\README.md" />
   </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\src\commands_token_gui.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\watch_gui_1.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\base64.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\cargo_table_gui.h" />
+    <ClInclude Include="..\src\widgets\cargo_table_widget.h" />
+  </ItemGroup>
 </Project>
diff --git a/projects/openttd_vs142.vcxproj b/projects/openttd_vs142.vcxproj
index 5999d00d6..6e2fd6345 100644
--- a/projects/openttd_vs142.vcxproj
+++ b/projects/openttd_vs142.vcxproj
@@ -92,6 +92,14 @@
     <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
     <OutDir Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(SolutionDir)..\objs\$(Platform)\$(Configuration)\</OutDir>
     <LocalDebuggerWorkingDirectory>$(ProjectDir)..\bin</LocalDebuggerWorkingDirectory>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">C:\OpenTTD_essentials\shared\include;C:\OpenTTD_DMusic\shared\include;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">C:\OpenTTD_essentials\shared\include;C:\OpenTTD_DMusic\shared\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">C:\OpenTTD_essentials\win32\library;C:\OpenTTD_DMusic\win32\library;$(LibraryPath)</LibraryPath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">C:\OpenTTD_essentials\win32\library;C:\OpenTTD_DMusic\win32\library;$(LibraryPath)</LibraryPath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">C:\OpenTTD_essentials\shared\include;$(IncludePath)</IncludePath>
+    <IncludePath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\OpenTTD_essentials\shared\include;$(IncludePath)</IncludePath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">C:\OpenTTD_essentials\win64\library;$(LibraryPath)</LibraryPath>
+    <LibraryPath Condition="'$(Configuration)|$(Platform)'=='Release|x64'">C:\OpenTTD_essentials\win64\library;$(LibraryPath)</LibraryPath>
   </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
     <Midl>
@@ -342,13 +350,16 @@
     <ClCompile Include="..\src\animated_tile.cpp" />
     <ClCompile Include="..\src\articulated_vehicles.cpp" />
     <ClCompile Include="..\src\autoreplace.cpp" />
+    <ClCompile Include="..\src\base64.cpp" />
     <ClCompile Include="..\src\bmp.cpp" />
     <ClCompile Include="..\src\cargoaction.cpp" />
     <ClCompile Include="..\src\cargomonitor.cpp" />
     <ClCompile Include="..\src\cargopacket.cpp" />
     <ClCompile Include="..\src\cargotype.cpp" />
+    <ClCompile Include="..\src\cargo_table_gui.cpp" />
     <ClCompile Include="..\src\cheat.cpp" />
     <ClCompile Include="..\src\command.cpp" />
+    <ClCompile Include="..\src\commands_token_gui.cpp" />
     <ClCompile Include="..\src\console.cpp" />
     <ClCompile Include="..\src\console_cmds.cpp" />
     <ClCompile Include="..\src\cpu.cpp" />
@@ -429,10 +440,12 @@
     <ClCompile Include="..\src\tile_map.cpp" />
     <ClCompile Include="..\src\tilearea.cpp" />
     <ClCompile Include="..\src\townname.cpp" />
+    <ClCompile Include="..\src\triphistory_cmd.cpp" />
     <ClCompile Include="..\src\vehicle.cpp" />
     <ClCompile Include="..\src\vehiclelist.cpp" />
     <ClCompile Include="..\src\viewport.cpp" />
     <ClCompile Include="..\src\viewport_sprite_sorter_sse4.cpp" />
+    <ClCompile Include="..\src\watch_gui_1.cpp" />
     <ClCompile Include="..\src\waypoint.cpp" />
     <ClCompile Include="..\src\widget.cpp" />
     <ClCompile Include="..\src\window.cpp" />
@@ -445,11 +458,13 @@
     <ClInclude Include="..\src\autoreplace_gui.h" />
     <ClInclude Include="..\src\autoreplace_type.h" />
     <ClInclude Include="..\src\autoslope.h" />
+    <ClInclude Include="..\src\base64.h" />
     <ClInclude Include="..\src\base_media_base.h" />
     <ClInclude Include="..\src\base_media_func.h" />
     <ClInclude Include="..\src\base_station_base.h" />
     <ClInclude Include="..\src\bmp.h" />
     <ClInclude Include="..\src\bridge.h" />
+    <ClInclude Include="..\src\cargo_table_gui.h" />
     <ClInclude Include="..\src\cargo_type.h" />
     <ClInclude Include="..\src\cargoaction.h" />
     <ClInclude Include="..\src\cargomonitor.h" />
@@ -461,6 +476,7 @@
     <ClInclude Include="..\src\cmd_helper.h" />
     <ClInclude Include="..\src\command_func.h" />
     <ClInclude Include="..\src\command_type.h" />
+    <ClInclude Include="..\src\commands_token_gui.h" />
     <ClInclude Include="..\src\company_base.h" />
     <ClInclude Include="..\src\company_func.h" />
     <ClInclude Include="..\src\company_gui.h" />
@@ -549,6 +565,7 @@
     <ClInclude Include="..\src\map_func.h" />
     <ClInclude Include="..\src\map_type.h" />
     <ClInclude Include="..\src\mixer.h" />
+    <ClInclude Include="..\src\triphistory.h" />
     <ClInclude Include="..\src\network\network.h" />
     <ClInclude Include="..\src\network\network_admin.h" />
     <ClInclude Include="..\src\network\network_base.h" />
@@ -599,6 +616,7 @@
     <ClInclude Include="..\src\sound\null_s.h" />
     <ClInclude Include="..\src\video\null_v.h" />
     <ClInclude Include="..\src\object.h" />
+    <ClCompile Include="..\src\triphistory_gui.cpp" />
     <ClInclude Include="..\src\object_base.h" />
     <ClInclude Include="..\src\object_type.h" />
     <ClInclude Include="..\src\openttd.h" />
@@ -697,6 +715,7 @@
     <ClInclude Include="..\src\viewport_func.h" />
     <ClInclude Include="..\src\viewport_sprite_sorter.h" />
     <ClInclude Include="..\src\viewport_type.h" />
+    <ClInclude Include="..\src\watch_gui_1.h" />
     <ClInclude Include="..\src\water.h" />
     <ClInclude Include="..\src\waypoint_base.h" />
     <ClInclude Include="..\src\waypoint_func.h" />
@@ -711,6 +730,7 @@
     <ClInclude Include="..\src\sound\xaudio2_s.h" />
     <ClInclude Include="..\src\zoom_func.h" />
     <ClInclude Include="..\src\zoom_type.h" />
+    <ClInclude Include="..\src\zoning.h" />
     <ClCompile Include="..\src\core\alloc_func.cpp" />
     <ClInclude Include="..\src\core\alloc_func.hpp" />
     <ClInclude Include="..\src\core\alloc_type.hpp" />
@@ -797,12 +817,14 @@
     <ClCompile Include="..\src\vehicle_gui.cpp" />
     <ClCompile Include="..\src\viewport_gui.cpp" />
     <ClCompile Include="..\src\waypoint_gui.cpp" />
+    <ClCompile Include="..\src\zoning_gui.cpp" />
     <ClInclude Include="..\src\widgets\airport_widget.h" />
     <ClInclude Include="..\src\widgets\ai_widget.h" />
     <ClInclude Include="..\src\widgets\autoreplace_widget.h" />
     <ClInclude Include="..\src\widgets\bootstrap_widget.h" />
     <ClInclude Include="..\src\widgets\bridge_widget.h" />
     <ClInclude Include="..\src\widgets\build_vehicle_widget.h" />
+    <ClInclude Include="..\src\widgets\cargo_table_widget.h" />
     <ClInclude Include="..\src\widgets\cheat_widget.h" />
     <ClInclude Include="..\src\widgets\company_widget.h" />
     <ClInclude Include="..\src\widgets\console_widget.h" />
@@ -881,6 +903,7 @@
     <ClCompile Include="..\src\void_cmd.cpp" />
     <ClCompile Include="..\src\water_cmd.cpp" />
     <ClCompile Include="..\src\waypoint_cmd.cpp" />
+    <ClCompile Include="..\src\zoning_cmd.cpp" />
     <ClCompile Include="..\src\saveload\afterload.cpp" />
     <ClCompile Include="..\src\saveload\ai_sl.cpp" />
     <ClCompile Include="..\src\saveload\airport_sl.cpp" />
diff --git a/projects/openttd_vs142.vcxproj.filters b/projects/openttd_vs142.vcxproj.filters
index 751e54887..a31029df2 100644
--- a/projects/openttd_vs142.vcxproj.filters
+++ b/projects/openttd_vs142.vcxproj.filters
@@ -375,6 +375,9 @@
     <ClCompile Include="..\src\townname.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\triphistory_cmd.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\vehicle.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -735,6 +738,9 @@
     <ClInclude Include="..\src\mixer.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\triphistory.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\network\network.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -885,6 +891,9 @@
     <ClInclude Include="..\src\object.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClCompile Include="..\src\triphistory_gui.cpp">
+      <Filter>Header Files</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\object_base.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -1221,6 +1230,9 @@
     <ClInclude Include="..\src\zoom_type.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\zoning.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClCompile Include="..\src\core\alloc_func.cpp">
       <Filter>Core Source Code</Filter>
     </ClCompile>
@@ -1479,6 +1491,9 @@
     <ClCompile Include="..\src\waypoint_gui.cpp">
       <Filter>GUI Source Code</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\zoning_gui.cpp">
+      <Filter>GUI Source Code</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\widgets\airport_widget.h">
       <Filter>Widgets</Filter>
     </ClInclude>
@@ -1731,6 +1746,9 @@
     <ClCompile Include="..\src\waypoint_cmd.cpp">
       <Filter>Command handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\zoning_cmd.cpp">
+      <Filter>Command handlers</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\saveload\afterload.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
@@ -3087,9 +3105,32 @@
     <ClCompile Include="..\src\thread\thread_win32.cpp">
       <Filter>Threading</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\watch_gui_1.cpp">
+      <Filter>GUI Source Code</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\commands_token_gui.cpp">
+      <Filter>GUI Source Code</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\base64.cpp">
+      <Filter>Command handlers</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\cargo_table_gui.cpp" />
   </ItemGroup>
   <ItemGroup>
     <None Include="..\media\openttd.ico" />
     <None Include="..\README.md" />
   </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\src\commands_token_gui.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\watch_gui_1.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\base64.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\cargo_table_gui.h" />
+    <ClInclude Include="..\src\widgets\cargo_table_widget.h" />
+  </ItemGroup>
 </Project>
diff --git a/source.list b/source.list
index ce6c4cf15..6d1b3add3 100644
--- a/source.list
+++ b/source.list
@@ -3,6 +3,7 @@ airport.cpp
 animated_tile.cpp
 articulated_vehicles.cpp
 autoreplace.cpp
+base64.cpp
 bmp.cpp
 cargoaction.cpp
 cargomonitor.cpp
@@ -90,6 +91,7 @@ tgp.cpp
 tile_map.cpp
 tilearea.cpp
 townname.cpp
+triphistory_cmd.cpp
 #if WIN32
 #else
 	#if OS2
@@ -132,11 +134,13 @@ autoreplace_func.h
 autoreplace_gui.h
 autoreplace_type.h
 autoslope.h
+base64.h
 base_media_base.h
 base_media_func.h
 base_station_base.h
 bmp.h
 bridge.h
+cargo_table_gui.h
 cargo_type.h
 cargoaction.h
 cargomonitor.h
@@ -236,6 +240,7 @@ livery.h
 map_func.h
 map_type.h
 mixer.h
+triphistory.h
 network/network.h
 network/network_admin.h
 network/network_base.h
@@ -283,9 +288,11 @@ news_type.h
 music/midi.h
 music/midifile.hpp
 music/null_m.h
+commands_token_gui.h
 sound/null_s.h
 video/null_v.h
 object.h
+triphistory_gui.cpp
 object_base.h
 object_type.h
 openttd.h
@@ -384,6 +391,7 @@ vehiclelist.h
 viewport_func.h
 viewport_sprite_sorter.h
 viewport_type.h
+watch_gui_1.h
 water.h
 waypoint_base.h
 waypoint_func.h
@@ -398,6 +406,7 @@ window_type.h
 sound/xaudio2_s.h
 zoom_func.h
 zoom_type.h
+zoning.h
 #if WIN32
 #else
 music/bemidi.h
@@ -453,6 +462,7 @@ autoreplace_gui.cpp
 bootstrap_gui.cpp
 bridge_gui.cpp
 build_vehicle_gui.cpp
+cargo_table_gui.cpp
 cheat_gui.cpp
 company_gui.cpp
 console_gui.cpp
@@ -480,6 +490,7 @@ network/network_gui.cpp
 newgrf_debug_gui.cpp
 newgrf_gui.cpp
 news_gui.cpp
+commands_token_gui.cpp
 object_gui.cpp
 order_gui.cpp
 osk_gui.cpp
@@ -504,7 +515,9 @@ transparency_gui.cpp
 tree_gui.cpp
 vehicle_gui.cpp
 viewport_gui.cpp
+watch_gui_1.cpp
 waypoint_gui.cpp
+zoning_gui.cpp
 
 # Widgets
 widgets/airport_widget.h
@@ -513,6 +526,7 @@ widgets/autoreplace_widget.h
 widgets/bootstrap_widget.h
 widgets/bridge_widget.h
 widgets/build_vehicle_widget.h
+widgets/cargo_table_widget.h
 widgets/cheat_widget.h
 widgets/company_widget.h
 widgets/console_widget.h
@@ -593,6 +607,7 @@ vehicle_cmd.cpp
 void_cmd.cpp
 water_cmd.cpp
 waypoint_cmd.cpp
+zoning_cmd.cpp
 
 # Save/Load handlers
 saveload/afterload.cpp
diff --git a/src/base64.cpp b/src/base64.cpp
new file mode 100644
index 000000000..6f9873600
--- /dev/null
+++ b/src/base64.cpp
@@ -0,0 +1,124 @@
+/* 
+	 base64.cpp and base64.h
+
+	 Copyright (C) 2004-2008 Ren? Nyffenegger
+
+	 This source code is provided 'as-is', without any express or implied
+	 warranty. In no event will the author be held liable for any damages
+	 arising from the use of this software.
+
+	 Permission is granted to anyone to use this software for any purpose,
+	 including commercial applications, and to alter it and redistribute it
+	 freely, subject to the following restrictions:
+
+	 1. The origin of this source code must not be misrepresented; you must not
+			claim that you wrote the original source code. If you use this source code
+			in a product, an acknowledgment in the product documentation would be
+			appreciated but is not required.
+
+	 2. Altered source versions must be plainly marked as such, and must not be
+			misrepresented as being the original source code.
+
+	 3. This notice may not be removed or altered from any source distribution.
+
+	 Ren? Nyffenegger rene.nyffenegger@adp-gmbh.ch
+
+*/
+
+#include "base64.h"
+#include <iostream>
+#include "safeguards.h"
+
+static const std::string base64_chars = 
+						 "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+						 "abcdefghijklmnopqrstuvwxyz"
+						 "0123456789+/";
+
+
+static inline bool is_base64(unsigned char c) {
+	return (isalnum(c) || (c == '+') || (c == '/'));
+}
+
+std::string base64_encode(unsigned char const* bytes_to_encode, unsigned int in_len) {
+	std::string ret;
+	int i = 0;
+	int j = 0;
+	unsigned char char_array_3[3];
+	unsigned char char_array_4[4];
+
+	while (in_len--) {
+		char_array_3[i++] = *(bytes_to_encode++);
+		if (i == 3) {
+			char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
+			char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
+			char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
+			char_array_4[3] = char_array_3[2] & 0x3f;
+
+			for(i = 0; (i <4) ; i++)
+				ret += base64_chars[char_array_4[i]];
+			i = 0;
+		}
+	}
+
+	if (i)
+	{
+		for(j = i; j < 3; j++)
+			char_array_3[j] = '\0';
+
+		char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
+		char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
+		char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
+		char_array_4[3] = char_array_3[2] & 0x3f;
+
+		for (j = 0; (j < i + 1); j++)
+			ret += base64_chars[char_array_4[j]];
+
+		while((i++ < 3))
+			ret += '=';
+
+	}
+
+	return ret;
+
+}
+
+std::string base64_decode(std::string const& encoded_string) {
+	int in_len = encoded_string.size();
+	int i = 0;
+	int j = 0;
+	int in_ = 0;
+	unsigned char char_array_4[4], char_array_3[3];
+	std::string ret;
+
+	while (in_len-- && ( encoded_string[in_] != '=') && is_base64(encoded_string[in_])) {
+		char_array_4[i++] = encoded_string[in_]; in_++;
+		if (i ==4) {
+			for (i = 0; i <4; i++)
+				char_array_4[i] = base64_chars.find(char_array_4[i]);
+
+			char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
+			char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
+			char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
+
+			for (i = 0; (i < 3); i++)
+				ret += char_array_3[i];
+			i = 0;
+		}
+	}
+
+	if (i) {
+		for (j = i; j <4; j++)
+			char_array_4[j] = 0;
+
+		for (j = 0; j <4; j++)
+			char_array_4[j] = base64_chars.find(char_array_4[j]);
+
+		char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);
+		char_array_3[1] = ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);
+		char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];
+
+		for (j = 0; (j < i - 1); j++) ret += char_array_3[j];
+	}
+
+	return ret;
+}
diff --git a/src/base64.h b/src/base64.h
new file mode 100644
index 000000000..65d5db8b2
--- /dev/null
+++ b/src/base64.h
@@ -0,0 +1,4 @@
+#include <string>
+
+std::string base64_encode(unsigned char const* , unsigned int len);
+std::string base64_decode(std::string const& s);
diff --git a/src/bridge_gui.cpp b/src/bridge_gui.cpp
index 768691f08..3bf4dbb3b 100644
--- a/src/bridge_gui.cpp
+++ b/src/bridge_gui.cpp
@@ -24,6 +24,7 @@
 #include "cmd_helper.h"
 #include "tunnelbridge_map.h"
 #include "road_gui.h"
+#include "tilehighlight_func.h"
 
 #include "widgets/bridge_widget.h"
 
@@ -72,6 +73,7 @@ void CcBuildBridge(const CommandCost &result, TileIndex end_tile, uint32 p1, uin
 		DiagDirection start_direction = ReverseDiagDir(GetTunnelBridgeDirection(p1));
 		ConnectRoadToStructure(p1, start_direction);
 	}
+	StoreRailPlacementEndpoints(p1, end_tile, (TileX(p1) == TileX(end_tile)) ? TRACK_Y : TRACK_X, false);
 }
 
 /** Window class for handling the bridge-build GUI. */
diff --git a/src/build_vehicle_gui.cpp b/src/build_vehicle_gui.cpp
index 0ac23cfde..551f25438 100644
--- a/src/build_vehicle_gui.cpp
+++ b/src/build_vehicle_gui.cpp
@@ -34,7 +34,7 @@
 #include "autoreplace_func.h"
 
 #include "widgets/build_vehicle_widget.h"
-
+#include "hotkeys.h"
 #include "table/strings.h"
 
 #include "safeguards.h"
@@ -1495,13 +1495,28 @@ struct BuildVehicleWindow : Window {
 	{
 		this->vscroll->SetCapacityFromWidget(this, WID_BV_LIST);
 	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		if (this->owner != _local_company) return ES_NOT_HANDLED;
+		return Window::OnHotkey(hotkey);
+	}
+
+	static HotkeyList hotkeys;
+};
+
+static Hotkey build_vehicle_hotkeys[] = {
+	Hotkey('R', "build_vehicle", WID_BV_BUILD),
+	HOTKEY_LIST_END
 };
+HotkeyList BuildVehicleWindow::hotkeys("build_vehicle", build_vehicle_hotkeys);
 
 static WindowDesc _build_vehicle_desc(
 	WDP_AUTO, "build_vehicle", 240, 268,
 	WC_BUILD_VEHICLE, WC_NONE,
 	WDF_CONSTRUCTION,
-	_nested_build_vehicle_widgets, lengthof(_nested_build_vehicle_widgets)
+	_nested_build_vehicle_widgets, lengthof(_nested_build_vehicle_widgets),
+	&BuildVehicleWindow::hotkeys
 );
 
 void ShowBuildVehicleWindow(TileIndex tile, VehicleType type)
diff --git a/src/cargo_table_gui.cpp b/src/cargo_table_gui.cpp
new file mode 100644
index 000000000..9beef25c9
--- /dev/null
+++ b/src/cargo_table_gui.cpp
@@ -0,0 +1,216 @@
+/* $Id: cargo_table_gui.cpp 21909 2011-01-26 08:14:36Z TheDude $ */
+
+#include "stdafx.h"
+#include "window_gui.h"
+#include "window_func.h"
+#include "strings_func.h"
+#include "company_func.h"
+#include "company_base.h"
+#include "table/strings.h"
+#include "textbuf_gui.h"
+#include "cargotype.h"
+#include "widgets/dropdown_type.h"
+
+#include "widgets/cargo_table_widget.h"
+
+#include "safeguards.h"
+
+static const uint EXP_TOPPADDING = 5;
+static const uint EXP_LINESPACE  = 2;      ///< Amount of vertical space for a horizontal (sub-)total line.
+static const uint EXP_BLOCKSPACE = 10;     ///< Amount of vertical space between two blocks of numbers.
+
+enum CargoOption {
+	WID_CT_OPTION_CARGO_TOTAL = 0,
+	WID_CT_OPTION_CARGO_MONTH,
+};
+
+static void DrawPrice(Money amount, int left, int right, int top)
+{
+	SetDParam(0, amount);
+	DrawString(left, right, top, STR_FINANCES_POSITIVE_INCOME, TC_FROMSTRING, SA_RIGHT);
+}
+
+void InvalidateCargosWindows(CompanyID cid)
+{
+	if (cid == _local_company) SetWindowDirty(WC_STATUS_BAR, 0);
+	SetWindowDirty(WC_CARGOS, cid);
+}
+
+/** Cargos window handler. */
+struct CargosWindow : Window {
+
+	CargoOption cargoPeriod;
+	CargosWindow(WindowDesc *desc, WindowNumber window_number) : Window(desc)
+	{
+		this->InitNested(window_number);
+		this->owner = (Owner)this->window_number;
+		this->cargoPeriod = WID_CT_OPTION_CARGO_TOTAL;
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		if(widget != WID_CT_CAPTION) return;
+		SetDParam(0, (CompanyID)this->window_number);
+		SetDParam(1, (CompanyID)this->window_number);
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		if(widget != WID_CT_HEADER_CARGO) return;
+		this->cargoPeriod = (this->cargoPeriod == WID_CT_OPTION_CARGO_TOTAL) ? WID_CT_OPTION_CARGO_MONTH : WID_CT_OPTION_CARGO_TOTAL;
+		this->SetDirty();
+	}
+
+	void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		uint extra_width = 0;
+		switch(widget){
+			case WID_CT_HEADER_AMOUNT:
+			case WID_CT_HEADER_INCOME:
+				extra_width += 16;
+			case WID_CT_HEADER_CARGO:
+				size->width = 96 + extra_width;
+				size->height = EXP_BLOCKSPACE + EXP_LINESPACE;
+				break;
+
+			case WID_CT_AMOUNT:
+			case WID_CT_INCOME:
+					extra_width += 16;
+			case WID_CT_LIST:
+				size->width = 96 + extra_width;
+				size->height = (_sorted_standard_cargo_specs_size + 3) * (EXP_BLOCKSPACE + EXP_LINESPACE);
+				break;
+		}
+	}
+
+	void DrawWidget(const Rect &r, int widget) const
+	{
+		int rect_x = (r.left + WD_FRAMERECT_LEFT);
+		int y = r.top;
+		const Company *c = Company::Get((CompanyID)this->window_number);
+		uint32 sum_cargo_amount = 0;
+		Money sum_cargo_income = 0;
+
+		switch(widget){
+			case WID_CT_HEADER_CARGO:
+				//DrawString(r.left, r.right, y, STR_TOOLBAR_CARGOS_HEADER_CARGO, TC_FROMSTRING, SA_LEFT);
+				y += EXP_BLOCKSPACE + EXP_LINESPACE;
+				break;
+			case WID_CT_HEADER_AMOUNT:
+				DrawString(r.left, r.right, y, STR_TOOLBAR_CARGOS_HEADER_AMOUNT, TC_FROMSTRING, SA_CENTER);
+				y += EXP_BLOCKSPACE + EXP_LINESPACE;
+				break;
+			case WID_CT_HEADER_INCOME:
+				DrawString(r.left, r.right, y, STR_TOOLBAR_CARGOS_HEADER_INCOME, TC_FROMSTRING, SA_RIGHT);
+				y += EXP_BLOCKSPACE + EXP_LINESPACE;
+				break;
+
+			case WID_CT_LIST:{
+				y += EXP_TOPPADDING; //top padding
+				for (int i = 0; i < _sorted_standard_cargo_specs_size; i++) {
+					const CargoSpec *cs = _sorted_cargo_specs[i];
+
+					GfxFillRect(rect_x, y, rect_x + 8, y + 5, 0);
+					GfxFillRect(rect_x + 1, y + 1, rect_x + 7, y + 4, cs->legend_colour); //coloured cargo rectangles
+
+					SetDParam(0, cs->name);
+					DrawString(r.left + 14, r.right, y, STR_TOOLBAR_CARGOS_NAME); //cargo name
+
+					y += EXP_BLOCKSPACE + EXP_LINESPACE;	//padding
+				}
+
+				//total
+				GfxFillRect(rect_x, y, rect_x + 96, y, 0);
+				y += EXP_BLOCKSPACE + EXP_LINESPACE;
+
+				StringID string_to_draw = STR_TOOLBAR_CARGOS_HEADER_TOTAL;
+				if(this->cargoPeriod != WID_CT_OPTION_CARGO_TOTAL) string_to_draw++;
+				DrawString(r.left, r.right, y, string_to_draw);
+				break;
+			}
+			case WID_CT_AMOUNT:
+				y += EXP_TOPPADDING;
+				for (int i = 0; i < _sorted_standard_cargo_specs_size; i++) {
+					const CargoSpec *cs = _sorted_cargo_specs[i];
+
+					if(this->cargoPeriod == WID_CT_OPTION_CARGO_MONTH){
+						sum_cargo_amount += c->cargo_units_period[0][cs->Index()];
+						SetDParam(0,  c->cargo_units_period[0][cs->Index()]);
+					}
+					else{
+						sum_cargo_amount += c->cargo_units[cs->Index()];
+						SetDParam(0,  c->cargo_units[cs->Index()]);
+					}
+
+					DrawString(r.left, r.right, y, STR_TOOLBAR_CARGOS_UNITS, TC_FROMSTRING, SA_RIGHT); //cargo amount in pcs
+					y += EXP_BLOCKSPACE + EXP_LINESPACE;
+				}
+
+				//total
+				GfxFillRect(rect_x, y, rect_x + 108, y, 0);
+				y += EXP_BLOCKSPACE + EXP_LINESPACE;
+				SetDParam(0, sum_cargo_amount);
+				DrawString(r.left, r.right, y, STR_TOOLBAR_CARGOS_UNITS_TOTAL, TC_FROMSTRING, SA_RIGHT);
+				break;
+
+			case WID_CT_INCOME:
+				y += EXP_TOPPADDING;
+				for (int i = 0; i < _sorted_standard_cargo_specs_size; i++) {
+					const CargoSpec *cs = _sorted_cargo_specs[i];
+
+					if(this->cargoPeriod == WID_CT_OPTION_CARGO_MONTH){
+						sum_cargo_income += c->cargo_income_period[0][cs->Index()];
+						DrawPrice(c->cargo_income_period[0][cs->Index()], r.left, r.right, y); //cargo income in money
+					}
+					else{
+						sum_cargo_income += c->cargo_income[cs->Index()];
+						DrawPrice(c->cargo_income[cs->Index()], r.left, r.right, y); //cargo income in money
+					}
+
+					y += EXP_BLOCKSPACE + EXP_LINESPACE;
+				}
+
+				//total
+				GfxFillRect(rect_x, y, rect_x + 108, y, 0);
+				y += EXP_BLOCKSPACE + EXP_LINESPACE;
+				DrawPrice(sum_cargo_income, r.left, r.right, y);
+				break;
+		}
+	}
+};
+
+static const NWidgetPart _nested_cargos_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, WID_CT_CAPTION), SetDataTip(STR_TOOLBAR_CARGOS_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY), SetResize(1, 1),
+		NWidget(NWID_HORIZONTAL), SetPadding(WD_FRAMERECT_TOP, WD_FRAMERECT_RIGHT, WD_FRAMERECT_BOTTOM, WD_FRAMERECT_LEFT), SetPIP(0, 9, 0),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_CT_HEADER_CARGO), SetMinimalSize(96, 16),SetFill(1, 0), SetPadding(2,2,2,2), SetDataTip(STR_TOOLBAR_CARGOS_HEADER_CARGO, STR_TOOLBAR_CARGOS_HEADER_CARGO),
+			NWidget(WWT_EMPTY, COLOUR_GREY, WID_CT_HEADER_AMOUNT), SetMinimalSize(108, 16), SetFill(1, 0), SetPadding(2,2,2,2), SetDataTip(STR_TOOLBAR_CARGOS_HEADER_AMOUNT, STR_TOOLBAR_CARGOS_HEADER_AMOUNT),
+			NWidget(WWT_EMPTY, COLOUR_GREY, WID_CT_HEADER_INCOME), SetMinimalSize(108, 16), SetFill(1, 0), SetPadding(2,2,2,2), SetDataTip(STR_TOOLBAR_CARGOS_HEADER_INCOME, STR_TOOLBAR_CARGOS_HEADER_INCOME),
+		EndContainer(),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY), SetResize(1, 1),
+		NWidget(NWID_HORIZONTAL), SetPadding(WD_FRAMERECT_TOP, WD_FRAMERECT_RIGHT, WD_FRAMERECT_BOTTOM, WD_FRAMERECT_LEFT), SetPIP(0, 9, 0),
+			NWidget(WWT_EMPTY, COLOUR_GREY, WID_CT_LIST),SetMinimalSize(96, 0),SetFill(1, 0), SetPadding(2,2,2,2), SetResize(1, 1),
+			NWidget(WWT_EMPTY, COLOUR_GREY, WID_CT_AMOUNT),SetMinimalSize(108, 0),SetFill(1, 0), SetPadding(2,2,2,2), SetResize(1, 1),
+			NWidget(WWT_EMPTY, COLOUR_GREY, WID_CT_INCOME),SetMinimalSize(108, 0),SetFill(1, 0), SetPadding(2,2,2,2), SetResize(1, 1),			
+		EndContainer(),
+	EndContainer(),
+};
+
+static WindowDesc _cargos_desc(
+	WDP_AUTO, "cargo_table_company", 0, 0,
+	WC_CARGOS, WC_NONE,
+	WDF_CONSTRUCTION,
+	_nested_cargos_widgets, lengthof(_nested_cargos_widgets)
+);
+
+void ShowCompanyCargos(CompanyID company)
+{
+	if (!Company::IsValidID(company)) return;
+	AllocateWindowDescFront<CargosWindow>(&_cargos_desc, company);
+}
diff --git a/src/cargo_table_gui.h b/src/cargo_table_gui.h
new file mode 100644
index 000000000..a997899ae
--- /dev/null
+++ b/src/cargo_table_gui.h
@@ -0,0 +1,14 @@
+/* $Id: cargo_table_gui.h 21700 2011-01-03 11:55:08Z  $ */
+
+/** @file cargo_table_gui.h GUI Functions related to cargos. */
+
+#ifndef CARGO_TABLE_H
+#define CARGO_TABLE_H
+
+#include "company_type.h"
+#include "gfx_type.h"
+
+void ShowCompanyCargos(CompanyID company);
+void InvalidateCargosWindows(CompanyID cid);
+
+#endif /* CARGO_TABLE_H */
diff --git a/src/command.cpp b/src/command.cpp
index 70258aaa1..b3fda2fbd 100644
--- a/src/command.cpp
+++ b/src/command.cpp
@@ -24,9 +24,12 @@
 #include "company_func.h"
 #include "company_base.h"
 #include "signal_func.h"
+#include "window_func.h"
 #include "core/backup_type.hpp"
 #include "object_base.h"
 
+#include "watch_gui_1.h"
+
 #include "table/strings.h"
 
 #include "safeguards.h"
@@ -551,14 +554,19 @@ bool DoCommandP(const CommandContainer *container, bool my_cmd)
 bool DoCommandP(TileIndex tile, uint32 p1, uint32 p2, uint32 cmd, CommandCallback *callback, const char *text, bool my_cmd)
 {
 	/* Cost estimation is generally only done when the
-	 * local user presses shift while doing somthing.
-	 * However, in case of incoming network commands,
-	 * map generation or the pause button we do want
-	 * to execute. */
-	bool estimate_only = _shift_pressed && IsLocalCompany() &&
-			!_generating_world &&
-			!(cmd & CMD_NETWORK_COMMAND) &&
-			(cmd & CMD_ID_MASK) != CMD_PAUSE;
+	 * local user presses shift while constructing somthing.
+	 * However, in case of incoming network commands or
+	 * map generation we do want to execute. */
+	bool estimate_only = false;
+	switch (_command_proc_table[cmd & CMD_ID_MASK].type) {
+		case CMDT_LANDSCAPE_CONSTRUCTION:
+		case CMDT_VEHICLE_CONSTRUCTION:
+			estimate_only = _shift_pressed && IsLocalCompany() &&
+					!_generating_world && !(cmd & CMD_NETWORK_COMMAND);
+			break;
+		default:
+			break; // just to silence warnings
+	}
 
 	/* We're only sending the command, so don't do
 	 * fancy things for 'success'. */
@@ -764,6 +772,16 @@ CommandCost DoCommandPInternal(TileIndex tile, uint32 p1, uint32 p2, uint32 cmd,
 	/* update signals if needed */
 	UpdateSignalsInBuffer();
 
+  /* Send Tile Number to Watching Company Windows - Original */
+	int watching_window = 0;
+	WatchCompany1 *wc;
+	wc = dynamic_cast<WatchCompany1*>(FindWindowById(WC_WATCH_COMPANY1, watching_window));
+	while (wc!=NULL) {
+		wc->OnDoCommand( _current_company, tile );
+		watching_window++;
+		wc = dynamic_cast<WatchCompany1*>(FindWindowById(WC_WATCH_COMPANY1, watching_window));
+	}
+
 	return_dcpi(res2);
 }
 #undef return_dcpi
diff --git a/src/command_type.h b/src/command_type.h
index e7512f11d..fe504498c 100644
--- a/src/command_type.h
+++ b/src/command_type.h
@@ -375,6 +375,7 @@ DECLARE_ENUM_AS_BIT_SET(DoCommandFlag)
  */
 enum FlaggedCommands {
 	CMD_NETWORK_COMMAND       = 0x0100, ///< execute the command without sending it on the network
+	CMD_NO_ESTIMATE           = 0x0200, ///< execute command instead of doing estimate even if shift is pressed
 	CMD_FLAGS_MASK            = 0xFF00, ///< mask for all command flags
 	CMD_ID_MASK               = 0x00FF, ///< mask for the command ID
 };
diff --git a/src/commands_token_gui.cpp b/src/commands_token_gui.cpp
new file mode 100644
index 000000000..d1af5ec44
--- /dev/null
+++ b/src/commands_token_gui.cpp
@@ -0,0 +1,130 @@
+/* $Id: commands_token_gui.cpp	23663 2011-12-23 18:01:50	me $ */
+
+#include "stdafx.h"
+#include "widget_type.h"
+#include "window_func.h"
+#include "strings_func.h"
+#include "commands_token_gui.h"
+#include "network/network.h"
+#include "network/network_func.h"
+#include "network/network_base.h"
+#include "network/network_type.h"
+#include "table/strings.h"
+#include "console_func.h"
+#include "error.h"
+#include "base64.h"
+#include <iostream>
+
+#include "safeguards.h"
+
+enum TokenLoginWidgets {
+	NIC_TOKEN_USER,
+	NIC_TOKEN_LOGIN,
+	NIC_TOKEN_COMMUNITY,
+	NIC_TOKEN_WEBSITE,
+	NIC_TOKEN_WIKI,
+	NIC_OTHER_WIKI_RULES,
+	NIC_OTHER_IRC_CHAT,
+	NIC_OTHER_IRC_SERVERS,
+};
+
+class TokenLoginGui : public Window
+{
+	public:
+		TokenLoginGui(WindowDesc *desc, int window_number) : Window(desc)
+		{
+			this->InitNested(window_number);
+		}
+
+	virtual void OnPaint()
+	{
+		this->DrawWidgets();
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		if(widget == NIC_TOKEN_USER) SetDParamStr(0, (char*)_settings_client.network.community_user[_settings_client.gui.community-1]);
+		else if(widget == NIC_TOKEN_COMMUNITY) SetDParam(0, (STR_CC_SEPARATOR_DEFAULT + (uint16)_settings_client.gui.community));
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		extern void OpenBrowser(const char *url);
+		switch (widget) {
+			case NIC_TOKEN_LOGIN:
+        if ((_networking) && (_settings_client.gui.community != 0)) {
+          //LoginToken();
+          //loginmgr.initiateLoginSequence();
+          CommunityLoginManagerSend();
+        } else {
+          // do nothing
+        }
+				break;
+			case NIC_TOKEN_WEBSITE:	
+          if(_settings_client.gui.community == 1) OpenBrowser("http://www.n-ice.org/openttd");
+          else if(_settings_client.gui.community == 2) OpenBrowser("http://openttd.btpro.nl");
+				break;
+			case NIC_TOKEN_WIKI:	
+          if(_settings_client.gui.community == 1) OpenBrowser("http://www.n-ice.org/openttd");
+          else if(_settings_client.gui.community == 2) OpenBrowser("http://openttd.btpro.nl/contact-us/vip-membership");
+				break;
+			case NIC_OTHER_WIKI_RULES:				
+				if(_settings_client.gui.community == 1) OpenBrowser("https://wiki.x-base.info/OpenTTD/Rules");
+				else if(_settings_client.gui.community == 2) OpenBrowser("http://openttd.btpro.nl/wiki/index.php/Server_Rules");
+				break;
+			case NIC_OTHER_IRC_CHAT:				
+				if(_settings_client.gui.community == 1) OpenBrowser("http://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2FOpenTTD.Chat");
+				else if(_settings_client.gui.community == 2) OpenBrowser("http://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2Fbtpro-chat");
+				break;
+			case NIC_OTHER_IRC_SERVERS:				
+				if(_settings_client.gui.community == 1) OpenBrowser("http://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2FOpenTTD");
+				else if(_settings_client.gui.community == 2) OpenBrowser("http://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2Fbtpro-openttd");
+				break;
+		}
+	}
+};
+
+static const NWidgetPart _nested_token_login_widgets[] = {
+	/* Title Bar with close box, title, shade and stick boxes */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY), SetDataTip(STR_CC_GLOBAL_COMMANDS_TITLE, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY), SetFill(0, 1), SetPIP(2, 2, 2),
+		NWidget(NWID_VERTICAL), SetPadding(0, 5, 0, 5),
+			NWidget(WWT_TEXT, COLOUR_BROWN, NIC_TOKEN_USER), SetDataTip(STR_CC_TOKEN_WELCOME, STR_NULL), SetMinimalSize(110, 16),
+			NWidget(WWT_TEXT, COLOUR_BROWN), SetDataTip(STR_CC_TOKEN_CLICKME, STR_NULL), SetMinimalSize(110, 16),
+			NWidget(NWID_HORIZONTAL), SetPIP(2, 2, 2),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, NIC_TOKEN_LOGIN), SetMinimalSize(105, 40),SetFill(1, 0), SetDataTip(STR_CC_TOKEN_LOGIN, STR_CC_TOKEN_LOGIN_TOOLTIP),
+			EndContainer(),
+			NWidget(WWT_TEXT, COLOUR_BROWN), SetDataTip(STR_CC_TOKEN_ENJOY, STR_NULL), SetMinimalSize(110, 16),
+			NWidget(WWT_TEXT, COLOUR_BROWN, NIC_TOKEN_COMMUNITY), SetDataTip(STR_CC_SEPARATOR, STR_NULL), SetMinimalSize(110, 16),
+			NWidget(NWID_HORIZONTAL ), SetPadding(5, 0, 5, 0),
+        NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, NIC_TOKEN_WEBSITE), SetMinimalSize(120, 14),SetFill(1, 0), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_WEBSITE, STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_WEBSITE_TOOLTIP),
+        NWidget(WWT_TEXT, COLOUR_BROWN), SetDataTip(STR_CC_IRC_LINK_SERVERS_SPACER, STR_NULL), SetMinimalSize(6, 14),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, NIC_TOKEN_WIKI ), SetMinimalSize(57, 14),SetFill(1, 0), SetDataTip( STR_CC_VIP, STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_VIP_TOOLTIP ),
+			EndContainer(),
+			NWidget(NWID_HORIZONTAL ), SetPadding(5, 0, 5, 0),
+				NWidget( WWT_PUSHTXTBTN, COLOUR_GREY, NIC_OTHER_IRC_CHAT ), SetMinimalSize(57, 14),SetFill(1, 0), SetDataTip( STR_CC_IRC_LINK_CHAT, STR_CC_IRC_LINK_CHAT_TOOLTIP ),
+				NWidget(WWT_TEXT, COLOUR_BROWN), SetDataTip(STR_CC_IRC_LINK_SERVERS_SPACER, STR_NULL), SetMinimalSize(6, 14),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, NIC_OTHER_IRC_SERVERS ), SetMinimalSize(57, 14),SetFill(1, 0), SetDataTip( STR_CC_IRC_LINK_SERVERS, STR_CC_IRC_LINK_SERVERS_TOOLTIP ),
+			EndContainer(),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, NIC_OTHER_WIKI_RULES ), SetMinimalSize(120, 14),SetFill(1, 0), SetDataTip( STR_CC_WIKI_RULES_PAGE, STR_CC_WIKI_RULES_PAGE_TOOLTIP ),
+		EndContainer(),
+		NWidget(NWID_SPACER), SetMinimalSize(2, 2), SetFill(0, 1),
+	EndContainer(),
+};
+
+static WindowDesc _token_login_desc(
+	WDP_CENTER, "commands_token_gui", 0, 0,
+	WC_CC_TOKENLOGIN, WC_NONE,
+	0,
+	_nested_token_login_widgets, lengthof(_nested_token_login_widgets)
+);
+
+void ShowTokenLogin()
+{	
+	AllocateWindowDescFront<TokenLoginGui>(&_token_login_desc, 0);
+}
diff --git a/src/commands_token_gui.h b/src/commands_token_gui.h
new file mode 100644
index 000000000..9779a6fbb
--- /dev/null
+++ b/src/commands_token_gui.h
@@ -0,0 +1,12 @@
+/* $Id: commands_token_gui.h $ */
+
+#ifndef COMMANDS_TOKEN_GUI_H
+#define COMMANDS_TOKEN_GUI_H
+
+#include "window_gui.h"
+#include "company_base.h"
+
+//void LoginToken();
+void ShowTokenLogin();
+
+#endif
diff --git a/src/company_base.h b/src/company_base.h
index 9d2bc9000..4eeba5b11 100644
--- a/src/company_base.h
+++ b/src/company_base.h
@@ -17,6 +17,7 @@
 #include "autoreplace_type.h"
 #include "tile_type.h"
 #include "settings_type.h"
+#include "cargo_type.h"
 #include "group.h"
 
 /** Statistics about the economy. */
@@ -26,6 +27,7 @@ struct CompanyEconomyEntry {
 	CargoArray delivered_cargo; ///< The amount of delivered cargo.
 	int32 performance_history;  ///< Company score (scale 0-1000)
 	Money company_value;        ///< The value of the company.
+	Money cargo_income[NUM_CARGO]; ///< Cargo income from each cargo type
 };
 
 struct CompanyInfrastructure {
@@ -129,6 +131,12 @@ struct Company : CompanyPool::PoolItem<&_company_pool>, CompanyProperties {
 
 	CompanyInfrastructure infrastructure; ///< NOSAVE: Counts of company owned infrastructure.
 
+	uint32 cargo_units[NUM_CARGO];   ///< Total amount of transported cargo for each cargo ID
+	Money cargo_income[NUM_CARGO];   ///< Total income from transported cargo for each cargo ID
+
+	uint32 cargo_units_period[2][NUM_CARGO];   ///< Monthly amount of transported cargo for each cargo ID 
+	Money cargo_income_period[2][NUM_CARGO];   ///< Monthly income from transported cargo for each cargo ID
+
 	/**
 	 * Is this company a valid company, controlled by the computer (a NoAI program)?
 	 * @param index Index in the pool.
diff --git a/src/company_cmd.cpp b/src/company_cmd.cpp
index 6194ebee8..651b6531d 100644
--- a/src/company_cmd.cpp
+++ b/src/company_cmd.cpp
@@ -37,6 +37,7 @@
 #include "goal_base.h"
 #include "story_base.h"
 
+#include "cargo_type.h"
 #include "table/strings.h"
 
 #include "safeguards.h"
@@ -69,6 +70,7 @@ Company::Company(uint16 name_1, bool is_ai)
 
 	for (uint j = 0; j < 4; j++) this->share_owners[j] = COMPANY_SPECTATOR;
 	InvalidateWindowData(WC_PERFORMANCE_DETAIL, 0, INVALID_COMPANY);
+	InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
 }
 
 /** Destructor. */
@@ -89,6 +91,7 @@ void Company::PostDestructor(size_t index)
 	InvalidateWindowData(WC_PERFORMANCE_DETAIL, 0, (int)index);
 	InvalidateWindowData(WC_COMPANY_LEAGUE, 0, 0);
 	InvalidateWindowData(WC_LINKGRAPH_LEGEND, 0);
+	InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
 	/* If the currently shown error message has this company in it, then close it. */
 	InvalidateWindowData(WC_ERRMSG, 0);
 }
@@ -585,9 +588,28 @@ Company *DoStartupNewCompany(bool is_ai, CompanyID company = INVALID_COMPANY)
 	AI::BroadcastNewEvent(new ScriptEventCompanyNew(c->index), c->index);
 	Game::NewEvent(new ScriptEventCompanyNew(c->index));
 
+	if (!is_ai) UpdateAllTownVirtCoords(); //coloured rating
+
+	for (uint j = 0; j < NUM_CARGO; j++) {
+		c->cargo_income[j] = 0;
+		c->cargo_units[j] = 0;
+	}
+	cargo_iam_free(c);
+
+  if (!is_ai) UpdateAllTownVirtCoords(); //coloured rating
+
 	return c;
 }
 
+void cargo_iam_free(Company *c){
+	for (uint j = 0; j < NUM_CARGO; j++) {
+		c->cargo_units_period[0][j] = 0;
+		c->cargo_units_period[1][j] = 0;
+		c->cargo_income_period[0][j] = 0;
+		c->cargo_income_period[1][j] = 0;
+	}
+}
+
 /** Start the next competitor now. */
 void StartupCompanies()
 {
@@ -1085,6 +1107,7 @@ CommandCost CmdRenameCompany(TileIndex tile, DoCommandFlag flags, uint32 p1, uin
 		Company *c = Company::Get(_current_company);
 		free(c->name);
 		c->name = reset ? NULL : stredup(text);
+		InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
 		MarkWholeScreenDirty();
 		CompanyAdminUpdate(c);
 	}
diff --git a/src/company_func.h b/src/company_func.h
index 29650d78c..d6a2d28a1 100644
--- a/src/company_func.h
+++ b/src/company_func.h
@@ -31,6 +31,7 @@ void SubtractMoneyFromCompany(CommandCost cost);
 void SubtractMoneyFromCompanyFract(CompanyID company, CommandCost cost);
 CommandCost CheckOwnership(Owner owner, TileIndex tile = 0);
 CommandCost CheckTileOwnership(TileIndex tile);
+void cargo_iam_free(Company *c);
 
 extern CompanyByte _local_company;
 extern CompanyByte _current_company;
diff --git a/src/crashlog.cpp b/src/crashlog.cpp
index 2bc891dcf..2029bacb0 100644
--- a/src/crashlog.cpp
+++ b/src/crashlog.cpp
@@ -119,7 +119,7 @@ char *CrashLog::LogCompiler(char *buffer, const char *last) const
 char *CrashLog::LogOpenTTDVersion(char *buffer, const char *last) const
 {
 	return buffer + seprintf(buffer, last,
-			"OpenTTD version:\n"
+			"OpenTTD version: Patched admin client (Build 19202) \n\n\n"
 			" Version:    %s (%d)\n"
 			" NewGRF ver: %08x\n"
 			" Bits:       %d\n"
@@ -333,7 +333,7 @@ char *CrashLog::LogRecentNews(char *buffer, const char *last) const
 char *CrashLog::FillCrashLog(char *buffer, const char *last) const
 {
 	time_t cur_time = time(NULL);
-	buffer += seprintf(buffer, last, "*** OpenTTD Crash Report ***\n\n");
+	buffer += seprintf(buffer, last, "*** OpenTTD Crash Report ***\nPatched client\nPlease, unless you encounter same bug with unpatched OpenTTD version, report bug to admins of your community.\n\n");
 	buffer += seprintf(buffer, last, "Crash at: %s", asctime(gmtime(&cur_time)));
 
 	YearMonthDay ymd;
diff --git a/src/depot_gui.cpp b/src/depot_gui.cpp
index 39accd65f..b3c4a4bb4 100644
--- a/src/depot_gui.cpp
+++ b/src/depot_gui.cpp
@@ -28,7 +28,7 @@
 #include "vehiclelist.h"
 #include "order_backup.h"
 #include "zoom_func.h"
-
+#include "hotkeys.h"
 #include "widgets/depot_widget.h"
 
 #include "table/strings.h"
@@ -81,34 +81,6 @@ static const NWidgetPart _nested_train_depot_widgets[] = {
 	EndContainer(),
 };
 
-static WindowDesc _train_depot_desc(
-	WDP_AUTO, "depot_train", 362, 123,
-	WC_VEHICLE_DEPOT, WC_NONE,
-	0,
-	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets)
-);
-
-static WindowDesc _road_depot_desc(
-	WDP_AUTO, "depot_roadveh", 316, 97,
-	WC_VEHICLE_DEPOT, WC_NONE,
-	0,
-	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets)
-);
-
-static WindowDesc _ship_depot_desc(
-	WDP_AUTO, "depot_ship", 306, 99,
-	WC_VEHICLE_DEPOT, WC_NONE,
-	0,
-	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets)
-);
-
-static WindowDesc _aircraft_depot_desc(
-	WDP_AUTO, "depot_aircraft", 332, 99,
-	WC_VEHICLE_DEPOT, WC_NONE,
-	0,
-	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets)
-);
-
 extern void DepotSortList(VehicleList *list);
 
 /**
@@ -1079,7 +1051,23 @@ struct DepotWindow : Window {
 
 		return ES_NOT_HANDLED;
 	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		if (this->owner != _local_company) return ES_NOT_HANDLED;
+		return Window::OnHotkey(hotkey);
+	}
+
+	static HotkeyList hotkeys;
+};
+
+static Hotkey depot_hotkeys[] = {
+	Hotkey(WKC_CTRL | 'F', "depot_go_all", WID_D_START_ALL),
+	Hotkey('R', "depot_build_vehicle", WID_D_BUILD),
+	Hotkey(WKC_NONE, "depot_clone_vehicle", WID_D_CLONE),
+	HOTKEY_LIST_END
 };
+HotkeyList DepotWindow::hotkeys("depot_gui", depot_hotkeys);
 
 static void DepotSellAllConfirmationCallback(Window *win, bool confirmed)
 {
@@ -1091,6 +1079,38 @@ static void DepotSellAllConfirmationCallback(Window *win, bool confirmed)
 	}
 }
 
+static WindowDesc _train_depot_desc(
+	WDP_AUTO, "depot_train", 362, 123,
+	WC_VEHICLE_DEPOT, WC_NONE,
+	0,
+	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets),
+	&DepotWindow::hotkeys
+);
+
+static WindowDesc _road_depot_desc(
+	WDP_AUTO, "depot_roadveh", 316, 97,
+	WC_VEHICLE_DEPOT, WC_NONE,
+	0,
+	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets),
+	&DepotWindow::hotkeys
+);
+
+static WindowDesc _ship_depot_desc(
+	WDP_AUTO, "depot_ship", 306, 99,
+	WC_VEHICLE_DEPOT, WC_NONE,
+	0,
+	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets),
+	&DepotWindow::hotkeys
+);
+
+static WindowDesc _aircraft_depot_desc(
+	WDP_AUTO, "depot_aircraft", 332, 99,
+	WC_VEHICLE_DEPOT, WC_NONE,
+	0,
+	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets),
+	&DepotWindow::hotkeys
+);
+
 /**
  * Opens a depot window
  * @param tile The tile where the depot/hangar is located
diff --git a/src/economy.cpp b/src/economy.cpp
index bbb3100bd..0255b9dad 100644
--- a/src/economy.cpp
+++ b/src/economy.cpp
@@ -40,6 +40,7 @@
 #include "subsidy_func.h"
 #include "station_base.h"
 #include "waypoint_base.h"
+#include "triphistory.h"
 #include "economy_base.h"
 #include "core/pool_func.hpp"
 #include "core/backup_type.hpp"
@@ -53,6 +54,7 @@
 
 #include "table/strings.h"
 #include "table/pricebase.h"
+#include "cargo_table_gui.h"
 
 #include "safeguards.h"
 
@@ -1136,6 +1138,16 @@ static Money DeliverGoods(int num_pieces, CargoID cargo_type, StationID dest, Ti
 		}
 	}
 
+	company->cargo_income[cargo_type] += profit;
+	company->cargo_units[cargo_type] += num_pieces;
+
+	company->cargo_income_period[0][cargo_type] += profit;
+	company->cargo_units_period[0][cargo_type] += num_pieces;
+
+	company->cur_economy.cargo_income[cargo_type] += profit;	
+
+	InvalidateCargosWindows(company->index);
+
 	return profit;
 }
 
@@ -1209,6 +1221,8 @@ CargoPayment::~CargoPayment()
 				this->front->z_pos, -this->visual_profit);
 	}
 
+	this->front->trip_history.AddValue(this->route_profit, _date);
+	InvalidateWindowData(WC_VEHICLE_TRIP_HISTORY, this->front->index);
 	cur_company.Restore();
 }
 
@@ -1972,6 +1986,11 @@ void CompaniesMonthlyLoop()
 	}
 	CompaniesPayInterest();
 	HandleEconomyFluctuations();
+
+	Company *c;
+	FOR_ALL_COMPANIES(c){
+		cargo_iam_free(c);
+	}
 }
 
 static void DoAcquireCompany(Company *c)
diff --git a/src/gfx.cpp b/src/gfx.cpp
index 7a6b827b7..2327070a6 100644
--- a/src/gfx.cpp
+++ b/src/gfx.cpp
@@ -34,6 +34,7 @@ bool _fullscreen;
 byte _support8bpp;
 CursorVars _cursor;
 bool _ctrl_pressed;   ///< Is Ctrl pressed?
+bool _alt_pressed;    ///< Is Alt pressed?
 bool _shift_pressed;  ///< Is Shift pressed?
 byte _fast_forward;
 bool _left_button_down;     ///< Is left mouse button pressed?
diff --git a/src/gfx_func.h b/src/gfx_func.h
index 9f7cb9153..94a1aede5 100644
--- a/src/gfx_func.h
+++ b/src/gfx_func.h
@@ -55,6 +55,7 @@ extern bool _fullscreen;
 extern byte _support8bpp;
 extern CursorVars _cursor;
 extern bool _ctrl_pressed;   ///< Is Ctrl pressed?
+extern bool _alt_pressed;    ///< Is Alt pressed?
 extern bool _shift_pressed;  ///< Is Shift pressed?
 extern byte _fast_forward;
 
diff --git a/src/gfxinit.cpp b/src/gfxinit.cpp
index 3613ce0d8..ce346286f 100644
--- a/src/gfxinit.cpp
+++ b/src/gfxinit.cpp
@@ -193,6 +193,8 @@ static void LoadSpriteTables()
 		);
 	}
 
+	LoadGrfFile("innerhighlight.grf", SPR_INNER_HIGHLIGHT_BASE, i++);
+
 	/* Initialize the unicode to sprite mapping table */
 	InitializeUnicodeGlyphMap();
 
diff --git a/src/graph_gui.cpp b/src/graph_gui.cpp
index 39df8ab6e..f45241288 100644
--- a/src/graph_gui.cpp
+++ b/src/graph_gui.cpp
@@ -103,6 +103,24 @@ struct GraphLegendWindow : Window {
 	}
 };
 
+/** Construct the row containing the digit keys. */
+static NWidgetBase *MakeCargoButtons(int *biggest_index)
+{
+	NWidgetVertical *ver = new NWidgetVertical;
+
+	for (int i = 0; i < _sorted_standard_cargo_specs_size; i++) {
+		//NWidgetBackground *leaf = new NWidgetBackground(WWT_PANEL, COLOUR_ORANGE, WID_CPR_CARGO_FIRST + i, NULL);
+		//try to use matrix instead of cargo_first
+		NWidgetBackground *leaf = new NWidgetBackground(WWT_PANEL, COLOUR_ORANGE, WID_CPR_MATRIX + i, NULL);
+		leaf->tool_tip = STR_GRAPH_CARGO_PAYMENT_TOGGLE_CARGO;
+		leaf->SetFill(1, 0);
+		leaf->SetLowered(true);
+		ver->Add(leaf);
+	}
+	*biggest_index = WID_CPR_MATRIX + _sorted_standard_cargo_specs_size - 1;
+	return ver;
+}
+
 /**
  * Construct a vertical list of buttons, one for each company.
  * @param biggest_index Storage for collecting the biggest index used in the returned tree.
@@ -533,6 +551,25 @@ public:
 		return INVALID_DATAPOINT;
 	}
 
+	void UpdateExcludedData()
+	{
+		this->excluded_data = 0;
+
+		int i = 0;
+		const CargoSpec *cs;
+		FOR_ALL_SORTED_STANDARD_CARGOSPECS(cs) {
+			if (HasBit(_legend_excluded_cargo, cs->Index())) SetBit(this->excluded_data, i);
+			i++;
+		}
+	}
+
+	void UpdateLoweredWidgets()
+	{
+		for (int i = 0; i < _sorted_standard_cargo_specs_size; i++) {
+			this->SetWidgetLoweredState(WID_CPR_MATRIX + i, !HasBit(this->excluded_data, i));
+		}
+	}
+
 	virtual void OnClick(Point pt, int widget, int click_count)
 	{
 		/* Clicked on legend? */
@@ -674,8 +711,60 @@ struct IncomeGraphWindow : BaseGraphWindow {
 
 	virtual OverflowSafeInt64 GetGraphData(const Company *c, int j)
 	{
+		if(_legend_excluded_cargo == 0){ 
 		return c->old_economy[j].income;
 	}
+		uint total_income = 0;
+		const CargoSpec *cs;
+		FOR_ALL_SORTED_STANDARD_CARGOSPECS(cs) {
+			if (!HasBit(_legend_excluded_cargo, cs->Index())){
+				total_income += c->old_economy[j].cargo_income[cs->Index()];
+			}
+		}
+		return total_income;
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)	
+	{
+		if (widget < WID_CPR_MATRIX) {
+			BaseGraphWindow::UpdateWidgetSize(widget, size, padding, fill, resize);
+			return;
+		}
+
+		const CargoSpec *cs = _sorted_cargo_specs[widget - WID_CPR_MATRIX];
+		SetDParam(0, cs->name);
+		Dimension d = GetStringBoundingBox(STR_GRAPH_CARGO_PAYMENT_CARGO);
+		d.width += 14; // colour field
+		d.width += WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+		d.height += WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+		*size = maxdim(d, *size);
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		if (widget < WID_CPR_MATRIX) {
+			BaseGraphWindow::DrawWidget(r, widget);
+			return;
+		}
+
+		const CargoSpec *cs = _sorted_cargo_specs[widget - WID_CPR_MATRIX];
+		bool rtl = _current_text_dir == TD_RTL;
+
+		/* Since the buttons have no text, no images,
+		 * both the text and the coloured box have to be manually painted.
+		 * clk_dif will move one pixel down and one pixel to the right
+		 * when the button is clicked */
+		byte clk_dif = this->IsWidgetLowered(widget) ? 1 : 0;
+		int x = r.left + WD_FRAMERECT_LEFT;
+		int y = r.top;
+
+		int rect_x = clk_dif + (rtl ? r.right - 12 : r.left + WD_FRAMERECT_LEFT);
+
+		GfxFillRect(rect_x, y + clk_dif, rect_x + 8, y + 5 + clk_dif, PC_BLACK);
+		GfxFillRect(rect_x + 1, y + 1 + clk_dif, rect_x + 7, y + 4 + clk_dif, cs->legend_colour);
+		SetDParam(0, cs->name);
+		DrawString(rtl ? r.left : x + 14 + clk_dif, (rtl ? r.right - 14 + clk_dif : r.right), y + clk_dif, STR_GRAPH_CARGO_PAYMENT_CARGO);
+	}	
 };
 
 static const NWidgetPart _nested_income_graph_widgets[] = {
@@ -690,6 +779,14 @@ static const NWidgetPart _nested_income_graph_widgets[] = {
 	NWidget(WWT_PANEL, COLOUR_GREY, WID_CV_BACKGROUND),
 		NWidget(NWID_HORIZONTAL),
 			NWidget(WWT_EMPTY, COLOUR_GREY, WID_CV_GRAPH), SetMinimalSize(576, 128), SetFill(1, 1), SetResize(1, 1),
+			NWidget(NWID_VERTICAL),//add
+				NWidget(NWID_SPACER), SetMinimalSize(0, 24), SetFill(0, 0), SetResize(0, 1),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_CPR_ENABLE_CARGOES), SetDataTip(STR_GRAPH_CARGO_ENABLE_ALL, STR_GRAPH_CARGO_TOOLTIP_ENABLE_ALL), SetFill(1, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_CPR_DISABLE_CARGOES), SetDataTip(STR_GRAPH_CARGO_DISABLE_ALL, STR_GRAPH_CARGO_TOOLTIP_DISABLE_ALL), SetFill(1, 0),
+				NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+				NWidgetFunction(MakeCargoButtons),
+				NWidget(NWID_SPACER), SetMinimalSize(0, 24), SetFill(0, 1), SetResize(0, 1),
+			EndContainer(),//add
 			NWidget(NWID_VERTICAL),
 				NWidget(NWID_SPACER), SetFill(0, 1), SetResize(0, 1),
 				NWidget(WWT_RESIZEBOX, COLOUR_GREY, WID_CV_RESIZE),
@@ -723,8 +820,60 @@ struct DeliveredCargoGraphWindow : BaseGraphWindow {
 
 	virtual OverflowSafeInt64 GetGraphData(const Company *c, int j)
 	{
+		if(_legend_excluded_cargo == 0){ 
 		return c->old_economy[j].delivered_cargo.GetSum<OverflowSafeInt64>();
 	}
+		uint total_delivered = 0;
+		const CargoSpec *cs;
+		FOR_ALL_SORTED_STANDARD_CARGOSPECS(cs) {
+			if (!HasBit(_legend_excluded_cargo, cs->Index())){
+				total_delivered += c->old_economy[j].delivered_cargo[cs->Index()];
+			}
+		}
+		return total_delivered;
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		if (widget < WID_CPR_MATRIX) {
+			BaseGraphWindow::UpdateWidgetSize(widget, size, padding, fill, resize);
+			return;
+		}
+
+		const CargoSpec *cs = _sorted_cargo_specs[widget - WID_CPR_MATRIX];
+		SetDParam(0, cs->name);
+		Dimension d = GetStringBoundingBox(STR_GRAPH_CARGO_PAYMENT_CARGO);
+		d.width += 14; // colour field
+		d.width += WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+		d.height += WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+		*size = maxdim(d, *size);
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		if (widget < WID_CPR_MATRIX) {
+			BaseGraphWindow::DrawWidget(r, widget);
+			return;
+		}
+
+		const CargoSpec *cs = _sorted_cargo_specs[widget - WID_CPR_MATRIX];
+		bool rtl = _current_text_dir == TD_RTL;
+
+		/* Since the buttons have no text, no images,
+		 * both the text and the coloured box have to be manually painted.
+		 * clk_dif will move one pixel down and one pixel to the right
+		 * when the button is clicked */
+		byte clk_dif = this->IsWidgetLowered(widget) ? 1 : 0;
+		int x = r.left + WD_FRAMERECT_LEFT;
+		int y = r.top;
+
+		int rect_x = clk_dif + (rtl ? r.right - 12 : r.left + WD_FRAMERECT_LEFT);
+
+		GfxFillRect(rect_x, y + clk_dif, rect_x + 8, y + 5 + clk_dif, PC_BLACK);
+		GfxFillRect(rect_x + 1, y + 1 + clk_dif, rect_x + 7, y + 4 + clk_dif, cs->legend_colour);
+		SetDParam(0, cs->name);
+		DrawString(rtl ? r.left : x + 14 + clk_dif, (rtl ? r.right - 14 + clk_dif : r.right), y + clk_dif, STR_GRAPH_CARGO_PAYMENT_CARGO);
+	}
 };
 
 static const NWidgetPart _nested_delivered_cargo_graph_widgets[] = {
@@ -795,6 +944,15 @@ static const NWidgetPart _nested_performance_history_widgets[] = {
 	NWidget(WWT_PANEL, COLOUR_GREY, WID_PHG_BACKGROUND),
 		NWidget(NWID_HORIZONTAL),
 			NWidget(WWT_EMPTY, COLOUR_GREY, WID_PHG_GRAPH), SetMinimalSize(576, 224), SetFill(1, 1), SetResize(1, 1),
+			NWidget(NWID_VERTICAL),//add
+				NWidget(NWID_SPACER), SetMinimalSize(0, 24), SetFill(0, 0), SetResize(0, 1),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_CPR_ENABLE_CARGOES), SetDataTip(STR_GRAPH_CARGO_ENABLE_ALL, STR_GRAPH_CARGO_TOOLTIP_ENABLE_ALL), SetFill(1, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_CPR_DISABLE_CARGOES), SetDataTip(STR_GRAPH_CARGO_DISABLE_ALL, STR_GRAPH_CARGO_TOOLTIP_DISABLE_ALL), SetFill(1, 0),
+				NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+				NWidgetFunction(MakeCargoButtons),
+				NWidget(NWID_SPACER), SetMinimalSize(0, 24), SetFill(0, 1), SetResize(0, 1),
+			EndContainer(),//add
+			NWidget(NWID_SPACER), SetMinimalSize(5, 0), SetFill(0, 1), SetResize(0, 1),
 			NWidget(NWID_VERTICAL),
 				NWidget(NWID_SPACER), SetFill(0, 1), SetResize(0, 1),
 				NWidget(WWT_RESIZEBOX, COLOUR_GREY, WID_PHG_RESIZE),
@@ -891,6 +1049,7 @@ struct PaymentRatesGraphWindow : BaseGraphWindow {
 		this->FinishInitNested(window_number);
 	}
 
+/*	
 	void UpdateExcludedData()
 	{
 		this->excluded_data = 0;
@@ -902,7 +1061,7 @@ struct PaymentRatesGraphWindow : BaseGraphWindow {
 			i++;
 		}
 	}
-
+*/
 	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
 	{
 		if (widget != WID_CPR_MATRIX) {
@@ -963,18 +1122,19 @@ struct PaymentRatesGraphWindow : BaseGraphWindow {
 		}
 	}
 
+/*
 	virtual void OnClick(Point pt, int widget, int click_count)
 	{
 		switch (widget) {
 			case WID_CPR_ENABLE_CARGOES:
-				/* Remove all cargoes from the excluded lists. */
+				// Remove all cargoes from the excluded lists.
 				_legend_excluded_cargo = 0;
 				this->excluded_data = 0;
 				this->SetDirty();
 				break;
 
 			case WID_CPR_DISABLE_CARGOES: {
-				/* Add all cargoes to the excluded lists. */
+				// Add all cargoes to the excluded lists.
 				int i = 0;
 				const CargoSpec *cs;
 				FOR_ALL_SORTED_STANDARD_CARGOSPECS(cs) {
@@ -1003,6 +1163,7 @@ struct PaymentRatesGraphWindow : BaseGraphWindow {
 			}
 		}
 	}
+*/
 
 	virtual void OnResize()
 	{
diff --git a/src/gui.h b/src/gui.h
index 39f1ea661..1b26084dc 100644
--- a/src/gui.h
+++ b/src/gui.h
@@ -44,7 +44,7 @@ void ShowGenerateLandscape();
 void ShowHeightmapLoad();
 
 /* misc_gui.cpp */
-void ShowLandInfo(TileIndex tile);
+void ShowLandInfo(TileIndex tile, TileIndex end_tile=INVALID_TILE);
 void ShowAboutWindow();
 void ShowBuildTreesToolbar();
 void ShowTownDirectory();
diff --git a/src/industry_gui.cpp b/src/industry_gui.cpp
index 78bf3f4a0..12c8f5105 100644
--- a/src/industry_gui.cpp
+++ b/src/industry_gui.cpp
@@ -41,6 +41,7 @@
 #include "widgets/industry_widget.h"
 
 #include "table/strings.h"
+#include "hotkeys.h"
 
 #include <bitset>
 
@@ -70,6 +71,13 @@ struct CargoSuffix {
 	char text[512];             ///< Cargo suffix text.
 };
 
+/** Alternatives for filtering by industry transported */
+enum { // Should this enum have a name? example: TransportedFilterSelections
+	TRANSPORTED_SHOW_BOTH,     ///< Show both transported and non-transported industries
+	TRANSPORTED_SHOW_ONLY_NOT, ///< Show only non-transported industries
+	TRANSPORTED_SHOW_ONLY,     ///< Show only transported industries
+};
+
 static void ShowIndustryCargoesWindow(IndustryType id);
 
 /**
@@ -216,6 +224,23 @@ void SortIndustryTypes()
 	QSortT(_sorted_industry_types, NUM_INDUSTRYTYPES, &IndustryTypeNameSorter);
 }
 
+/**
+ * Return a drop down list of sorted industry types.
+ */
+DropDownList *GetIndustryTypeDropDownList(bool include_show_all = false){
+	DropDownList *lst = new DropDownList;
+	//if (include_show_all) lst->push_back(new DropDownListStringItem(STR_FILTER_INDUSTRY_TYPE_ALL, -1, false));
+	if (include_show_all) *lst->Append() = new DropDownListStringItem(STR_FILTER_INDUSTRY_TYPE_ALL, -1, false);
+	for (uint8 i = 0; i < NUM_INDUSTRYTYPES; i++) {
+		IndustryType ind = _sorted_industry_types[i];
+		const IndustrySpec *indsp = GetIndustrySpec(ind);
+		if (!indsp->enabled) continue;
+		//lst->push_back(new DropDownListStringItem(indsp->name, ind, false));
+		*lst->Append() = new DropDownListStringItem(indsp->name, ind, false);
+	}
+	return lst;
+}
+
 /**
  * Command callback. In case of failure to build an industry, show an error message.
  * @param result Result of the command.
@@ -259,14 +284,6 @@ static const NWidgetPart _nested_build_industry_widgets[] = {
 	EndContainer(),
 };
 
-/** Window definition of the dynamic place industries gui */
-static WindowDesc _build_industry_desc(
-	WDP_AUTO, "build_industry", 170, 212,
-	WC_BUILD_INDUSTRY, WC_NONE,
-	WDF_CONSTRUCTION,
-	_nested_build_industry_widgets, lengthof(_nested_build_industry_widgets)
-);
-
 /** Build (fund or prospect) a new industry, */
 class BuildIndustryWindow : public Window {
 	int selected_index;                         ///< index of the element in the matrix
@@ -387,7 +404,7 @@ class BuildIndustryWindow : public Window {
 	}
 
 public:
-	BuildIndustryWindow() : Window(&_build_industry_desc)
+	BuildIndustryWindow(WindowDesc *desc) : Window(desc)
 	{
 		this->timer_enabled = _loaded_newgrf_features.has_newindustries;
 
@@ -721,13 +738,38 @@ public:
 		if (indsp == NULL) this->enabled[this->selected_index] = _settings_game.difficulty.industry_density != ID_FUND_ONLY;
 		this->SetButtons();
 	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		return Window::OnHotkey(hotkey);
+	}
+
+	static HotkeyList hotkeys;
 };
 
+static Hotkey build_industry_hotkeys[] = {
+	Hotkey((uint16)0, "display_chain", WID_DPI_DISPLAY_WIDGET),
+	Hotkey((uint16)0, "build_button", WID_DPI_FUND_WIDGET),
+	HOTKEY_LIST_END
+};
+
+HotkeyList BuildIndustryWindow::hotkeys("industry_fund_gui", build_industry_hotkeys);
+
+/** Window definition of the dynamic place industries gui */
+static WindowDesc _build_industry_desc(
+	WDP_AUTO, "build_industry", 170, 212,
+	WC_BUILD_INDUSTRY, WC_NONE,
+	WDF_CONSTRUCTION,
+	_nested_build_industry_widgets, lengthof(_nested_build_industry_widgets),
+	&BuildIndustryWindow::hotkeys
+);
+
+
 void ShowBuildIndustryWindow()
 {
 	if (_game_mode != GM_EDITOR && !Company::IsValidID(_local_company)) return;
 	if (BringWindowToFrontById(WC_BUILD_INDUSTRY, 0)) return;
-	new BuildIndustryWindow();
+	new BuildIndustryWindow(&_build_industry_desc);
 }
 
 static void UpdateIndustryProduction(Industry *i);
@@ -1168,6 +1210,10 @@ static const NWidgetPart _nested_industry_directory_widgets[] = {
 			NWidget(NWID_HORIZONTAL),
 				NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_ID_DROPDOWN_ORDER), SetDataTip(STR_BUTTON_SORT_BY, STR_TOOLTIP_SORT_ORDER),
 				NWidget(WWT_DROPDOWN, COLOUR_BROWN, WID_ID_DROPDOWN_CRITERIA), SetDataTip(STR_JUST_STRING, STR_TOOLTIP_SORT_CRITERIA),
+				NWidget(WWT_DROPDOWN, COLOUR_BROWN, WID_ID_DROPDOWN_FILTER_TRANSPORTED),
+						SetDataTip(STR_JUST_STRING, STR_TOOLTIP_FILTER_CRITERIA),
+				NWidget(WWT_DROPDOWN, COLOUR_BROWN, WID_ID_DROPDOWN_FILTER_INDUSTRY_TYPE),
+						SetDataTip(STR_INDUSTRY_CARGOES_SELECT_INDUSTRY, STR_TOOLTIP_FILTER_CRITERIA),
 				NWidget(WWT_PANEL, COLOUR_BROWN), SetResize(1, 0), EndContainer(),
 			EndContainer(),
 			NWidget(WWT_PANEL, COLOUR_BROWN, WID_ID_INDUSTRY_LIST), SetDataTip(0x0, STR_INDUSTRY_DIRECTORY_LIST_CAPTION), SetResize(1, 1), SetScrollbar(WID_ID_SCROLLBAR), EndContainer(),
@@ -1193,6 +1239,10 @@ protected:
 
 	/* Constants for sorting stations */
 	static const StringID sorter_names[];
+	static const StringID transported_filter_names[]; ///< List of filter by transported alternatives
+	byte selected_filter_transported_index;           ///< The currently selected filter by transported industry
+	int selected_filter_industry_type_index;          ///< The currently selected filter by industry type
+	Dimension ind_textsize;                           ///< Size to hold any industry type text, as well as STR_INDUSTRY_CARGOES_SELECT_INDUSTRY.
 	static GUIIndustryList::SortFunction * const sorter_funcs[];
 
 	GUIIndustryList industries;
@@ -1206,8 +1256,29 @@ protected:
 
 			const Industry *i;
 			FOR_ALL_INDUSTRIES(i) {
-				*this->industries.Append() = i;
-			}
+				if (this->selected_filter_industry_type_index == -1 || i->type == this->selected_filter_industry_type_index) {
+					bool transported = 0;
+					for (byte j = 0; j < lengthof(i->produced_cargo); j++) {
+						if (i->produced_cargo[j] == CT_INVALID) continue;
+						if (i->last_month_pct_transported[j]) {
+							transported = true;
+							break;
+						}
+					} // for cargoes
+ 
+					switch (this->selected_filter_transported_index) {
+						case TRANSPORTED_SHOW_BOTH:
+							*this->industries.Append() = i;
+							break;
+						case TRANSPORTED_SHOW_ONLY_NOT:
+							if (!transported) *this->industries.Append() = i;
+							break;
+						case TRANSPORTED_SHOW_ONLY:
+							if (transported) *this->industries.Append() = i;
+							break;
+					} // switch
+				} // If correct type
+			} // FOR_ALL_INDUSTRIES
 
 			this->industries.Compact();
 			this->industries.RebuildDone();
@@ -1344,6 +1415,8 @@ public:
 		this->CreateNestedTree();
 		this->vscroll = this->GetScrollbar(WID_ID_SCROLLBAR);
 
+		this->SetFilterTransportedIndex(TRANSPORTED_SHOW_BOTH);
+		this->SetFilterIndustryTypeIndex(-1);
 		this->industries.SetListing(this->last_sorting);
 		this->industries.SetSortFuncs(IndustryDirectoryWindow::sorter_funcs);
 		this->industries.ForceRebuild();
@@ -1357,9 +1430,24 @@ public:
 		this->last_sorting = this->industries.GetListing();
 	}
 
+	virtual void SetFilterTransportedIndex(byte index) {
+		this->selected_filter_transported_index = index;
+	}
+
+	virtual void SetFilterIndustryTypeIndex(int index) {
+		this->selected_filter_industry_type_index = index;
+	}
+
 	virtual void SetStringParameters(int widget) const
 	{
-		if (widget == WID_ID_DROPDOWN_CRITERIA) SetDParam(0, IndustryDirectoryWindow::sorter_names[this->industries.SortType()]);
+		switch (widget) {
+			case WID_ID_DROPDOWN_CRITERIA:
+				SetDParam(0, IndustryDirectoryWindow::sorter_names[this->industries.SortType()]);
+				break;
+			case WID_ID_DROPDOWN_FILTER_TRANSPORTED:
+				SetDParam(0, IndustryDirectoryWindow::transported_filter_names[this->selected_filter_transported_index]);
+				break;
+		}
 	}
 
 	virtual void DrawWidget(const Rect &r, int widget) const
@@ -1409,6 +1497,21 @@ public:
 				break;
 			}
 
+			case WID_ID_DROPDOWN_FILTER_TRANSPORTED: {
+				Dimension d = {0, 0};
+				for (uint i = 0; IndustryDirectoryWindow::transported_filter_names[i] != INVALID_STRING_ID; i++) {
+					d = maxdim(d, GetStringBoundingBox(IndustryDirectoryWindow::transported_filter_names[i]));
+				}
+				d.width += padding.width;
+				d.height += padding.height;
+				*size = maxdim(*size, d);
+				break;
+			}
+
+			case WID_ID_DROPDOWN_FILTER_INDUSTRY_TYPE:
+				size->width = max(size->width, this->ind_textsize.width + padding.width);
+				break;
+
 			case WID_ID_INDUSTRY_LIST: {
 				Dimension d = GetStringBoundingBox(STR_INDUSTRY_DIRECTORY_NONE);
 				for (uint i = 0; i < this->industries.Length(); i++) {
@@ -1437,6 +1540,20 @@ public:
 				ShowDropDownMenu(this, IndustryDirectoryWindow::sorter_names, this->industries.SortType(), WID_ID_DROPDOWN_CRITERIA, 0, 0);
 				break;
 
+			case WID_ID_DROPDOWN_FILTER_TRANSPORTED:
+				ShowDropDownMenu(this, IndustryDirectoryWindow::transported_filter_names, this->selected_filter_transported_index, WID_ID_DROPDOWN_FILTER_TRANSPORTED, 0, 0);
+				break;
+
+			case WID_ID_DROPDOWN_FILTER_INDUSTRY_TYPE: {
+				const DropDownList *lst = GetIndustryTypeDropDownList(1);
+				if (lst->Length() == 0) {
+					delete lst;
+					break;
+				}
+				ShowDropDownList(this, lst, this->selected_filter_industry_type_index, WID_ID_DROPDOWN_FILTER_INDUSTRY_TYPE, 0, true);
+				break;
+			}
+
 			case WID_ID_INDUSTRY_LIST: {
 				uint p = this->vscroll->GetScrolledRowFromWidget(pt.y, this, WID_ID_INDUSTRY_LIST, WD_FRAMERECT_TOP);
 				if (p < this->industries.Length()) {
@@ -1453,10 +1570,32 @@ public:
 
 	virtual void OnDropdownSelect(int widget, int index)
 	{
-		if (this->industries.SortType() != index) {
-			this->industries.SetSortType(index);
-			this->BuildSortIndustriesList();
-		}
+		switch (widget) {
+			case WID_ID_DROPDOWN_CRITERIA:
+				if (this->industries.SortType() != index) {
+					this->industries.SetSortType(index);
+					this->BuildSortIndustriesList();
+				}
+				break;
+
+			case WID_ID_DROPDOWN_FILTER_TRANSPORTED:
+				if (this->selected_filter_transported_index != index) {
+					this->SetFilterTransportedIndex(index);
+					this->industries.ForceRebuild();
+					this->BuildSortIndustriesList();
+					this->SetWidgetDirty(WID_ID_INDUSTRY_LIST);
+				}
+				break;
+
+			case WID_ID_DROPDOWN_FILTER_INDUSTRY_TYPE:
+				if (this->selected_filter_industry_type_index != index) {
+					this->SetFilterIndustryTypeIndex(index);
+					this->industries.ForceRebuild();
+					this->BuildSortIndustriesList();
+					this->SetWidgetDirty(WID_ID_INDUSTRY_LIST);
+				}
+				break;
+		} // switch
 	}
 
 	virtual void OnResize()
@@ -1512,6 +1651,13 @@ const StringID IndustryDirectoryWindow::sorter_names[] = {
 	INVALID_STRING_ID
 };
 
+/* Names of the filter functions */
+const StringID IndustryDirectoryWindow::transported_filter_names[] = {
+	STR_FILTER_TRANSPORTED_BOTH,
+	STR_FILTER_TRANSPORTED_ONLY_NOT,
+	STR_FILTER_TRANSPORTED_ONLY,
+	INVALID_STRING_ID,
+};
 
 /** Window definition of the industry directory gui */
 static WindowDesc _industry_directory_desc(
@@ -2720,13 +2866,7 @@ struct IndustryCargoesWindow : public Window {
 			}
 
 			case WID_IC_IND_DROPDOWN: {
-				DropDownList *lst = new DropDownList;
-				for (uint i = 0; i < NUM_INDUSTRYTYPES; i++) {
-					IndustryType ind = _sorted_industry_types[i];
-					const IndustrySpec *indsp = GetIndustrySpec(ind);
-					if (!indsp->enabled) continue;
-					*lst->Append() = new DropDownListStringItem(indsp->name, ind, false);
-				}
+				DropDownList *lst = GetIndustryTypeDropDownList();
 				if (lst->Length() == 0) {
 					delete lst;
 					break;
diff --git a/src/intro_gui.cpp b/src/intro_gui.cpp
index 3659b033c..6d0c7f635 100644
--- a/src/intro_gui.cpp
+++ b/src/intro_gui.cpp
@@ -16,6 +16,7 @@
 #include "textbuf_gui.h"
 #include "network/network.h"
 #include "genworld.h"
+#include "network/network_func.h"
 #include "network/network_gui.h"
 #include "network/network_content.h"
 #include "landscape_type.h"
@@ -33,15 +34,62 @@
 #include "table/strings.h"
 #include "table/sprites.h"
 
+#include "window_func.h" //deletewindowbyID
+#include "console_func.h" //IConsolePrintF
+#include "settings_func.h" //saveconfig
+#include "base64.h"
+
 #include "safeguards.h"
 
+using namespace std;
+std::string _server_list_text_names;
+
+void ShowSelectGameWindow();
+
 struct SelectGameWindow : public Window {
 
+  SelectGameQuery query_widget;
+
 	SelectGameWindow(WindowDesc *desc) : Window(desc)
 	{
 		this->CreateNestedTree();
 		this->FinishInitNested(0);
 		this->OnInvalidateData();
+		GetCommunityServerListText();
+	}
+
+  void OnQueryTextFinished(char *str) {
+		if (str == NULL) return;		
+
+    int comm = _settings_client.gui.community; //chosen community 
+		switch (query_widget) {
+			case SGQ_CC_USER:
+				if (Utf8StringLength(str) >= NETWORK_NAME_LENGTH) break;
+				if(comm > 0 && comm <= 2){
+					//comm--; //array first index
+					strecpy(_settings_client.network.community_user[comm-1], str, lastof(_settings_client.network.community_user[comm-1]));
+				}
+				//strecpy(_settings_client.network.client_name, str, lastof(_settings_client.network.client_name));
+				SaveToConfig();
+				this->SetDirty();
+				break;
+
+			case SGQ_CC_PASSWORD:{
+				if (Utf8StringLength(str) >= NETWORK_PASSWORD_LENGTH) break;
+				string s = str;
+				const char *np;
+				string encoded = base64_encode(reinterpret_cast<const unsigned char*>(s.c_str()), s.length());
+				np = encoded.c_str();
+
+				if(comm > 0 && comm <= 2){
+					comm--; //array first index
+					strecpy(_settings_client.network.community_password[comm], np, lastof(_settings_client.network.community_password[comm]));
+				}
+				SaveToConfig();
+				break;
+			}
+			default: NOT_REACHED();
+		}
 	}
 
 	/**
@@ -65,10 +113,29 @@ struct SelectGameWindow : public Window {
 
 		bool missing_lang = _current_language->missing >= _settings_client.gui.missing_strings_threshold && !IsReleasedVersion();
 		this->GetWidget<NWidgetStacked>(WID_SGI_TRANSLATION_SELECTION)->SetDisplayedPlane(missing_lang ? 0 : SZSP_NONE);
+		if(_settings_client.gui.community == 1){
+			this->GetWidget<NWidgetCore>(WID_SGI_CC_SELECT_NICE)->colour = COLOUR_YELLOW;
+			this->DisableWidget(WID_SGI_SERVER_VIP); //disable VIP-button for n-ice
+		}
+		else if(_settings_client.gui.community == 2) this->GetWidget<NWidgetCore>(WID_SGI_CC_SELECT_BTPRO)->colour = COLOUR_YELLOW;
+		else{ 
+			this->DisableWidget(WID_SGI_CC_PASSWORD);
+			this->DisableWidget(WID_SGI_CC_USER_ENTER);
+			this->DisableWidget(WID_SGI_WEBSITE);
+			this->DisableWidget(WID_SGI_SERVERS_FORUM);
+			this->DisableWidget(WID_SGI_IRC_CHAT);
+			this->DisableWidget(WID_SGI_IRC_SERVERS_CHAT);
+			this->DisableWidget(WID_SGI_SERVER_RULES);
+			this->DisableWidget(WID_SGI_SERVER_WIKI);
+			this->DisableWidget(WID_SGI_SERVER_VIP);
+		}
 	}
 
 	virtual void DrawWidget(const Rect &r, int widget) const
 	{
+    char* _cc_name; //server name - for the button
+    char name[16];
+    char sn[64];
 		switch (widget) {
 			case WID_SGI_BASESET:
 				SetDParam(0, _missing_extra_graphics);
@@ -79,6 +146,28 @@ struct SelectGameWindow : public Window {
 				SetDParam(0, _current_language->missing);
 				DrawStringMultiLine(r.left, r.right, r.top,  r.bottom, STR_INTRO_TRANSLATION, TC_FROMSTRING, SA_CENTER);
 				break;
+
+			case WID_SGI_SERVERS:				
+				//DrawString(r.left, r.right, r.top + 40, STR_CC_SERVER_FREELANCER, TC_FROMSTRING, SA_CENTER);
+				DrawStringMultiLine(r.left, r.right, r.top,  r.bottom, STR_CC_SERVER_FREELANCER, TC_FROMSTRING, SA_CENTER);
+				break;
+			default:
+				if(widget >= WID_SGI_CC1){
+					if(widget - WID_SGI_CC1 + 1 < 10){
+						seprintf(name, lastof(name), "NAME0%i", widget - WID_SGI_CC1 + 1);
+					}
+					else {
+						seprintf(name, lastof(name), "NAME%i", widget - WID_SGI_CC1 + 1);
+					}
+					size_t posname = _server_list_text_names.find(name);
+					std::string sname = _server_list_text_names.substr(posname + 8, _server_list_text_names.find(";", posname + 8) - posname - 8);
+					strecpy(sn, sname.c_str(), lastof(sn));
+					_cc_name = sn;
+					
+					SetDParamStr(0, _cc_name);
+					DrawString(r.left, r.right, r.top + 3, STR_NETWORK_DIRECT_JOIN_GAME, TC_FROMSTRING, SA_CENTER);
+				}
+				break;
 		}
 	}
 
@@ -111,6 +200,23 @@ struct SelectGameWindow : public Window {
 		}
 	}
 
+	virtual void SetStringParameters(int widget) const
+	{
+		switch(widget){
+			case WID_SGI_CC_USER:
+        if (_settings_client.gui.community != 0) {
+          SetDParamStr(0, _settings_client.network.community_user[_settings_client.gui.community-1]);
+        } else {
+          SetDParamStr(0, " ");
+        }
+				break;
+
+			case WID_SGI_CC_HEADER:
+				SetDParam(0, STR_NETWORK_SERVER_LIST_CC_DEFAULT + (uint16)_settings_client.gui.community);
+				break;
+		}
+	}
+
 	virtual void OnClick(Point pt, int widget, int click_count)
 	{
 #ifdef ENABLE_NETWORK
@@ -119,6 +225,7 @@ struct SelectGameWindow : public Window {
 		if (IsInsideMM(widget, WID_SGI_GENERATE_GAME, WID_SGI_EDIT_SCENARIO + 1)) _is_network_server = false;
 #endif /* ENABLE_NETWORK */
 
+    extern void OpenBrowser(const char *url);
 		switch (widget) {
 			case WID_SGI_GENERATE_GAME:
 				if (_ctrl_pressed) {
@@ -159,10 +266,137 @@ struct SelectGameWindow : public Window {
 				break;
 			case WID_SGI_AI_SETTINGS:     ShowAIConfigWindow(); break;
 			case WID_SGI_EXIT:            HandleExitGameRequest(); break;
+
+			//community stuff
+			case WID_SGI_CC_SELECT_NICE:
+				_settings_client.gui.community = _settings_client.gui.community != 1 ? 1 : 0;
+				IConsolePrintF(CC_DEFAULT, "icomm: '%i'", _settings_client.gui.community);
+				GetCommunityServerListText();
+				DeleteWindowByClass(WC_SELECT_GAME);
+				ShowSelectGameWindow();
+				break;
+			case WID_SGI_CC_SELECT_BTPRO:
+				_settings_client.gui.community = _settings_client.gui.community != 2 ? 2 : 0;
+				IConsolePrintF(CC_DEFAULT, "icomm: '%i'", _settings_client.gui.community);
+				GetCommunityServerListText();
+				DeleteWindowByClass(WC_SELECT_GAME);
+				ShowSelectGameWindow();
+				break;
+			case WID_SGI_WEBSITE:
+				if(_settings_client.gui.community == 1) OpenBrowser("http://www.n-ice.org");
+				else if(_settings_client.gui.community == 2) OpenBrowser("http://openttd.btpro.nl");
+				break;	
+			case WID_SGI_SERVERS_FORUM:
+				if(_settings_client.gui.community == 1) OpenBrowser("http://www.n-ice.org/openttd/forum/index.php");
+				else if(_settings_client.gui.community == 2) OpenBrowser("http://openttd.btpro.nl/index.php/forum/recent");
+				break;
+			case WID_SGI_IRC_CHAT:
+				if(_settings_client.gui.community == 1) OpenBrowser("http://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2FOpenTTD.Chat");
+				else if(_settings_client.gui.community == 2) OpenBrowser("http://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2Fbtpro-chat");
+				break;
+			case WID_SGI_IRC_SERVERS_CHAT:
+				if(_settings_client.gui.community == 1) OpenBrowser("http://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2FOpenTTD");
+				else if(_settings_client.gui.community == 2) OpenBrowser("http://chat.mibbit.com/?url=irc%3A%2F%2Firc.boxor.net:6668%2Fbtpro-openttd");
+				break;
+			case WID_SGI_SERVER_RULES:
+				if(_settings_client.gui.community == 1) OpenBrowser("http://n-ice.org/openttd/rules.php");
+				else if(_settings_client.gui.community == 2) OpenBrowser("http://openttd.btpro.nl/index.php/forum/11-server-rules/10-server-rules");
+				break;
+			case WID_SGI_SERVER_WIKI:
+				if(_settings_client.gui.community == 1) OpenBrowser("https://wiki.x-base.info/OpenTTD/Rules");
+				else if(_settings_client.gui.community == 2) OpenBrowser("http://openttd.btpro.nl/wiki/index.php/Main_Page");
+				break;
+			case WID_SGI_SERVER_VIP:
+				if(_settings_client.gui.community == 2) OpenBrowser("http://openttd.btpro.nl/contact-us/vip-membership");
+				else this->DisableWidget(widget);
+				break;
+			case WID_SGI_CC_USER_ENTER: // Enter User name
+				this->query_widget = SGQ_CC_USER;
+				SetDParamStr(0, _settings_client.network.community_user[_settings_client.gui.community-1]);
+				ShowQueryString(STR_CC_USER_WHITE, STR_CC_USER_ENTER, 40, this, CS_ALPHANUMERAL, QSF_NONE);
+				break;
+			case WID_SGI_CC_PASSWORD: // Enter user Password
+				this->query_widget = SGQ_CC_PASSWORD;
+				ShowQueryString(STR_EMPTY, STR_CC_PASSWORD_ENTER, 40, this, CS_ALPHANUMERAL, QSF_NONE);
+				break;
+			// directly to server #number
+			default:
+				if(widget >= WID_SGI_CC1){
+					if (GetCommunityServer(widget - WID_SGI_CC1 + 1)) {
+						if (_ctrl_pressed) {
+							NetworkClientConnectGame(NetworkAddress(_cc_address, _cc_porti), COMPANY_NEW_COMPANY);
+						} else {
+							NetworkClientConnectGame(NetworkAddress(_cc_address, _cc_porti), COMPANY_SPECTATOR);
+						}
+					}        
+				} else {
+					ShowErrorMessage(STR_CC_SERVER_DISABLED, INVALID_STRING_ID, WL_ERROR);
+				}
+				break;
 		}
 	}
 };
 
+NWidgetBase *MakeServerButtons(int *biggest_index)
+{
+	NWidgetVertical *ver = new NWidgetVertical;
+    _server_list_text_names = _server_list_text;
+	if(_settings_client.gui.community == 0 || _server_list_text.empty()){
+		NWidgetBackground *leaf = new NWidgetBackground(WWT_PANEL, COLOUR_BROWN, WID_SGI_SERVERS, NULL);		
+		ver->Add(leaf);
+		return ver;
+	}
+	
+	/* check for disabled server from serverlist file */ 
+	int active = 0, aactive[50], s_max = 0;
+	if (_settings_client.gui.community == 1) s_max = 50; //for n-ice
+	if (_settings_client.gui.community == 2) s_max = 30; //for btpro
+	for (int i = 0; i < s_max; i++) {
+        aactive[i] = GetCommunityServer(i + 1, true) ? (i + 1) : 0; //server disabled?
+        active++;
+    }
+    	
+	NWidgetHorizontal *hor = new NWidgetHorizontal;
+	int i1 = 0, i2 = 0;
+	for (int i = 0; i < s_max; i++) {
+		if ((aactive[i] == 0) && (_settings_client.gui.community == 1)) continue; //hide button if disabled - for n-ice only
+		i2++;
+		if ((i1 == 5) || (i1 == 10) || (i1 == 15) || (i1 == 20) || (i1 == 25) || (i1 == 30) || (i1 == 35) || (i1 == 40) || (i1 == 45) || (i1 == 50)) {
+			i2=0;
+			NWidgetSpacer *spce = new NWidgetSpacer(8, 0);
+			spce->SetFill(1, 0);
+			hor->Add(spce);
+			ver->Add(hor);
+			NWidgetSpacer *spc = new NWidgetSpacer(0, 4);
+			spc->SetFill(1, 0);
+			ver->Add(spc);
+			hor = new NWidgetHorizontal();
+		}
+		NWidgetSpacer *spce = new NWidgetSpacer(3, 0);
+		spce->SetFill(1, 0);
+		hor->Add(spce);
+		NWidgetBackground *leaf = new NWidgetBackground(WWT_PANEL, COLOUR_ORANGE, WID_SGI_CC1 + i, NULL);
+		if(aactive[i] == 0) leaf->SetDisabled(true);
+		leaf->SetDataTip(STR_NETWORK_DIRECT_JOIN_GAME, STR_NETWORK_DIRECT_JOIN_GAME_TOOLTIP);
+		leaf->SetMinimalSize(90, 15);
+		hor->Add(leaf);
+		i1++;
+	}
+	
+	/* arrange buttons @ last line */
+	if (i2==0) i2=380;
+	if (i2==1) i2=287;
+	if (i2==2) i2=194;
+	if (i2==3) i2=101;
+	if (i2==4) i2=8;
+	NWidgetSpacer *spce = new NWidgetSpacer(i2, 0);
+	spce->SetFill(1, 0);
+	hor->Add(spce);			
+	ver->Add(hor);
+	*biggest_index = WID_SGI_CC1 - 1 + active;
+	return ver;
+}
+
 static const NWidgetPart _nested_select_game_widgets[] = {
 	NWidget(WWT_CAPTION, COLOUR_BROWN), SetDataTip(STR_INTRO_CAPTION, STR_NULL),
 	NWidget(WWT_PANEL, COLOUR_BROWN),
@@ -268,6 +502,67 @@ static const NWidgetPart _nested_select_game_widgets[] = {
 	NWidget(NWID_SPACER), SetMinimalSize(0, 8),
 
 	EndContainer(),
+
+	// community servers
+	NWidget(WWT_CAPTION, COLOUR_BROWN, WID_SGI_CC_HEADER), SetDataTip(STR_NETWORK_SERVER_LIST_CC_HEADER, STR_CC_SERVERS_TOOLTIP),
+	NWidget(WWT_PANEL, COLOUR_BROWN),
+	NWidget(NWID_SPACER), SetMinimalSize(0, 3),
+	NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+		NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(20, 12), SetDataTip(STR_CC_USER_TEXT, STR_NULL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_SGI_CC_USER_ENTER), SetMinimalSize(15, 12), SetDataTip(STR_CC_USER_CHANGE, STR_CC_USER_CHANGE_TOOLTIP),
+		NWidget(NWID_SPACER), SetMinimalSize(3, 0),
+		NWidget(WWT_TEXT, COLOUR_ORANGE, WID_SGI_CC_USER), SetMinimalSize(160, 12), SetDataTip(STR_CC_USER_WHITE, STR_NULL),
+		NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(20, 12), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+		NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(20, 12), SetDataTip(STR_CC_PASSWORD, STR_NULL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_SGI_CC_PASSWORD), SetMinimalSize(15, 12), SetDataTip(STR_CC_PASSWORD_CHANGE, STR_CC_PASSWORD_CHANGE_TOOLTIP),
+		NWidget(NWID_SPACER), SetMinimalSize(175, 0),
+		NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(20, 12), SetDataTip(STR_CC_BUILD, STR_NULL),
+		NWidget(NWID_SPACER), SetMinimalSize(3, 0),
+	EndContainer(),
+	NWidget(NWID_SPACER), SetMinimalSize(0, 6),
+	NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_WEBSITE), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_WEBSITE, STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_WEBSITE_TOOLTIP),
+		NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SGI_CC_SELECT_NICE), SetMinimalSize(235, 15), SetDataTip(STR_NETWORK_CC_SELECT_NICE, STR_NETWORK_CC_SELECT_NICE_TOOLTIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SGI_CC_SELECT_BTPRO), SetMinimalSize(235, 15), SetDataTip(STR_NETWORK_CC_SELECT_BTPRO, STR_NETWORK_CC_SELECT_BTPRO_TOOLTIP),
+			NWidget(NWID_SPACER), SetMinimalSize(5, 0),
+	EndContainer(),
+	NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+	NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+		NWidget(NWID_VERTICAL, NC_EQUALSIZE), SetFill(1, 0),
+			NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_SERVERS_FORUM), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS, STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS_TOOLTIP),
+				NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+			NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_IRC_CHAT), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_CHAT, STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_CHAT_TOOLTIP),
+				NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+			NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_IRC_SERVERS_CHAT), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_SERVERS_CHAT, STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_SERVERS_CHAT_TOOLTIP),
+				NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+			NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_SERVER_RULES), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_RULES, STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_RULES_TOOLTIP),
+				NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+			NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_SERVER_WIKI), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_WIKI, STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_WIKI_TOOLTIP),
+				NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 4),
+			NWidget(NWID_HORIZONTAL, NC_EQUALSIZE), SetFill(1, 0), SetPIP(5, 3, 0),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_ORANGE, WID_SGI_SERVER_VIP), SetMinimalSize(55, 15), SetDataTip(STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_VIP, STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_VIP_TOOLTIP),
+				NWidget(WWT_TEXT, COLOUR_ORANGE), SetMinimalSize(10, 0), SetDataTip(STR_CC_SEPARATOR1, STR_NULL),
+			EndContainer(),
+		EndContainer(),
+		NWidgetFunction(MakeServerButtons),
+	EndContainer(),
+	NWidget(NWID_SPACER), SetMinimalSize(0, 6),
 };
 
 static WindowDesc _select_game_desc(
diff --git a/src/lang/english.txt b/src/lang/english.txt
index 638fb2cdf..8ec16d41e 100644
--- a/src/lang/english.txt
+++ b/src/lang/english.txt
@@ -275,6 +275,7 @@ STR_MEASURE_LENGTH                                              :{BLACK}Length:
 STR_MEASURE_AREA                                                :{BLACK}Area: {NUM} x {NUM}
 STR_MEASURE_LENGTH_HEIGHTDIFF                                   :{BLACK}Length: {NUM}{}Height difference: {HEIGHT}
 STR_MEASURE_AREA_HEIGHTDIFF                                     :{BLACK}Area: {NUM} x {NUM}{}Height difference: {HEIGHT}
+STR_MEASURE_DIST_HEIGHTDIFF                                     :{BLACK}Manhattan Distance: {NUM}{}Bird Fly Distance: {NUM}{}Distance from the nearest edge: {NUM}{}Height from sea level: {HEIGHT}{}Height difference: {HEIGHT}
 
 
 # These are used in buttons
@@ -324,6 +325,7 @@ STR_TOOLBAR_TOOLTIP_DISPLAY_TOWN_DIRECTORY                      :{BLACK}Display
 STR_TOOLBAR_TOOLTIP_DISPLAY_SUBSIDIES                           :{BLACK}Display subsidies
 STR_TOOLBAR_TOOLTIP_DISPLAY_LIST_OF_COMPANY_STATIONS            :{BLACK}Display list of company's stations
 STR_TOOLBAR_TOOLTIP_DISPLAY_COMPANY_FINANCES                    :{BLACK}Display company finances information
+STR_TOOLBAR_TOOLTIP_DISPLAY_COMPANY_CARGOS                      :{BLACK}Display company cargos information
 STR_TOOLBAR_TOOLTIP_DISPLAY_COMPANY_GENERAL                     :{BLACK}Display general company information
 STR_TOOLBAR_TOOLTIP_DISPLAY_STORY_BOOK                          :{BLACK}Display story book
 STR_TOOLBAR_TOOLTIP_DISPLAY_GOALS_LIST                          :{BLACK}Display goal list
@@ -378,6 +380,7 @@ STR_SETTINGS_MENU_CONFIG_SETTINGS_TREE                          :Settings
 STR_SETTINGS_MENU_SCRIPT_SETTINGS                               :AI/Game script settings
 STR_SETTINGS_MENU_NEWGRF_SETTINGS                               :NewGRF settings
 STR_SETTINGS_MENU_TRANSPARENCY_OPTIONS                          :Transparency options
+STR_SETTINGS_MENU_ZONING                                        :Zoning
 STR_SETTINGS_MENU_TOWN_NAMES_DISPLAYED                          :Town names displayed
 STR_SETTINGS_MENU_STATION_NAMES_DISPLAYED                       :Station names displayed
 STR_SETTINGS_MENU_WAYPOINTS_DISPLAYED                           :Waypoint names displayed
@@ -402,6 +405,7 @@ STR_MAP_MENU_MAP_OF_WORLD                                       :Map of world
 STR_MAP_MENU_EXTRA_VIEW_PORT                                    :Extra viewport
 STR_MAP_MENU_LINGRAPH_LEGEND                                    :Cargo Flow Legend
 STR_MAP_MENU_SIGN_LIST                                          :Sign list
+STR_MAP_MENU_WATCH_COMPANY                                      :Watch Company
 
 ############ range for town menu starts
 STR_TOWN_MENU_TOWN_DIRECTORY                                    :Town directory
@@ -1725,6 +1729,26 @@ STR_CONFIG_SETTING_REVERSE_AT_SIGNALS_HELPTEXT                  :Allow trains to
 
 STR_CONFIG_SETTING_QUERY_CAPTION                                :{WHITE}Change setting value
 
+STR_CONFIG_SETTING_VEHICLES_CTRL                                :{ORANGE}Controls & Orders
+STR_CONFIG_SETTING_ORDER_SHORTCUTS                              :{ORANGE}Order's Shortcuts
+STR_CONFIG_SETTING_CTRL_ENABLE_CTRLCLICK_STARTSTOP              :Allow ctrl+left-click vehicles to start or stop them: {STRING2}
+STR_CONFIG_SETTING_AUTOSET_NOLOAD_ON_TRANSFER                   :"Transfer" orders are "No Loading" by default: {STRING2}
+STR_CONFIG_SETTING_AUTOSET_NOLOAD_ON_UNLOAD                     :"Unload all" orders are "No Loading" by default: {STRING2}
+
+STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_CTRLLCLICK                 :ctrl+left-click: {STRING2}
+STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_CTRLSHIFTLCLICK            :ctrl+shift+left-click: {STRING2}
+STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_SHIFTLCLICK                :shift+left-click: {STRING2}
+STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_ALTLCLICK                  :alt+left-click: {STRING2}
+STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_ALTSHIFTCLICK              :alt+shift+left-click: {STRING2}
+STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_CTRLALTLCLICK              :ctrl+alt+left-click: {STRING2}
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE                      :do nothing
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_FULL_LOAD_ANY             :Full load any cargo
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_TRANSFER_CARGO            :Transfer cargo
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_UNLOAD_ALL                :Force unload of all cargo
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_FEEDERLOAD                :Feeder Load (replace first order)
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_FEEDERDROP                :Feeder Unload (replace last order)
+STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NO_LOAD                   :Do not load any cargo
+
 # Config errors
 STR_CONFIG_ERROR                                                :{WHITE}Error with the configuration file...
 STR_CONFIG_ERROR_ARRAY                                          :{WHITE}... error in array '{RAW_STRING}'
@@ -2103,6 +2127,10 @@ STR_NETWORK_CLIENTLIST_GIVE_MONEY                               :Give money
 STR_NETWORK_CLIENTLIST_SPEAK_TO_ALL                             :Speak to all
 STR_NETWORK_CLIENTLIST_SPEAK_TO_COMPANY                         :Speak to company
 STR_NETWORK_CLIENTLIST_SPEAK_TO_CLIENT                          :Private message
+STR_NETWORK_CLIENTLIST_GET_TOKEN                                :{LTBLUE}Token Login
+STR_NETWORK_CLIENTLIST_INVITE                                   :{GREEN}Invite
+STR_NETWORK_CLIENTLIST_INVITE_CAPTION                           :{BLACK}Invite Player
+STR_NETWORK_CLIENTLIST_INVITE_QUESTION                          :{YELLOW}Are you sure want to invite {WHITE}{RAW_STRING} {YELLOW}to your company?
 
 STR_NETWORK_SERVER                                              :Server
 STR_NETWORK_CLIENT                                              :Client
@@ -2298,6 +2326,7 @@ STR_TRANSPARENT_BRIDGES_TOOLTIP                                 :{BLACK}Toggle t
 STR_TRANSPARENT_STRUCTURES_TOOLTIP                              :{BLACK}Toggle transparency for structures like lighthouses and antennas. Ctrl+Click to lock
 STR_TRANSPARENT_CATENARY_TOOLTIP                                :{BLACK}Toggle transparency for catenary. Ctrl+Click to lock
 STR_TRANSPARENT_LOADING_TOOLTIP                                 :{BLACK}Toggle transparency for loading indicators. Ctrl+Click to lock
+STR_TRANSPARENT_TUNNELS_TOOLTIP                                 :{BLACK}Toggle transparency for vehicles in tunnels. Ctrl+Click to lock.
 STR_TRANSPARENT_INVISIBLE_TOOLTIP                               :{BLACK}Set objects invisible instead of transparent
 
 # Linkgraph legend window
@@ -2336,6 +2365,7 @@ STR_RAIL_TOOLBAR_MAGLEV_CONSTRUCTION_CAPTION                    :Maglev Construc
 
 STR_RAIL_TOOLBAR_TOOLTIP_BUILD_RAILROAD_TRACK                   :{BLACK}Build railway track. Ctrl toggles build/remove for railway construction. Shift toggles building/showing cost estimate
 STR_RAIL_TOOLBAR_TOOLTIP_BUILD_AUTORAIL                         :{BLACK}Build railway track using the Autorail mode. Ctrl toggles build/remove for railway construction. Shift toggles building/showing cost estimate
+STR_RAIL_TOOLBAR_TOOLTIP_BUILD_POLYRAIL                         :{BLACK}Build railway track using the Polyline mode. Ctrl toggles build/remove for railway construction. Shift toggles building/showing cost estimate
 STR_RAIL_TOOLBAR_TOOLTIP_BUILD_TRAIN_DEPOT_FOR_BUILDING         :{BLACK}Build train depot (for buying and servicing trains). Shift toggles building/showing cost estimate
 STR_RAIL_TOOLBAR_TOOLTIP_CONVERT_RAIL_TO_WAYPOINT               :{BLACK}Convert rail to waypoint. Ctrl enables joining waypoints. Shift toggles building/showing cost estimate
 STR_RAIL_TOOLBAR_TOOLTIP_BUILD_RAILROAD_STATION                 :{BLACK}Build railway station. Ctrl enables joining stations. Shift toggles building/showing cost estimate
@@ -2353,6 +2383,7 @@ STR_RAIL_NAME_MAGLEV                                            :Maglev
 # Rail depot construction window
 STR_BUILD_DEPOT_TRAIN_ORIENTATION_CAPTION                       :{WHITE}Train Depot Orientation
 STR_BUILD_DEPOT_TRAIN_ORIENTATION_TOOLTIP                       :{BLACK}Select railway depot orientation
+STR_BUILD_DEPOT_TRAIN_ORIENTATION_AUTO_TOOLTIP                  :{BLACK}Automatically select railway depot orientation based on environment
 
 # Rail waypoint construction window
 STR_WAYPOINT_CAPTION                                            :{WHITE}Waypoint
@@ -2361,6 +2392,8 @@ STR_WAYPOINT_GRAPHICS_TOOLTIP                                   :{BLACK}Select w
 # Rail station construction window
 STR_STATION_BUILD_RAIL_CAPTION                                  :{WHITE}Rail Station Selection
 STR_STATION_BUILD_ORIENTATION                                   :{BLACK}Orientation
+STR_STATION_BUILD_ORIENTATION_AUTO                              :{BLACK}Auto
+STR_STATION_BUILD_ORIENTATION_AUTO_TOOLTIP                      :{BLACK}Automatically select station orientation based on environment
 STR_STATION_BUILD_RAILROAD_ORIENTATION_TOOLTIP                  :{BLACK}Select railway station orientation
 STR_STATION_BUILD_NUMBER_OF_TRACKS                              :{BLACK}Number of tracks
 STR_STATION_BUILD_NUMBER_OF_TRACKS_TOOLTIP                      :{BLACK}Select number of platforms for railway station
@@ -2436,6 +2469,7 @@ STR_BUILD_DEPOT_ROAD_ORIENTATION_CAPTION                        :{WHITE}Road Dep
 STR_BUILD_DEPOT_ROAD_ORIENTATION_SELECT_TOOLTIP                 :{BLACK}Select road vehicle depot orientation
 STR_BUILD_DEPOT_TRAM_ORIENTATION_CAPTION                        :{WHITE}Tram Depot Orientation
 STR_BUILD_DEPOT_TRAM_ORIENTATION_SELECT_TOOLTIP                 :{BLACK}Select tram vehicle depot orientation
+STR_BUILD_DEPOT_ROAD_ORIENTATION_AUTO_TOOLTIP                   :{BLACK}Automatically select road depot orientation based on environment
 
 # Road vehicle station construction window
 STR_STATION_BUILD_BUS_ORIENTATION                               :{WHITE}Bus Station Orientation
@@ -2499,6 +2533,7 @@ STR_LANDSCAPING_TOOLTIP_LOWER_A_CORNER_OF_LAND                  :{BLACK}Lower a
 STR_LANDSCAPING_TOOLTIP_RAISE_A_CORNER_OF_LAND                  :{BLACK}Raise a corner of land. Dragging raises the first selected corner and levels the selected area to the new corner height. Ctrl selects the area diagonally. Shift toggles building/showing cost estimate
 STR_LANDSCAPING_LEVEL_LAND_TOOLTIP                              :{BLACK}Level an area of land to the height of the first selected corner. Ctrl selects the area diagonally. Shift toggles building/showing cost estimate
 STR_LANDSCAPING_TOOLTIP_PURCHASE_LAND                           :{BLACK}Purchase land for future use. Shift toggles building/showing cost estimate
+STR_LANDSCAPING_TOOLTIP_RULER_TOOL                              :{BLACK}Use a virtual ruler to measure distance and height
 
 # Object construction window
 STR_OBJECT_BUILD_CAPTION                                        :{WHITE}Object Selection
@@ -4110,6 +4145,32 @@ STR_AI_LIST_AUTHOR                                              :{LTBLUE}Author:
 STR_AI_LIST_VERSION                                             :{LTBLUE}Version: {ORANGE}{NUM}
 STR_AI_LIST_URL                                                 :{LTBLUE}URL: {ORANGE}{RAW_STRING}
 
+######## Trip History
+STR_TRIP_HISTORY                                                :{BLACK}History
+STR_TRIP_HISTORY_TOOLTIP                                        :{BLACK}Shows the history of the last 10 trips
+STR_TRIP_HISTORY_RECEIVED_LABEL                                 :{BLACK}Received
+STR_TRIP_HISTORY_RECEIVED_LABEL_TIP                             :{BLACK}The date when the cargo was received
+STR_TRIP_HISTORY_PROFIT_LABEL                                   :{BLACK}Profit
+STR_TRIP_HISTORY_PROFIT_LABEL_TIP                               :{BLACK}The profit received from each trip
+STR_TRIP_HISTORY_PERCHANGE_LABEL                                :{BLACK}% Change
+STR_TRIP_HISTORY_PERCHANGE_LABEL_TIP                            :{BLACK}Percentage change between the current and last trips profit
+STR_TRIP_HISTORY_TBT_LABEL                                      :{BLACK}TBT
+STR_TRIP_HISTORY_TBT_LABEL_TIP                                  :{BLACK}Time taken between the current and last trip
+STR_TRIP_HISTORY_DAYCHANGE_LABEL                                :{BLACK}Change
+STR_TRIP_HISTORY_DAYCHANGE_LABEL_TIP                            :{BLACK}Change (in days) between the current and last trips length
+STR_TRIP_HISTORY_TOTALINCOME                                    :{BLACK}Total income for the last {NUM} trip{P "" s}:{LTBLUE} {CURRENCY_SHORT} {BLACK}({LTBLUE}{CURRENCY_SHORT} {BLACK} per day)
+STR_TRIP_HISTORY_DAYAVERAGE                                     :{BLACK}Average trip length:{LTBLUE} {NUM} day{P "" s}
+STR_TRIP_HISTORY_DAYAVERAGE_IMPROVEMENT                         :{BLACK}Improvement over last {NUM} trip{P "" s}:{LTBLUE} {NUM}%
+STR_TRIP_HISTORY_CAPTION                                        :{WHITE}{VEHICLE} Trip History
+STR_TRIP_HISTORY_DATE                                           :{BLACK}{DATE_LONG}
+STR_TRIP_HISTORY_PROFIT                                         :{BLACK}{CURRENCY_SHORT}
+STR_TRIP_HISTORY_VIRTUAL_PROFIT                                 :{YELLOW}{CURRENCY_SHORT}
+STR_TRIP_HISTORY_PROFITCHANGEPOS                                :{GREEN}+{NUM}%
+STR_TRIP_HISTORY_PROFITCHANGENEG                                :{RED}{NUM}%
+STR_TRIP_HISTORY_TBT                                            :{BLACK}{NUM} day{P "" s}
+STR_TRIP_HISTORY_TBTCHANGEPOS                                   :{RED}+{NUM}
+STR_TRIP_HISTORY_TBTCHANGENEG                                   :{GREEN}{NUM}
+
 STR_AI_LIST_ACCEPT                                              :{BLACK}Accept
 STR_AI_LIST_ACCEPT_TOOLTIP                                      :{BLACK}Select highlighted script
 STR_AI_LIST_CANCEL                                              :{BLACK}Cancel
@@ -4978,10 +5039,18 @@ STR_SAVEGAME_NAME_DEFAULT                                       :{COMPANY}, {STR
 STR_SAVEGAME_NAME_SPECTATOR                                     :Spectator, {1:STRING1}
 
 # Viewport strings
+STR_VIEWPORT_TOWN_POP_VERY_POOR_RATING                          :{WHITE}{TOWN} {RED}({COMMA})
+STR_VIEWPORT_TOWN_POP_MEDIOCRE_RATING                           :{WHITE}{TOWN} {ORANGE}({COMMA})
+STR_VIEWPORT_TOWN_POP_GOOD_RATING                               :{WHITE}{TOWN} {YELLOW}({COMMA})
 STR_VIEWPORT_TOWN_POP                                           :{WHITE}{TOWN} ({COMMA})
+STR_VIEWPORT_TOWN_POP_EXCELLENT_RATING                          :{WHITE}{TOWN} {GREEN}({COMMA})
 STR_VIEWPORT_TOWN                                               :{WHITE}{TOWN}
 STR_VIEWPORT_TOWN_TINY_BLACK                                    :{TINY_FONT}{BLACK}{TOWN}
+STR_VIEWPORT_TOWN_TINY_VERY_POOR_RATING                         :{TINY_FONT}{RED}{TOWN}
+STR_VIEWPORT_TOWN_TINY_MEDIOCRE_RATING                          :{TINY_FONT}{ORANGE}{TOWN}
+STR_VIEWPORT_TOWN_TINY_GOOD_RATING                              :{TINY_FONT}{YELLOW}{TOWN}
 STR_VIEWPORT_TOWN_TINY_WHITE                                    :{TINY_FONT}{WHITE}{TOWN}
+STR_VIEWPORT_TOWN_TINY_EXCELLENT_RATING                         :{TINY_FONT}{GREEN}{TOWN}
 
 STR_VIEWPORT_SIGN_SMALL_BLACK                                   :{TINY_FONT}{BLACK}{SIGN}
 STR_VIEWPORT_SIGN_SMALL_WHITE                                   :{TINY_FONT}{WHITE}{SIGN}
@@ -5067,3 +5136,254 @@ STR_PLANE                                                       :{BLACK}{PLANE}
 STR_SHIP                                                        :{BLACK}{SHIP}
 
 STR_TOOLBAR_RAILTYPE_VELOCITY                                   :{STRING} ({VELOCITY})
+STR_TOWN_VIEW_GROWTH                                            :{BLACK}GR: {ORANGE}{COMMA}{BLACK}  next: {ORANGE}{COMMA} {BLACK} RH: {ORANGE}{COMMA} {BLACK}flag {ORANGE}{COMMA}  {BLACK}Fund: {ORANGE}{COMMA}{SILVER}m
+STR_TOWN_VIEW_GROWTH_TILES                                      :{BLACK}HS: {ORANGE}{COMMA}(+{COMMA})  {BLACK}CS: {ORANGE}{COMMA}(+{COMMA})  {BLACK}HR: {ORANGE}{COMMA}(+{COMMA})
+STR_TOWN_VIEW_HOUSE_STATE                                       :{BLACK}Houses: Building: {ORANGE}{COMMA}{BLACK} :: {BLACK}RTM: {ORANGE}{COMMA}  {BLACK}DTM: {ORANGE}{COMMA}
+STR_LOCAL_AUTHORITY_COMPANY_RATING_NUM                          :{YELLOW}{COMPANY} {COMPANY_NUM}: {ORANGE}{STRING} {BLACK}({COMMA})
+
+######## community ########
+STR_NETWORK_CC_SELECT_NICE                                      :{BLACK}N-ICE
+STR_NETWORK_CC_SELECT_NICE_TOOLTIP                              :{BLACK}Select N-ICE servers
+STR_NETWORK_CC_SELECT_BTPRO                                     :{BLACK}BTPRO
+STR_NETWORK_CC_SELECT_BTPRO_TOOLTIP                             :{BLACK}Select BTPro servers
+STR_NETWORK_CC_SELECT_REDDIT                                    :{BLACK}REDDIT
+STR_NETWORK_CC_SELECT_REDDIT_TOOLTIP                            :{BLACK}Select Reddit servers
+STR_NETWORK_CC_SELECT_CITYMANIA                                 :{BLACK}CITYMANIA
+STR_NETWORK_CC_SELECT_CITYMANIA_TOOLTIP                         :{BLACK}Select CityMania servers
+
+STR_CC_SPACES                                                   :{BLACK}  
+STR_CC_SEPARATOR1                                               :{CREAM} || 
+STR_CC_SEPARATOR                                                :{SILVER}{STRING}
+STR_CC_SEPARATOR_DEFAULT                                        :
+STR_CC_SEPARATOR_NICE                                           :## Visit n-ice.org ##
+STR_CC_SEPARATOR_BTPRO                                          :## Visit openttd.btpro.nl ##
+
+STR_CC_USER_TEXT                                                :{BLACK}User: 
+STR_CC_USER_WHITE                                               :{WHITE}{RAW_STRING}
+STR_CC_USER_CHANGE                                              :{BLACK}...
+STR_CC_USER_ENTER                                               :{BLACK}Enter your account User name
+STR_CC_USER_CHANGE_TOOLTIP                                      :{BLACK}Enter acccount User name
+STR_CC_PASSWORD                                                 :{BLACK}PW: 
+STR_CC_PASSWORD_ENTER                                           :{BLACK}Enter your account Password
+STR_CC_PASSWORD_CHANGE                                          :{BLACK}...
+STR_CC_PASSWORD_CHANGE_TOOLTIP                                  :{BLACK}Enter account Password
+
+
+STR_CC_GLOBAL_COMMANDS_TITLE                                    :{WHITE}Token Login tool
+STR_CC_TOKEN_WELCOME                                            :{BLACK}Welcome back {WHITE}{RAW_STRING}{BLACK} :)
+STR_CC_TOKEN_CLICKME                                            :{BLACK}Click the big button to Login automatically
+STR_CC_TOKEN_ENJOY                                              :{BLACK}  Respect the rules and enjoy the game. :)
+STR_CC_TOKEN_LOGIN                                              :{LTBLUE}Get Token --> Login
+STR_CC_TOKEN_LOGIN_TOOLTIP                                      :{BLACK}Get Token from website and executes !login XXXX
+STR_CC_TOKEN_LOGIN_ERROR                                        :{WHITE}Wrong Username or Password!
+
+STR_NETWORK_SERVER_LIST_CC_HEADER                               :{BLACK}{STRING}
+STR_NETWORK_SERVER_LIST_CC_DEFAULT                              :Select community
+STR_NETWORK_SERVER_LIST_CC_NICE                                 :n-ice | #n-ice.org#
+STR_NETWORK_SERVER_LIST_CC_BTPRO                                :BTPro | #openttd.btpro.nl#
+STR_CC_SERVERS_TOOLTIP                                          :Active Community
+
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_WEBSITE                    :{BLACK}Website
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_WEBSITE_TOOLTIP            :{BLACK}Open website in browser
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS_S                  :{WHITE}Server:
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS                    :{BLACK}Forum
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS_TOOLTIP            :{BLACK}Open Forum in browser of active community
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS_DONATE             :{BLACK}Donate
+STR_NETWORK_SERVER_LIST_JOIN_GAME_CC_SERVERS_DONATE_TOOLTIP     :{BLACK}Help us keeping good quality servers and community
+STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_CHAT                      :{BLACK}IRC Chat
+STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_CHAT_TOOLTIP              :{BLACK}Open mibbit IRC webclient to connect to IRC channel
+STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_SERVERS_CHAT              :{BLACK}Servers
+STR_NETWORK_SERVER_LIST_JOIN_GAME_IRC_SERVERS_CHAT_TOOLTIP      :{BLACK}Open mibbit IRC webclient to connect to Servers IRC channel
+STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_RULES                  :{BLACK}Rules
+STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_RULES_TOOLTIP          :{BLACK}Open Rules page in browser (of selected community)
+STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_WIKI                   :{BLACK}Wiki
+STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_WIKI_TOOLTIP           :{BLACK}Open Wiki page in browser (of selected community)
+STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_VIP                    :{BLACK}VIP's
+STR_NETWORK_SERVER_LIST_JOIN_GAME_SERVER_VIP_TOOLTIP            :{BLACK}Open VIP page in browser (of selected community)
+
+STR_CC_SERVER_FREELANCER                                        :{WHITE}No community selected
+STR_NETWORK_DIRECT_JOIN_GAME                                    :{BLACK}{RAW_STRING}
+STR_NETWORK_DIRECT_JOIN_GAME_TOOLTIP                            :{BLACK}Join server directly
+STR_CC_BUILD                                                    :{BLACK}(Build 19202)
+STR_CC_ADMIN_LOGIN_WRONG_SERVER                                 :{BLACK}Not a correct community server
+STR_CC_IRC_LINK_CHAT                                            :{BLACK}IRC Chat
+STR_CC_IRC_LINK_CHAT_TOOLTIP                                    :{BLACK}Open mibbit in browser to connect to #btpro-chat IRC channel
+STR_CC_IRC_LINK_SERVERS                                         :{BLACK}IRC Servers
+STR_CC_IRC_LINK_SERVERS_SPACER                                  :{BLACK}  
+STR_CC_IRC_LINK_SERVERS_TOOLTIP                                 :{BLACK}Open mibbit in browser to connect to #btpro-openttd IRC channel
+STR_CC_WIKI_RULES_PAGE                                          :{YELLOW}Detailed Rules
+STR_CC_WIKI_RULES_PAGE_STATUS                                   :{BLACK}Rules Wiki
+STR_CC_WIKI_RULES_PAGE_STATUS_TOOLTIP                           :{BLACK}Open Rules Wiki page in browser
+STR_CC_WIKI_RULES_PAGE_TOOLTIP                                  :{BLACK}Open browser in Rules Wiki page
+STR_CC_VIP                                                      :{GREEN}VIP's
+
+STR_CC_SERVER_LIST_UNREACHABLE                                  :{WHITE}Couldn't get server details
+STR_CC_SERVER_DISABLED                                          :{WHITE}Server is Disabled / Offline
+STR_CC_SERVER_LIST_ERROR_FILE                                   :{WHITE}Error on getting servers file
+
+STR_TOWN_VIEW_REALPOP_RATE                                      :{BLACK}Real Population: {YELLOW}{COMMA}  {BLACK}Rating: {YELLOW}{COMMA}
+STR_CB_DISTANCE_CHECK                                           :CB town acceptance: {STRING2}
+STR_ORDER_DIST                                                  :{NUM}, {NUM}
+
+#towns
+STR_TOWN_DIRECTORY_TOWN_COLOUR                                  :{ORANGE}{TOWN}{BLACK} ({COMMA}) - {YELLOW}{COMMA} {P "house" "houses"}
+STR_TOWN_DIRECTORY_CITY_COLOUR                                  :{YELLOW}{TOWN}{BLACK} ({COMMA}) - {YELLOW}{COMMA} {P "house" "houses"}
+STR_TOWN_DIRECTORY_CAPTION_EXTRA                                :{WHITE}Towns ({YELLOW}{COMMA}{WHITE} / {ORANGE}{COMMA}{WHITE})
+STR_SMALLMAP_TOWN_LARGE                                         :{TINY_FONT}{YELLOW}{TOWN}
+STR_TOWN_VIEW_TOWN_CAPTION_EXTRA                                :{WHITE}{TOWN} {COMMA} [{COMMA}]
+STR_TOWN_VIEW_CITY_CAPTION_EXTRA                                :{WHITE}{TOWN} (City) {COMMA} [{COMMA}]
+STR_SORT_BY_HOUSES                                              :Houses
+
+#cargo table
+STR_TOOLBAR_CARGOS_HEADER_CARGO                                 :{BLACK}Total/Month
+STR_TOOLBAR_CARGOS_HEADER_AMOUNT                                :{BLACK}Amount
+STR_TOOLBAR_CARGOS_HEADER_INCOME                                :{BLACK}Income
+STR_TOOLBAR_CARGOS_HEADER_TOTAL                                 :{BLACK}Total
+STR_TOOLBAR_CARGOS_HEADER_TOTAL_MONTH                           :{BLACK}Total this Month
+
+STR_TOOLBAR_CARGOS_UNITS                                        :{BLACK}{COMMA}
+STR_TOOLBAR_CARGOS_UNITS_TOTAL                                  :{BLACK}{COMMA}
+STR_TOOLBAR_CARGOS_CAPTION                                      :{WHITE}{COMPANY} Cargo Transported {BLACK}{COMPANY_NUM}
+STR_TOOLBAR_CARGOS_NAME                                         :{BLACK}{STRING}
+
+#community choice - settings
+STR_CONFIG_SETTING_COMMUNITY                                    :Choose your community: {STRING2}
+STR_CONFIG_SETTING_CLIENT_COMMUNITY                             :Freelancer
+STR_CONFIG_SETTING_CLIENT_COMMUNITY_NICE                        :n-ice / http://n-ice.org
+STR_CONFIG_SETTING_CLIENT_COMMUNITY_BTPRO                       :BTPro / http://openttd.btpro.nl
+
+#industry filter
+STR_FILTER_TRANSPORTED_BOTH                                     :Show all (transported or not)
+STR_FILTER_TRANSPORTED_ONLY_NOT                                 :Show only non-transported
+STR_FILTER_TRANSPORTED_ONLY                                     :Show only transported
+STR_FILTER_INDUSTRY_TYPE_ALL                                    :Show all
+
+STR_BT_NEW_CLIENT_AVAILABLE                                     :{WHITE}?? ATTENTION ?? There's a new BTPro client available. Visit openttd.btpro.nl (Website button below :)
+STR_CC_WIKI_USER_PAGE                                           :{BLACK}{RAW_STRING}
+STR_CC_WIKI_USER_PAGE_TOOLTIP                                   :{BLACK}Open browser in Community Website
+
+# Industry tooltip
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP                           :{BLACK}{STRING}
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_1                         :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%)
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_2                         :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%)
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_3                         :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%)
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_4                         :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%)
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_5                         :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%)
+STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP_6                         :{BLACK}{STRING}{}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%){}{CARGO_LONG} ({COMMA}%)
+
+# Station tooltip
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP                            :{BLACK}{STATION}
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_1                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%)
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_2                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%)
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_3                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%)
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_4                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%)
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_5                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%)
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_6                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%)
+STR_STATION_VIEW_TRANSPORTED_TOOLTIP_7                          :{BLACK}{STATION}{}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{BLACK}{CARGO_LONG} ({COMMA}%){}{SILVER}(...)
+
+# Town tooltip
+STR_TOWN_NAME_TOOLTIP                                           :{BLACK}{TOWN}
+
+######## Watch Window
+STR_WATCH_WINDOW_TITLE                                          :{WHITE}{RAW_STRING} in {RAW_STRING}({NUM}).
+STR_WATCH_WINDOW_TITLE2								                    			:{WHITE}Watching {RAW_STRING} {BLACK}({NUM}).
+STR_WATCH_CLICK_TO_WATCH_COMPANY_NUMBER                         :{BLACK}{NUM}
+STR_WATCH_CLICK_TO_WATCH_COMPANY                                :{BLACK}Click here to watch this company building
+STR_WATCH_CLICK_TO_OPEN_COMPANY                                 :{BLACK}Click here to open this company window
+STR_WATCH_CLICK_NEW_WINDOW                                      :{BLACK}Click here to open new watching window
+
+STR_CC_OTHER_TOKEN_WSA_ERROR                                    :{WHITE}WSAStartup() failed
+STR_CC_OTHER_TOKEN_SOCKET_ERROR                                 :{WHITE}socket() failed
+STR_CC_OTHER_TOKEN_CONNECT_ERROR                                :{WHITE}connect() failed
+STR_CC_OTHER_TOKEN_SENT_ERROR                                   :{WHITE}send() sent a different number of bytes than expected
+STR_CC_OTHER_TOKEN_LOGIN_ERROR                                  :{WHITE}Wrong Username or Password!
+
+STR_CONFIG_SETTING_ENABLE_EXTRA_TOOLTIPS                        :Enable extra tooltips{STRING2}
+STR_TTE_HOUSE_NAME                                              :{LTBLUE}{STRING}
+STR_TTE_HOUSE                                                   :{BLACK}Population: {NUM}
+STR_TTE_INDUSTRY_NAME                                           :{LTBLUE}{INDUSTRY}
+STR_TTE_INDUSTRY                                                :{WHITE}{STRING}  {BLACK}{CARGO_SHORT} {YELLOW}{NUM} %
+STR_TTE_STATION_NAME                                            :{LTBLUE}{STATION}
+STR_TTE_STATION                                                 :{WHITE}{STRING}  {BLACK}{CARGO_SHORT} {YELLOW}{NUM} %
+STR_LAND_AREA_INFORMATION_POP                                   :{BLACK}Population: {LTBLUE}{NUM}
+
+STR_CONFIG_SETTING_POWERFUND_MONEY                              :Powerfund minimum needed money for fund: {STRING2}
+STR_CONFIG_SETTING_POWERFUND_HOUSES                             :Maximum amount of houses to powerfund up to
+
+######## Zoning toolbar
+
+STR_ZONING_TOOLBAR                                              :{WHITE}Zoning toolbar
+STR_ZONING_OUTER                                                :{BLACK}Outer tile borders:
+STR_ZONING_INNER                                                :{BLACK}Inner tile borders:
+STR_ZONING_OUTER_INFO                                           :{BLACK}Select which type of zoning you want on the outer border of a tile.
+STR_ZONING_INNER_INFO                                           :{BLACK}Select which type of zoning you want on the inner border of a tile.
+
+STR_ZONING_NO_ZONING                                            :{BLACK}Nothing
+STR_ZONING_AUTHORITY                                            :{BLACK}Authority
+STR_ZONING_CAN_BUILD                                            :{BLACK}Where I can't build
+STR_ZONING_STA_CATCH                                            :{BLACK}Station catchment
+STR_ZONING_IND_CATCH                                            :{BLACK}Industry catchment
+STR_ZONING_BUL_CATCH                                            :{BLACK}City catchment
+STR_ZONING_BUL_UNSER                                            :{BLACK}Unserved buildings
+STR_ZONING_IND_UNSER                                            :{BLACK}Unserved industries
+STR_ZONING_TOWN_ZONES                                           :{BLACK}Town zones
+STR_ZONING_CB_TOWN_BORDERS                                      :{BLACK}CB town borders
+STR_ZONING_CB_BORDERS                                           :{BLACK}CB borders
+STR_ZONING_ADVERTISEMENT_ZONES                                  :{BLACK}Advertisement
+STR_ZONING_TOWN_GROWTH_TILES                                    :{BLACK}Town growth tiles
+
+### Town CB gui
+STR_BUTTON_CB                                                   :{STRING}
+STR_BUTTON_CB_YES                                               :{BLACK}CB
+STR_TOWN_VIEW_CB_CAPTION                                        :{WHITE}{TOWN}
+
+STR_CB_LARGE_ADVERTISING_CAMPAIGN                               :{BLACK}Large Advertising
+STR_CB_NEW_BUILDINGS                                            :{BLACK}Fund Buildings
+STR_CB_FUND_REGULAR                                             :{BLACK}Fund Regularly
+STR_CB_FUND_REGULAR_TT                                          :{BLACK}Every time fund buildings is zero and company has enough money, buildings will be funded automatically
+STR_CB_FUNDED_REGULARLY                                         :{GREEN}Town is funded regularly
+STR_CB_ADVERT_REGULAR                                           :{BLACK}Adv. Regularly
+STR_CB_ADVERT_REGULAR_TT                                        :{BLACK}Automatically advertise town whenever stations rating drops below a certain point
+STR_CB_POWERFUND                                                :{BLACK}Powerfund
+STR_CB_ADVERT_REGULAR_RATING_TO_KEEP                            :{BLACK}Keep station rating at
+STR_CB_POWERFUND_TT                                             :{BLACK}Continiously funds town with maximum speed possible
+
+STR_TOWN_CB_FUNDING                                             :{ORANGE}Funded for {YELLOW}{COMMA}{ORANGE} month{P "" s}
+STR_TOWN_CB_GROWING                                             :{GREEN}Town is growing!
+STR_TOWN_CB_NOT_GROWING                                         :{WHITE}Town is not growing
+STR_TOWN_CB_GROWING_DETAIL                                      :{ORANGE}1 house in {YELLOW}{COMMA} {ORANGE}days ({YELLOW}{COMMA}%{ORANGE}). Next House in {YELLOW}{COMMA} {ORANGE}days
+
+STR_TOWN_GROWTH_HEADER_CARGO                                    :{BLACK}Cargo
+STR_TOWN_GROWTH_HEADER_AMOUNT                                   :{BLACK}Delivered
+STR_TOWN_GROWTH_HEADER_REQ                                      :{BLACK}Required
+STR_TOWN_GROWTH_HEADER_LAST                                     :{BLACK}Last Month
+STR_TOWN_GROWTH_HEADER_STORE                                    :{BLACK}Stored
+STR_TOWN_GROWTH_HEADER_STORE_PCT                                :{BLACK}Use%
+STR_TOWN_GROWTH_HEADER_FROM                                     :{BLACK}From
+
+STR_TOWN_CB_CARGO_NAME                                          :{BLACK}{STRING}:
+
+STR_TOWN_CB_CARGO_AMOUNT_GOOD                                   :{GREEN}{COMMA}
+STR_TOWN_CB_CARGO_AMOUNT_BAD                                    :{YELLOW}{COMMA}
+STR_TOWN_CB_CARGO_AMOUNT_NOT                                    :{SILVER}{COMMA}
+
+STR_TOWN_CB_CARGO_REQ_YES                                       :{ORANGE}{COMMA}
+STR_TOWN_CB_CARGO_REQ_NOT                                       :{SILVER}{COMMA}
+
+STR_TOWN_CB_CARGO_STORE_YES                                     :{LTBLUE}{COMMA}
+STR_TOWN_CB_CARGO_STORE_NOT                                     :{SILVER}{COMMA}
+STR_TOWN_CB_CARGO_STORE_DECAY                                   :{BLACK}-
+
+STR_TOWN_CB_CARGO_STORE_PCT_YES                                 :{LTBLUE}{COMMA}%
+STR_TOWN_CB_CARGO_STORE_PCT_NOT                                 :{SILVER}{COMMA}%
+
+STR_TOWN_CB_CARGO_PREVIOUS_YES                                  :{GREEN}{COMMA}
+STR_TOWN_CB_CARGO_PREVIOUS_EDGE                                 :{YELLOW}{COMMA}
+STR_TOWN_CB_CARGO_PREVIOUS_BAD                                  :{RED}{COMMA}
+STR_TOWN_CB_CARGO_PREVIOUS_NOT                                  :{SILVER}{COMMA}
+
+STR_TOWN_CB_CARGO_FROM_YES                                      :{YELLOW}{COMMA}
+STR_TOWN_CB_CARGO_FROM_NOT                                      :{SILVER}{COMMA}
+
+STR_CB_GUI_TOWN_VIEW_BUTTON                                     :{BLACK}Town view
+STR_CB_GUI_TOWN_VIEW_TOOLTIP                                    :{BLACK}Show information on town
diff --git a/src/main_gui.cpp b/src/main_gui.cpp
index 42a2a7eff..653998acc 100644
--- a/src/main_gui.cpp
+++ b/src/main_gui.cpp
@@ -33,6 +33,13 @@
 #include "tilehighlight_func.h"
 #include "hotkeys.h"
 #include "guitimer_func.h"
+#include "watch_gui_1.h"
+#include "industry.h"
+#include "town_map.h"
+ 
+#include "station_gui.h"
+#include "station_base.h"
+#include "cargotype.h"
 
 #include "saveload/saveload.h"
 
@@ -108,7 +115,7 @@ bool HandlePlacePushButton(Window *w, int widget, CursorID cursor, HighLightStyl
 	if (_settings_client.sound.click_beep) SndPlayFx(SND_15_BEEP);
 	w->SetDirty();
 
-	if (w->IsWidgetLowered(widget)) {
+	if (w->IsWidgetLowered(widget) && mode == _thd.place_mode) {
 		ResetObjectToPlace();
 		return false;
 	}
@@ -221,6 +228,7 @@ static const struct NWidgetPart _nested_main_window_widgets[] = {
 
 enum {
 	GHK_QUIT,
+	GHK_WATCH_WINDOW,
 	GHK_ABANDON,
 	GHK_CONSOLE,
 	GHK_BOUNDING_BOXES,
@@ -407,6 +415,8 @@ struct MainWindow : Window
 				ResetRestoreAllTransparency();
 				break;
 
+      case GHK_WATCH_WINDOW:	ShowWatchWindow1( INVALID_COMPANY );	break;
+
 #ifdef ENABLE_NETWORK
 			case GHK_CHAT: // smart chat; send to team if any, otherwise to all
 				if (_networking) {
@@ -479,6 +489,97 @@ struct MainWindow : Window
 		InvalidateWindowData(WC_MAIN_TOOLBAR, 0, data, true);
 	}
 
+  virtual void OnMouseOver(Point pt, int widget)
+	{
+		if (_game_mode != GM_MENU && _settings_client.gui.enable_extra_tooltips && pt.x != -1) {
+			GuiPrepareTooltipsExtra(this);
+		/* Show tooltip with last month production or town name */
+		} else if (pt.x != -1 && _game_mode != GM_MENU) {
+			TileIndex tile;
+			const bool viewport_is_in_map_mode = (this->viewport->zoom > ZOOM_LVL_MAX);
+			//const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_MAX);
+			//const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_DRAW_MAP);
+			if (viewport_is_in_map_mode) {
+        // Disable, for now :)
+				/*const int a = ((ScaleByZoom(pt.x, this->viewport->zoom) + this->viewport->virtual_left) >> 2) / ZOOM_LVL_BASE;
+				const int b = ((ScaleByZoom(pt.y, this->viewport->zoom) + this->viewport->virtual_top) >> 1) / ZOOM_LVL_BASE;
+				tile = TileVirtXY(b - a, b + a);*/
+			} else {
+				const Point p = GetTileBelowCursor();
+				tile = TileVirtXY(p.x, p.y);
+			}
+			if (tile >= MapSize()) return;
+
+			switch (GetTileType(tile)) {
+				case MP_ROAD:
+					if (IsRoadDepot(tile)) return;
+					/* FALL THROUGH */
+				case MP_HOUSE: {
+					if (HasBit(_display_opt, DO_SHOW_TOWN_NAMES)) return; // No need for a town name tooltip when it is already displayed
+					if (!viewport_is_in_map_mode) return;
+					const TownID tid = GetTownIndex(tile);
+					if (!tid) return;
+					SetDParam(0, tid);
+					GuiShowTooltips(this, STR_TOWN_NAME_TOOLTIP, 0, NULL, TCC_HOVER);
+					break;
+				}
+				case MP_INDUSTRY: {
+					const Industry *ind = Industry::GetByTile(tile);
+					const IndustrySpec *indsp = GetIndustrySpec(ind->type);
+
+					StringID str = STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP;
+					uint prm_count = 0;
+					SetDParam(prm_count++, indsp->name);
+					for (byte i = 0; i < lengthof(ind->produced_cargo); i++) {
+						if (ind->produced_cargo[i] != CT_INVALID) {
+							SetDParam(prm_count++, ind->produced_cargo[i]);
+							SetDParam(prm_count++, ind->last_month_production[i]);
+							SetDParam(prm_count++, ToPercent8(ind->last_month_pct_transported[i]));
+							str++;
+						}
+					}
+					if (prm_count <= 19) {
+            GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+          }
+					break;
+				}
+				case MP_STATION: {
+          if (!IsRailWaypoint(tile)) {
+            if (!HasTileWaterGround(tile)) {
+              const Station *st = Station::GetByTile(tile);
+              StringID str = STR_STATION_VIEW_TRANSPORTED_TOOLTIP;
+              uint prm_count = 0;
+              SetDParam(prm_count++, st->index);
+              for (int i = 0; i < _sorted_standard_cargo_specs_size; i++) {
+                const CargoSpec *cs = _sorted_cargo_specs[i];
+                //const CargoSpec *cs = CargoSpec::Get(i);
+                if(cs == NULL) continue;
+                int cargoid = cs->Index();
+                //if (HasBit(st->goods[i].status,GoodsEntry::GES_RATING)) {
+                if (HasBit(st->goods[cargoid].status, GoodsEntry::GES_RATING)) {
+                  SetDParam(prm_count++, cs->Index());
+                  SetDParam(prm_count++, st->goods[cargoid].cargo.TotalCount());
+                  SetDParam(prm_count++, ToPercent8(st->goods[cargoid].rating));
+                  str++;
+                  if (prm_count == 19) {
+                    str++;
+                    i = _sorted_standard_cargo_specs_size;
+                  }
+                }
+              }
+              if (prm_count <= 19) {
+                GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+              }
+            }
+          }
+					break;
+				}
+				default:
+					return;
+			}
+		}
+	}
+
 	static HotkeyList hotkeys;
 };
 
@@ -532,6 +633,7 @@ static Hotkey global_hotkeys[] = {
 	Hotkey(_ghk_chat_company_keys, "chat_company", GHK_CHAT_COMPANY),
 	Hotkey(_ghk_chat_server_keys, "chat_server", GHK_CHAT_SERVER),
 #endif
+  Hotkey('O', "show_watch_window", GHK_WATCH_WINDOW),
 	HOTKEY_LIST_END
 };
 HotkeyList MainWindow::hotkeys("global", global_hotkeys);
diff --git a/src/misc.cpp b/src/misc.cpp
index 8151f2dd3..733b53d2f 100644
--- a/src/misc.cpp
+++ b/src/misc.cpp
@@ -112,6 +112,7 @@ void InitializeGame(uint size_x, uint size_y, bool reset_date, bool reset_settin
 	InitializeEconomy();
 
 	ResetObjectToPlace();
+	ClearRailPlacementEndpoints();
 
 	GamelogReset();
 	GamelogStartAction(GLAT_START);
diff --git a/src/misc_gui.cpp b/src/misc_gui.cpp
index 061070a2b..930e376e6 100644
--- a/src/misc_gui.cpp
+++ b/src/misc_gui.cpp
@@ -34,6 +34,14 @@
 
 #include "safeguards.h"
 
+#include "house.h"
+#include "town_map.h"
+#include "station_base.h"
+#include "viewport_func.h"
+#include "industry.h"
+
+void GuiShowTooltipsExtra(Window *parent, uint param, TooltipCloseCondition close_tooltip);
+
 /** Method to open the OSK. */
 enum OskActivation {
 	OSKA_DISABLED,           ///< The OSK shall not be activated at all.
@@ -42,8 +50,8 @@ enum OskActivation {
 	OSKA_IMMEDIATELY,        ///< Focusing click already opens OSK.
 };
 
-
-static const NWidgetPart _nested_land_info_widgets[] = {
+//old
+static const NWidgetPart _nested_land_info_widgets_old[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
 		NWidget(WWT_CAPTION, COLOUR_GREY), SetDataTip(STR_LAND_AREA_INFORMATION_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
@@ -52,10 +60,24 @@ static const NWidgetPart _nested_land_info_widgets[] = {
 	NWidget(WWT_PANEL, COLOUR_GREY, WID_LI_BACKGROUND), EndContainer(),
 };
 
-static WindowDesc _land_info_desc(
+//new
+static const NWidgetPart _nested_land_info_widgets[] = {
+	NWidget(WWT_PANEL, COLOUR_GREY, WID_LI_BACKGROUND), SetMinimalSize(64, 32),     EndContainer(),
+};
+
+//old
+static WindowDesc _land_info_desc_old(
 	WDP_AUTO, "land_info", 0, 0,
 	WC_LAND_INFO, WC_NONE,
 	0,
+        _nested_land_info_widgets_old, lengthof(_nested_land_info_widgets_old)
+);
+
+//new
+static WindowDesc _land_info_desc(
+        WDP_MANUAL, "land_info", 0, 0,
+	WC_LAND_INFO, WC_NONE,
+	0,
 	_nested_land_info_widgets, lengthof(_nested_land_info_widgets)
 );
 
@@ -71,6 +93,19 @@ class LandInfoWindow : public Window {
 public:
 	char landinfo_data[LAND_INFO_LINE_END][LAND_INFO_LINE_BUFF_SIZE];
 	TileIndex tile;
+       TileIndex end_tile;  ///< For use in ruler(dragdrop) mode
+
+       virtual Point OnInitialPosition(int16 sm_width, int16 sm_height, int window_number)
+       {
+               int scr_top = GetMainViewTop() + 2;
+               int scr_bot = GetMainViewBottom() - 2;
+               Point pt;
+               pt.y = Clamp(_cursor.pos.y + _cursor.total_size.y + _cursor.total_offs.y + 5, scr_top, scr_bot);
+               if (pt.y + sm_height > scr_bot) pt.y = min(_cursor.pos.y + _cursor.total_offs.y - 5, scr_bot) - sm_height;
+               pt.x = sm_width >= _screen.width ? 0 : Clamp(_cursor.pos.x - (sm_width >> 1), 0, _screen.width - sm_width);
+               return pt;
+       }
+
 
 	virtual void DrawWidget(const Rect &r, int widget) const
 	{
@@ -114,9 +149,18 @@ public:
 		}
 	}
 
-	LandInfoWindow(TileIndex tile) : Window(&_land_info_desc), tile(tile)
+	//old
+	LandInfoWindow(TileIndex tile, TileIndex end_tile, bool oldinfo): Window(&_land_info_desc_old), tile(tile)
+	{
+		this->InitNested();
+	}
+
+	//new
+       LandInfoWindow(TileIndex tile, TileIndex end_tile=INVALID_TILE) :
+               Window(&_land_info_desc), tile(tile), end_tile(end_tile)
 	{
 		this->InitNested();
+                CLRBITS(this->flags, WF_WHITE_BORDER);
 
 #if defined(_DEBUG)
 #	define LANDINFOD_LEVEL 0
@@ -167,6 +211,7 @@ public:
 		td.railtype = STR_NULL;
 		td.rail_speed = 0;
 		td.road_speed = 0;
+		td.population = 0;
 
 		td.grf = NULL;
 
@@ -300,6 +345,14 @@ public:
 			line_nr++;
 		}
 
+               /* House pop */
+               if (td.population != 0) {
+                       SetDParam(0, td.population);
+                       GetString(this->landinfo_data[line_nr], STR_LAND_AREA_INFORMATION_POP, lastof(this->landinfo_data[line_nr]));
+                       line_nr++;
+               }
+
+
 		assert(line_nr < LAND_INFO_CENTERED_LINES);
 
 		/* Mark last line empty */
@@ -353,16 +406,34 @@ public:
 				break;
 		}
 	}
+
+
+       virtual void OnMouseLoop()
+       {
+		if (_settings_client.gui.enable_extra_tooltips) {
+	               /* Always close tooltips when the cursor is not in our window. */
+	               if (!_cursor.in_window) {
+	                       delete this;
+	                       return;
+	               }
+	               if (!_mouse_hovering) delete this;
+		}
+       }
+
 };
 
 /**
  * Show land information window.
  * @param tile The tile to show information about.
  */
-void ShowLandInfo(TileIndex tile)
+void ShowLandInfo(TileIndex tile, TileIndex end_tile)
 {
 	DeleteWindowById(WC_LAND_INFO, 0);
-	new LandInfoWindow(tile);
+	if (_settings_client.gui.enable_extra_tooltips) {
+		new LandInfoWindow(tile, end_tile);
+	} else {
+		new LandInfoWindow(tile, end_tile, true);
+	}
 }
 
 static const NWidgetPart _nested_about_widgets[] = {
@@ -651,11 +722,13 @@ struct TooltipsWindow : public Window
 	byte paramcount;                  ///< Number of string parameters in #string_id.
 	uint64 params[5];                 ///< The string parameters.
 	TooltipCloseCondition close_cond; ///< Condition for closing the window.
+	char buffer[DRAW_STRING_BUFFER];  ///< Text to draw
 
 	TooltipsWindow(Window *parent, StringID str, uint paramcount, const uint64 params[], TooltipCloseCondition close_tooltip) : Window(&_tool_tips_desc)
 	{
 		this->parent = parent;
 		this->string_id = str;
+		if (paramcount == 0) GetString(this->buffer, str, lastof(this->buffer)); // Get the text while params are still around
 		assert_compile(sizeof(this->params[0]) == sizeof(params[0]));
 		assert(paramcount <= lengthof(this->params));
 		if (paramcount > 0) memcpy(this->params, params, sizeof(this->params[0]) * paramcount);
@@ -706,10 +779,14 @@ struct TooltipsWindow : public Window
 		GfxFillRect(r.left, r.top, r.right, r.bottom, PC_BLACK);
 		GfxFillRect(r.left + 1, r.top + 1, r.right - 1, r.bottom - 1, PC_LIGHT_YELLOW);
 
-		for (uint arg = 0; arg < this->paramcount; arg++) {
-			SetDParam(arg, this->params[arg]);
+		if (this->paramcount == 0) {
+			DrawStringMultiLine(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, r.bottom - WD_FRAMERECT_BOTTOM, this->buffer, TC_FROMSTRING, SA_CENTER);
+		} else {
+			for (uint arg = 0; arg < this->paramcount; arg++) {
+				SetDParam(arg, this->params[arg]);
+			}
+			DrawStringMultiLine(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, r.bottom - WD_FRAMERECT_BOTTOM, this->string_id, TC_FROMSTRING, SA_CENTER);
 		}
-		DrawStringMultiLine(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, r.bottom - WD_FRAMERECT_BOTTOM, this->string_id, TC_FROMSTRING, SA_CENTER);
 	}
 
 	virtual void OnMouseLoop()
@@ -1219,3 +1296,258 @@ void ShowQuery(StringID caption, StringID message, Window *parent, QueryCallback
 
 	new QueryWindow(&_query_desc, caption, message, parent, callback);
 }
+
+
+/** Window for displaying a tooltip. */
+void GuiPrepareTooltipsExtra(Window *parent){
+       const Point p = GetTileBelowCursor();
+       if (p.x == -1) return;
+       const TileIndex tile = TileVirtXY(p.x, p.y);
+
+       //if (_cursor.sprite == SPR_CURSOR_QUERY) {  //original
+       if (_cursor.sprite_seq[0].sprite == SPR_CURSOR_QUERY) {  //test
+               // Land info tool active
+               ShowLandInfo(tile);
+               return;
+       }
+
+       if (!_settings_client.gui.enable_extra_tooltips)
+               return;
+
+       if (tile >= MapSize()) return;
+       uint param = 0;
+       switch (GetTileType(tile)) {
+               case MP_HOUSE: {
+                       const HouseID house = GetHouseType(tile);
+                       param = ((house & 0xFFFF) << 16) | MP_HOUSE;
+                       break;
+               }
+               case MP_INDUSTRY: {
+                       const Industry *ind = Industry::GetByTile(tile);
+                       if(ind->produced_cargo[0] == CT_INVALID && ind->produced_cargo[1] == CT_INVALID) return;
+                       param = ((ind->index & 0xFFFF) << 16) | MP_INDUSTRY;
+                       break;
+               }
+               case MP_STATION: {
+                       if (IsRailWaypoint(tile) || HasTileWaterGround(tile)) break;
+                       const Station *st = Station::GetByTile(tile);
+                       param |= ((st->index & 0xFFFF) << 16) | MP_STATION;
+                       break;
+               }
+               default:
+                       return;
+       }
+       if(param != 0) GuiShowTooltipsExtra(parent, param, TCC_HOVER);
+}
+
+static const NWidgetPart _nested_tooltips_extra_widgets[] = {
+       NWidget(WWT_PANEL, COLOUR_GREY, WID_TT_BACKGROUND), SetMinimalSize(64, 32),     EndContainer(),
+};
+
+static WindowDesc _tool_tips_extra_desc(
+       WDP_MANUAL, NULL, 0, 0,
+       WC_TOOLTIPS_EXTRA, WC_NONE,
+       0,
+       _nested_tooltips_extra_widgets, lengthof(_nested_tooltips_extra_widgets)
+);
+
+struct TooltipsExtraWindow : public Window
+{
+       TileType tiletype;
+       uint16 objIndex;
+       TooltipCloseCondition close_cond;
+
+       TooltipsExtraWindow(Window *parent, uint param, TooltipCloseCondition close_tooltip) : Window(&_tool_tips_extra_desc)
+       {
+               this->parent = parent;
+               this->tiletype = (TileType)(param & 0xFFFF);
+               this->objIndex = (uint16)((param >> 16) & 0xFFFF);
+               this->close_cond = close_tooltip;
+               this->InitNested();
+               CLRBITS(this->flags, WF_WHITE_BORDER);
+       }
+
+       virtual Point OnInitialPosition(int16 sm_width, int16 sm_height, int window_number)
+       {
+               int scr_top = GetMainViewTop() + 2;
+               int scr_bot = GetMainViewBottom() - 2;
+               Point pt;
+               pt.y = Clamp(_cursor.pos.y + _cursor.total_size.y + _cursor.total_offs.y + 5, scr_top, scr_bot);
+               if (pt.y + sm_height > scr_bot) pt.y = min(_cursor.pos.y + _cursor.total_offs.y - 5, scr_bot) - sm_height;
+               pt.x = sm_width >= _screen.width ? 0 : Clamp(_cursor.pos.x - (sm_width >> 1), 0, _screen.width - sm_width);
+               return pt;
+       }
+
+       virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+       {
+               uint icon_size = ScaleGUITrad(10);
+               uint line_height = max((uint)FONT_HEIGHT_NORMAL, icon_size) + 2;
+               uint icons_width = icon_size * 3 + 20;
+               size->width = 200;
+               size->height = FONT_HEIGHT_NORMAL + 6;
+               switch(this->tiletype) {
+                       case MP_HOUSE: {
+                              const HouseID house = (HouseID)this->objIndex;
+                              const HouseSpec *hs = HouseSpec::Get(house);
+
+                              size->height += line_height;
+                               SetDParam(0, 1000);
+                               size->width = GetStringBoundingBox(STR_TTE_HOUSE).width;
+                               if(hs == NULL) break;
+                              SetDParam(0, hs->building_name);
+                              size->width = max(GetStringBoundingBox(STR_TTE_HOUSE_NAME).width + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT + 18, size->width);
+                               break;
+                       }
+                       case MP_INDUSTRY: {
+                               const Industry *ind = Industry::GetIfValid((IndustryID)this->objIndex);
+                               if(ind == NULL) break;
+
+                               for (CargoID i = 0; i < lengthof(ind->produced_cargo); i++) {
+                                       if (ind->produced_cargo[i] == CT_INVALID) continue;
+                                       const CargoSpec *cs = CargoSpec::Get(ind->produced_cargo[i]);
+                                       if(cs == NULL) continue;
+                                       size->height += line_height;
+                                       SetDParam(0, cs->name);
+                                       SetDParam(1, cs->Index());
+                                       SetDParam(2, ind->last_month_production[i]);
+                                       SetDParam(3, ToPercent8(ind->last_month_pct_transported[i]));
+                                       size->width = max(GetStringBoundingBox(STR_TTE_INDUSTRY).width + icons_width, size->width);
+                               }
+                               break;
+                       }
+                       case MP_STATION: {
+                               const Station *st = Station::GetIfValid((StationID)this->objIndex);
+                               if(st == NULL) break;
+
+                               for (int i = 0; i < _sorted_standard_cargo_specs_size; i++) {
+                                       const CargoSpec *cs = _sorted_cargo_specs[i];
+                                       if(cs == NULL) continue;
+                                       int cargoid = cs->Index();
+                                       if (HasBit(st->goods[cargoid].status, GoodsEntry::GES_RATING)) {
+                                               size->height += line_height;
+                                               SetDParam(0, cs->name);
+                                               SetDParam(1, cargoid);
+                                               SetDParam(2, st->goods[cargoid].cargo.TotalCount());
+                                               SetDParam(3, ToPercent8(st->goods[cargoid].rating));
+                                               size->width = max(GetStringBoundingBox(STR_TTE_STATION).width + icons_width, size->width);
+                                       }
+                               }
+                               break;
+                       }
+                       default:
+                               break;
+               }
+               size->width  += 2 + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+               size->height += 2 + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+       }
+
+       virtual void DrawWidget(const Rect &r, int widget) const
+       {
+               uint icon_size = ScaleGUITrad(10);
+               uint line_height = max((uint)FONT_HEIGHT_NORMAL, icon_size) + 2;
+               uint icons_width = icon_size * 3 + 10;
+               uint text_ofs = (line_height - FONT_HEIGHT_NORMAL) >> 1;
+               uint icon_ofs = (line_height - icon_size) >> 1;
+
+               GfxDrawLine(r.left,  r.top,    r.right, r.top,    PC_BLACK);
+               GfxDrawLine(r.left,  r.bottom, r.right, r.bottom, PC_BLACK);
+               GfxDrawLine(r.left,  r.top,    r.left,  r.bottom, PC_BLACK);
+               GfxDrawLine(r.right, r.top,    r.right, r.bottom, PC_BLACK);
+
+               int y = r.top + WD_FRAMERECT_TOP + 4;
+               int left = r.left + WD_FRAMERECT_LEFT + 4;
+
+               switch(this->tiletype) {
+                       case MP_HOUSE: {
+                               const HouseID house = (HouseID)this->objIndex;
+                               const HouseSpec *hs = HouseSpec::Get(house);
+
+
+                               if(hs == NULL) break;
+
+                               SetDParam(0, hs->building_name);
+                               DrawString(left, r.right - WD_FRAMERECT_RIGHT, y, STR_TTE_HOUSE_NAME, TC_BLACK, SA_CENTER);
+                               y += FONT_HEIGHT_NORMAL + 2;
+                               SetDParam(0, hs->population);
+                               DrawString(left, r.right - WD_FRAMERECT_RIGHT, y, STR_TTE_HOUSE, TC_BLACK, SA_CENTER);
+                               break;
+                       }
+                       case MP_INDUSTRY: {
+                               const Industry *ind = Industry::GetIfValid((IndustryID)this->objIndex);
+                               if(ind == NULL) break;
+
+                               SetDParam(0, ind->index);
+                               DrawString(left, r.right - WD_FRAMERECT_RIGHT, y, STR_TTE_INDUSTRY_NAME, TC_BLACK, SA_CENTER);
+                               y += FONT_HEIGHT_NORMAL + 2;
+
+                               for (CargoID i = 0; i < lengthof(ind->produced_cargo); i++) {
+                                       if (ind->produced_cargo[i] == CT_INVALID) continue;
+                                       const CargoSpec *cs = CargoSpec::Get(ind->produced_cargo[i]);
+                                       if(cs == NULL) continue;
+                                       SetDParam(0, cs->name);
+                                       SetDParam(1, cs->Index());
+                                       SetDParam(2, ind->last_month_production[i]);
+                                       SetDParam(3, ToPercent8(ind->last_month_pct_transported[i]));
+
+                                       this->DrawSpriteIcons(cs->GetCargoIcon(), left, y + icon_ofs);
+                                       DrawString(left + icons_width, r.right - WD_FRAMERECT_RIGHT, y + text_ofs, STR_TTE_INDUSTRY);
+                                       y += line_height;
+                               }
+                               break;
+                       }
+                       case MP_STATION: {
+                               const Station *st = Station::GetIfValid((StationID)this->objIndex);
+                               if(st == NULL) break;
+
+                               SetDParam(0, st->index);
+                               DrawString(left, r.right - WD_FRAMERECT_RIGHT, y, STR_TTE_STATION_NAME, TC_BLACK, SA_CENTER);
+                               y += FONT_HEIGHT_NORMAL + 2;
+
+                               for (int i = 0; i < _sorted_standard_cargo_specs_size; i++) {
+                                       const CargoSpec *cs = _sorted_cargo_specs[i];
+                                       if(cs == NULL) continue;
+                                       int cargoid = cs->Index();
+                                       if (HasBit(st->goods[cargoid].status, GoodsEntry::GES_RATING)) {
+                                               SetDParam(0, cs->name);
+                                               SetDParam(1, cargoid);
+                                               SetDParam(2, st->goods[cargoid].cargo.TotalCount());
+                                               SetDParam(3, ToPercent8(st->goods[cargoid].rating));
+                                               this->DrawSpriteIcons(cs->GetCargoIcon(), left, y + icon_ofs);
+                                               DrawString(left + icons_width, r.right - WD_FRAMERECT_RIGHT, y + text_ofs, STR_TTE_STATION);
+                                               y += line_height;
+                                       }
+                               }
+                               break;
+                       }
+                       default:
+                               break;
+               }
+       }
+
+       virtual void OnMouseLoop()
+       {
+               if (!_cursor.in_window) {
+                       delete this;
+                       return;
+               }
+
+               switch (this->close_cond) {
+                       case TCC_RIGHT_CLICK: if (!_right_button_down) delete this; break;
+                       case TCC_HOVER: if (!_mouse_hovering) delete this; break;
+               }
+       }
+
+       void DrawSpriteIcons(SpriteID sprite, int left, int top) const
+       {
+               uint step = ScaleGUITrad(10);
+               for(int i = 0; i < 3; i++) {
+                       DrawSprite(sprite, PAL_NONE, left + i * step, top);
+               }
+       }
+};
+
+void GuiShowTooltipsExtra(Window *parent, uint param, TooltipCloseCondition close_tooltip)
+{
+       DeleteWindowById(WC_TOOLTIPS_EXTRA, 0);
+       new TooltipsExtraWindow(parent, param, close_tooltip);
+}
diff --git a/src/network/network.cpp b/src/network/network.cpp
index 4727e3344..2745ae957 100644
--- a/src/network/network.cpp
+++ b/src/network/network.cpp
@@ -23,6 +23,9 @@
 #include "network_udp.h"
 #include "network_gamelist.h"
 #include "network_base.h"
+#include "network_func.h"
+#include "network_type.h"
+#include "network.h"
 #include "core/udp.h"
 #include "core/host.h"
 #include "network_gui.h"
@@ -37,6 +40,10 @@
 #include "../core/pool_func.hpp"
 #include "../gfx_func.h"
 #include "../error.h"
+#include "../settings_func.h"
+#include <iostream> //std
+#include "../strings_func.h"
+#include "../base64.h"
 
 #include "../safeguards.h"
 
@@ -83,6 +90,11 @@ uint16 _network_udp_broadcast;        ///< Timeout for the UDP broadcasts.
 uint8 _network_advertise_retries;     ///< The number of advertisement retries we did.
 CompanyMask _network_company_passworded; ///< Bitmask of the password status of all companies.
 
+std::string _server_list_text;
+char* _cc_address; //current adddress
+int _cc_porti; //current port
+uint8 _fromlast = 0;
+
 /* Check whether NETWORK_NUM_LANDSCAPES is still in sync with NUM_LANDSCAPE */
 assert_compile((int)NETWORK_NUM_LANDSCAPES == (int)NUM_LANDSCAPE);
 assert_compile((int)NETWORK_COMPANY_NAME_LENGTH == MAX_LENGTH_COMPANY_NAME_CHARS * MAX_CHAR_LENGTH);
@@ -656,6 +668,210 @@ void NetworkRebuildHostList()
 	}
 }
 
+/** To handle Community connections */
+class CommunityLoginManager: public HTTPCallback {
+public:
+	//CommunityLoginManager(const char *u, const char *p): username(u), password(p) {}
+	CommunityLoginManager() {}
+
+	void initiateLoginSequence() {
+    DeleteWindowByClass(WC_CC_TOKENLOGIN);
+    char uri[512];
+    const char *np;
+    std::string decoded;
+    std::string login_user;
+    const char *login_userch;
+    //IConsolePrint(CC_INFO, "INITIATING LOGIN SEQUENCE");
+    if(_settings_client.gui.community == 1){
+      decoded = base64_decode(_settings_client.network.community_password[0]);
+      decoded = urlencode(decoded);
+      np = decoded.c_str();
+      login_user = _settings_client.network.community_user[0];
+      login_user = urlencode(login_user);
+      login_userch = login_user.c_str();
+      seprintf(uri, lastof(uri), "http://n-ice.org/openttd/gettoken.php?user=%s&password=%s", login_userch, np);
+    } else if(_settings_client.gui.community == 2){
+      //decoded = base64_decode(_settings_client.network.community_password[1]);
+      decoded = _settings_client.network.community_password[1];
+      decoded = urlencode(decoded);
+      np = decoded.c_str();
+      login_user = _settings_client.network.community_user[1];
+      login_user = base64_encode(reinterpret_cast<const unsigned char*>(login_user.c_str()), login_user.length());
+      login_user = urlencode(login_user);
+      login_userch = login_user.c_str();
+      seprintf(uri, lastof(uri), "http://openttd.btpro.nl/gettoken-enc.php?user=%s&password=%s", login_userch, np);
+      //NetworkClientSendChat(NETWORK_ACTION_CHAT_CLIENT, DESTTYPE_CLIENT, CLIENT_ID_SERVER , uri);  // only to see result on testings
+    }
+    std::cout << "sending to http server: " << uri << std::endl;
+    this->cursor = this->buf;
+    NetworkHTTPSocketHandler::Connect(uri, this);
+	}
+
+	void sendLoginString() {
+    char b[16];
+    seprintf(b, lastof(b), "!login %s", this->buf);
+    NetworkClientSendChat(NETWORK_ACTION_CHAT_CLIENT, DESTTYPE_CLIENT, CLIENT_ID_SERVER , b);
+	}
+
+	void inspectLoginData() {
+    //IConsolePrint(CC_INFO, "INSPECTING DATA");
+    if (this->cursor - this->buf == 4) {
+      this->sendLoginString();
+      //IConsolePrint( CC_INFO, "*** Community Authentification successful ***");
+    } else {
+      //IConsolePrint(CC_ERROR, b);
+      ShowErrorMessage(STR_CC_OTHER_TOKEN_LOGIN_ERROR, INVALID_STRING_ID, WL_ERROR);
+    }
+	}
+
+	virtual void OnFailure() {
+    //std::cout << "*** UNABLE TO RETRIEVE LOGIN TOKEN FROM HTTP SERVER ***" << std::endl;
+    ShowErrorMessage(STR_CC_OTHER_TOKEN_CONNECT_ERROR, INVALID_STRING_ID, WL_ERROR);
+	}
+
+	virtual void OnReceiveData( const char *data, size_t length) {
+    size_t i = length;
+
+    if (data == 0) {
+      std::cout << "*** RECEIVED ALL HTTP DATA ***" << std::endl;
+      this->inspectLoginData();
+      this->cursor = 0;
+    } else {
+      std::cout << "*** RECEIVING HTTP DATA ***" << std::endl;
+      while ( this->cursor - this->buf < 512 && i) {
+        *this->cursor = *data;
+        data++;
+        this->cursor++;
+        i--;
+      }
+      if (this->cursor - this->buf >= 512)
+        this->buf[511] = 0;
+      else
+        *this->cursor = 0;
+    }
+	}
+
+  std::string urlencode(const std::string &s)
+  {
+    //RFC 3986 section 2.3 Unreserved Characters (January 2005)
+    const std::string unreserved = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.~";
+
+    std::string escaped="";
+    for(size_t i=0; i<s.length(); i++)
+    {
+        if (unreserved.find_first_of(s[i]) != std::string::npos)
+        {
+            escaped.push_back(s[i]);
+        }
+        else
+        {
+            escaped.append("%");
+            char buf[3];
+            seprintf(buf, lastof(buf), "%.2X", s[i]);
+            escaped.append(buf);
+        }
+    }
+    return escaped;
+  }
+
+private:
+	NetworkHTTPContentConnecter *conn;
+	char buf[512];
+	char	 *cursor;
+};
+
+static CommunityLoginManager loginmgr;
+
+void CommunityLoginManagerSend()
+{
+  loginmgr.initiateLoginSequence();
+}
+
+/** To handle Community Server list */
+class CommunityServerManager: public HTTPCallback {
+public:
+	CommunityServerManager() {}
+
+	void initiateServerSequence() {
+    char uri[512];
+    //IConsolePrint(CC_INFO, "INITIATING LOGIN SEQUENCE");
+    if(_settings_client.gui.community == 1){
+      seprintf(uri, lastof(uri), "http://n-ice.org/openttd/serverlist.txt");
+    } else if(_settings_client.gui.community == 2){
+      seprintf(uri, lastof(uri), "http://openttd.btpro.nl/btproservers.txt");
+    }
+    std::cout << "sending to http server: " << uri << std::endl;
+    this->cursor = this->buf;
+    NetworkHTTPSocketHandler::Connect(uri, this);
+	}
+
+	void SaveServerString() {
+    int tmpversion;
+    _server_list_text += this->buf;
+
+      if(_settings_client.gui.community == 2){
+        size_t posver = _server_list_text.find("bt.version.check:");
+        std::string saver = _server_list_text.substr(posver + 18, _server_list_text.find(";", posver + 18) - posver - 18);
+        tmpversion = atoi(saver.c_str());
+        _settings_client.gui.btpro_version = tmpversion;
+        SaveToConfig();
+      }
+	}
+
+  void inspectServerData() {
+    //IConsolePrint(CC_INFO, "INSPECTING DATA");
+    if (this->cursor - this->buf >= 4) {
+      this->SaveServerString();
+      
+    } else {
+      ShowErrorMessage(STR_CC_OTHER_TOKEN_CONNECT_ERROR, INVALID_STRING_ID, WL_ERROR);
+    }
+	}
+
+	virtual void OnFailure() {
+    //std::cout << "*** UNABLE TO RETRIEVE LOGIN TOKEN FROM HTTP SERVER ***" << std::endl;
+    ShowErrorMessage(STR_CC_OTHER_TOKEN_CONNECT_ERROR, INVALID_STRING_ID, WL_ERROR);
+	}
+
+	virtual void OnReceiveData( const char *data, size_t length) {
+    size_t i = length;
+    IConsolePrintF(CC_INFO, "Size: %i", i);
+
+    if (data == 0) {
+      std::cout << "*** RECEIVED ALL HTTP DATA ***" << std::endl;
+      //_server_list_text += this->buf;
+      this->inspectServerData();
+      DeleteWindowByClass(WC_SELECT_GAME);///restart the windows
+      extern void ShowSelectGameWindow();
+      ShowSelectGameWindow();
+      this->cursor = 0;
+    } else {
+      std::cout << "*** RECEIVING HTTP DATA ***" << std::endl;
+      while ( this->cursor - this->buf < 4096 && i) {
+        *this->cursor = *data;
+        data++;
+        this->cursor++;
+        i--;
+      }
+      if (this->cursor - this->buf >= 4096)
+        this->buf[4095] = 0;
+      else
+        *this->cursor = 0;
+    }
+	}
+private:
+	NetworkHTTPContentConnecter *conn;
+	char buf[4096];
+	char	 *cursor;
+};
+
+static CommunityServerManager servermgr;
+
+void CommunityServerManagerSend()
+{
+  servermgr.initiateServerSequence();
+}
+
 /** Non blocking connection create to actually connect to servers */
 class TCPClientConnecter : TCPConnecter {
 public:
@@ -689,6 +905,45 @@ void NetworkClientConnectGame(NetworkAddress address, CompanyID join_as, const c
 	_network_join_server_password = join_server_password;
 	_network_join_company_password = join_company_password;
 
+  //where did we join? - IP check
+	IConsolePrintF(CC_WHITE, "ip   %s", _settings_client.network.last_host);	
+	if(     strcmp(_settings_client.network.last_host, "176.9.26.206") == 0
+    ||  strcmp(_settings_client.network.last_host, "openttd.n-ice.org") == 0
+    ||  strcmp(_settings_client.network.last_host, "openttd.boxor.net") == 0
+    ||  strcmp(_settings_client.network.last_host, "2a01:4f8:150:24c5:77d::") == 0
+    ||  strcmp(_settings_client.network.last_host, "23.92.218.75") == 0
+    ||  strcmp(_settings_client.network.last_host, "supervds.boxor.net") == 0
+		||  strstr(_settings_client.network.last_host, "n-ice") != NULL)
+	{ //if we BTPro chosen and n-ice IP, change to n-ice		 
+		if(_settings_client.gui.community != 1){
+			_settings_client.gui.community = 1;
+			GetCommunityServerListText();
+		}		
+		IConsolePrintF(CC_WHITE, "joined n-ice (%i)", _settings_client.gui.community);
+	}
+	else if(strcmp(_settings_client.network.last_host, "83.137.149.29") == 0 
+		||  strcmp(_settings_client.network.last_host, "95.97.242.6") == 0
+		||  strcmp(_settings_client.network.last_host, "198.27.66.222") == 0
+		||  strcmp(_settings_client.network.last_host, "5.135.161.60") == 0
+		||  strcmp(_settings_client.network.last_host, "server.btpro.nl") == 0
+		||  strcmp(_settings_client.network.last_host, "server01.btpro.nl") == 0
+		||  strcmp(_settings_client.network.last_host, "server02.btpro.nl") == 0
+		||  strcmp(_settings_client.network.last_host, "server03.btpro.nl") == 0
+		||  strcmp(_settings_client.network.last_host, "2a01:1b0:7999:419::29") == 0
+		||  strcmp(_settings_client.network.last_host, "2001:41d0:8:e43c::") == 0
+		||  strcmp(_settings_client.network.last_host, "2607:5300:60:1bde::1") == 0
+		||  strstr(_settings_client.network.last_host, "btpro") != NULL)
+	{ //if n-ice chosen and BTPro IP, change to BTPro
+		if(_settings_client.gui.community != 2){
+			_settings_client.gui.community = 2;
+			GetCommunityServerListText();
+		}		
+		IConsolePrintF(CC_WHITE, "joined BTPro (%i)", _settings_client.gui.community);		
+	}
+	else { //not supported community
+		_settings_client.gui.community = 0;
+	}
+
 	NetworkDisconnect();
 	NetworkInitialize();
 
@@ -1173,4 +1428,66 @@ bool IsNetworkCompatibleVersion(const char *other)
 	return hash1 && hash2 && (strncmp(hash1, hash2, GITHASH_SUFFIX_LEN) == 0);
 }
 
+void GetCommunityServerListText(uint8 from){
+	if(_fromlast == _settings_client.gui.community || _settings_client.gui.community == 0) return;
+	_fromlast = _settings_client.gui.community;
+
+  _server_list_text.clear();
+
+  CommunityServerManagerSend();
+
+}
+
+bool GetCommunityServer(int number, bool findonly) {
+  //IConsolePrintF(CC_INFO, "Buf: %s", _server_list_text.c_str());
+	if(_server_list_text.empty()) return false;
+	_cc_address = NULL;
+
+	char server[32];
+	char port[16];
+
+	if(number < 10){
+		seprintf(server, lastof(server), "SERVER0%i", number);
+		seprintf(port, lastof(port), "PORT0%i", number);
+	}
+	else{
+		seprintf(server, lastof(server), "SERVER%i", number);
+		seprintf(port, lastof(port), "PORT%i", number);
+	}
+
+	size_t posaddress = _server_list_text.find(server);
+	size_t posport = _server_list_text.find(port);
+
+	if(posaddress != std::string::npos && posport != std::string::npos){
+		std::string saddress = _server_list_text.substr(posaddress + 10, _server_list_text.find(";", posaddress + 10) - posaddress - 10);
+		std::string sport = _server_list_text.substr(posport + 8, posport + 12);
+
+		//IConsolePrintF(CC_DEFAULT, "server: '%s'", saddress.c_str());
+		if(saddress.compare("DISABLED") == 0) return false;
+		else if(findonly) return true;
+
+		char sa[64];
+		strecpy(sa, saddress.c_str(), lastof(sa));
+		_cc_address = sa;
+		_cc_porti = atoi(sport.c_str());
+		return true;
+	}
+	else if(findonly) return false;
+	ShowErrorMessage(STR_CC_SERVER_LIST_ERROR_FILE, INVALID_STRING_ID, WL_ERROR);
+	return false;
+}
+
+void SetClipboardInfo(char *output) {
+  #ifdef WIN32
+    const size_t len = strlen(output) + 1;
+    HGLOBAL hMem =  GlobalAlloc(GMEM_MOVEABLE, len);
+    memcpy(GlobalLock(hMem), output, len);
+    GlobalUnlock(hMem);
+    OpenClipboard(0);
+    EmptyClipboard();
+    SetClipboardData(CF_TEXT, hMem);
+    CloseClipboard();
+  #endif
+}
+
 #endif /* ENABLE_NETWORK */
diff --git a/src/network/network.h b/src/network/network.h
index 26f94482e..233b14827 100644
--- a/src/network/network.h
+++ b/src/network/network.h
@@ -8,7 +8,7 @@
  */
 
 /** @file network.h Basic functions/variables used all over the place. */
-
+#include <iomanip>  //string
 #ifndef NETWORK_H
 #define NETWORK_H
 
@@ -20,12 +20,23 @@ void NetworkShutDown();
 void NetworkDrawChatMessage();
 bool HasClients();
 
+//void initiateLoginSequence();
+void CommunityLoginManagerSend();
+void CommunityServerManagerSend();
+
 extern bool _networking;         ///< are we in networking mode?
 extern bool _network_server;     ///< network-server is active
 extern bool _network_available;  ///< is network mode available?
 extern bool _network_dedicated;  ///< are we a dedicated server?
 extern bool _is_network_server;  ///< Does this client wants to be a network-server?
 
+extern std::string _server_list_text;  //string with servers status
+extern char* _cc_address; //current adddress
+extern int _cc_porti; //current port
+extern uint8 _fromlast;
+void GetCommunityServerListText(uint8 from = 0);
+bool GetCommunityServer(int number, bool findonly = false);
+
 #else /* ENABLE_NETWORK */
 /* Network function stubs when networking is disabled */
 
diff --git a/src/network/network_client.cpp b/src/network/network_client.cpp
index 62db6a555..57f8da829 100644
--- a/src/network/network_client.cpp
+++ b/src/network/network_client.cpp
@@ -630,6 +630,8 @@ NetworkRecvStatus ClientNetworkGameSocketHandler::Receive_SERVER_CLIENT_INFO(Pac
 		strecpy(ci->client_name, name, lastof(ci->client_name));
 
 		SetWindowDirty(WC_CLIENT_LIST, 0);
+		InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
+		SetWindowClassesDirty( WC_WATCH_COMPANY1 );
 
 		return NETWORK_RECV_STATUS_OKAY;
 	}
@@ -649,6 +651,8 @@ NetworkRecvStatus ClientNetworkGameSocketHandler::Receive_SERVER_CLIENT_INFO(Pac
 	strecpy(ci->client_name, name, lastof(ci->client_name));
 
 	SetWindowDirty(WC_CLIENT_LIST, 0);
+	InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
+	SetWindowClassesDirty( WC_WATCH_COMPANY1 );
 
 	return NETWORK_RECV_STATUS_OKAY;
 }
@@ -1022,6 +1026,8 @@ NetworkRecvStatus ClientNetworkGameSocketHandler::Receive_SERVER_ERROR_QUIT(Pack
 	}
 
 	SetWindowDirty(WC_CLIENT_LIST, 0);
+	InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
+	SetWindowClassesDirty( WC_WATCH_COMPANY1 );
 
 	return NETWORK_RECV_STATUS_OKAY;
 }
@@ -1041,6 +1047,8 @@ NetworkRecvStatus ClientNetworkGameSocketHandler::Receive_SERVER_QUIT(Packet *p)
 	}
 
 	SetWindowDirty(WC_CLIENT_LIST, 0);
+	InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
+	SetWindowClassesDirty( WC_WATCH_COMPANY1 );
 
 	/* If we come here it means we could not locate the client.. strange :s */
 	return NETWORK_RECV_STATUS_OKAY;
@@ -1058,6 +1066,8 @@ NetworkRecvStatus ClientNetworkGameSocketHandler::Receive_SERVER_JOIN(Packet *p)
 	}
 
 	SetWindowDirty(WC_CLIENT_LIST, 0);
+	InvalidateWindowClassesData( WC_WATCH_COMPANY1, 0 );
+	SetWindowClassesDirty( WC_WATCH_COMPANY1 );
 
 	return NETWORK_RECV_STATUS_OKAY;
 }
diff --git a/src/network/network_gui.cpp b/src/network/network_gui.cpp
index 93cd3d973..bcf1c9271 100644
--- a/src/network/network_gui.cpp
+++ b/src/network/network_gui.cpp
@@ -32,6 +32,7 @@
 #include "../genworld.h"
 #include "../map_type.h"
 #include "../guitimer_func.h"
+#include "../error.h"
 
 #include "../widgets/network_widget.h"
 
@@ -42,6 +43,9 @@
 
 #include "../safeguards.h"
 
+#include "../commands_token_gui.h"
+ 
+ClientID invitedid;
 
 static void ShowNetworkStartServerWindow();
 static void ShowNetworkLobbyWindow(NetworkGameList *ngl);
@@ -236,6 +240,7 @@ protected:
 	QueryString name_editbox;     ///< Client name editbox.
 	QueryString filter_editbox;   ///< Editbox for filter on servers
 	GUITimer requery_timer;       ///< Timer for network requery
+	bool UDP_CC_queried;
 
 	int lock_offset; ///< Left offset for lock icon.
 	int blot_offset; ///< Left offset for green/yellow/red compatibility icon.
@@ -476,6 +481,10 @@ public:
 
 		this->querystrings[WID_NG_FILTER] = &this->filter_editbox;
 		this->filter_editbox.cancel_button = QueryString::ACTION_CLEAR;
+		//if community is chosen, filter by default
+		this->UDP_CC_queried = false;
+		if(_settings_client.gui.community == 1) this->filter_editbox.text.Assign("n-ice");
+		else if(_settings_client.gui.community == 2) this->filter_editbox.text.Assign("BTPro");
 		this->SetFocusedWidget(WID_NG_FILTER);
 
 		this->last_joined = NetworkGameListAddItem(NetworkAddress(_settings_client.network.last_host, _settings_client.network.last_port));
@@ -786,6 +795,24 @@ public:
 			case WID_NG_NEWGRF_MISSING: // Find missing content online
 				if (this->server != NULL) ShowMissingContentWindow(this->server->info.grfconfig);
 				break;
+
+			case WID_NG_CC_NICE:
+			case WID_NG_CC_BTPRO:
+			case WID_NG_CC_REDDIT:
+			case WID_NG_CC_CITYMANIA:
+				if(!UDP_CC_queried){ 
+					NetworkUDPQueryMasterServer();
+					UDP_CC_queried = true;
+				}
+				if(widget == WID_NG_CC_NICE) this->filter_editbox.text.Assign("n-ice");
+				else if(widget == WID_NG_CC_BTPRO) this->filter_editbox.text.Assign("BTPro");
+				else if(widget == WID_NG_CC_REDDIT) this->filter_editbox.text.Assign("reddit");
+				else if(widget == WID_NG_CC_CITYMANIA) this->filter_editbox.text.Assign("CityMania");
+				this->servers.ForceRebuild();
+				this->BuildGUINetworkGameList();
+				this->ScrollToSelectedServer();
+				this->SetDirty();
+				break;
 		}
 	}
 
@@ -952,7 +979,12 @@ static const NWidgetPart _nested_network_game_widgets[] = {
 						NWidget(WWT_TEXT, COLOUR_LIGHT_BLUE, WID_NG_CONNECTION), SetDataTip(STR_NETWORK_SERVER_LIST_ADVERTISED, STR_NULL),
 						NWidget(WWT_DROPDOWN, COLOUR_LIGHT_BLUE, WID_NG_CONN_BTN),
 											SetDataTip(STR_BLACK_STRING, STR_NETWORK_SERVER_LIST_ADVERTISED_TOOLTIP),
-						NWidget(NWID_SPACER), SetFill(1, 0), SetResize(1, 0),
+						//NWidget(NWID_SPACER), SetFill(1, 0), SetResize(1, 0),
+						NWidget(NWID_SPACER), SetMinimalSize(20, 0),SetFill(1, 0), SetResize(1, 0),
+						NWidget(WWT_PUSHTXTBTN, COLOUR_WHITE, WID_NG_CC_REDDIT), SetFill(1, 0), SetDataTip(STR_NETWORK_CC_SELECT_REDDIT, STR_NETWORK_CC_SELECT_REDDIT_TOOLTIP),
+						NWidget(WWT_PUSHTXTBTN, COLOUR_WHITE, WID_NG_CC_CITYMANIA), SetFill(1, 0), SetDataTip(STR_NETWORK_CC_SELECT_CITYMANIA, STR_NETWORK_CC_SELECT_CITYMANIA_TOOLTIP),
+						NWidget(WWT_PUSHTXTBTN, COLOUR_WHITE, WID_NG_CC_NICE), SetFill(1, 0), SetDataTip(STR_NETWORK_CC_SELECT_NICE, STR_NETWORK_CC_SELECT_NICE_TOOLTIP),
+						NWidget(WWT_PUSHTXTBTN, COLOUR_WHITE, WID_NG_CC_BTPRO), SetFill(1, 0), SetDataTip(STR_NETWORK_CC_SELECT_BTPRO, STR_NETWORK_CC_SELECT_BTPRO_TOOLTIP),
 					EndContainer(),
 					NWidget(NWID_HORIZONTAL), SetPIP(0, 7, 0),
 						NWidget(WWT_TEXT, COLOUR_LIGHT_BLUE, WID_NG_FILTER_LABEL), SetDataTip(STR_LIST_FILTER_TITLE, STR_NULL),
@@ -1698,6 +1730,28 @@ static void ClientList_Ban(const NetworkClientInfo *ci)
 	NetworkServerKickOrBanIP(ci->client_id, true);
 }
 
+static void ClientList_Get_Token(const NetworkClientInfo *ci)
+{	//if community server, get token
+	 if (_settings_client.gui.community != 0) CommunityLoginManagerSend();
+}
+
+static void ClientListInviteYesCallback(Window *w, bool confirmed)
+{
+	if (confirmed) {
+		const NetworkClientInfo *ci = NetworkClientInfo::GetByClientID(invitedid);
+		char msg[128];
+		seprintf(msg, lastof(msg), "!invite %s", ci->client_name);
+		NetworkClientSendChat(NETWORK_ACTION_CHAT, DESTTYPE_BROADCAST, 0 , msg);
+	}
+}
+
+static void ClientList_Invite(const NetworkClientInfo *ci)
+{
+	invitedid = ci->client_id;
+	SetDParamStr(0, ci->client_name);
+	ShowQuery(STR_NETWORK_CLIENTLIST_INVITE_CAPTION, STR_NETWORK_CLIENTLIST_INVITE_QUESTION, NULL, ClientListInviteYesCallback);
+}
+
 static void ClientList_GiveMoney(const NetworkClientInfo *ci)
 {
 	ShowNetworkGiveMoneyWindow(ci->client_playas);
@@ -1767,6 +1821,14 @@ struct NetworkClientListPopupWindow : Window {
 				this->AddAction(STR_NETWORK_CLIENTLIST_GIVE_MONEY, &ClientList_GiveMoney);
 			}
 		}
+		if (_settings_client.gui.community != 0 && _network_own_client_id == ci->client_id) {
+			this->AddAction(STR_NETWORK_CLIENTLIST_GET_TOKEN, &ClientList_Get_Token);
+		}
+		if (_settings_client.gui.community != 0 && _network_own_client_id != ci->client_id
+			&& ci->client_id != CLIENT_ID_SERVER && Company::IsValidID(_local_company))
+		{
+			this->AddAction(STR_NETWORK_CLIENTLIST_INVITE, &ClientList_Invite);
+		}
 
 		/* A server can kick clients (but not himself). */
 		if (_network_server && _network_own_client_id != ci->client_id) {
diff --git a/src/order_cmd.cpp b/src/order_cmd.cpp
index dae6e58ad..20034ef7f 100644
--- a/src/order_cmd.cpp
+++ b/src/order_cmd.cpp
@@ -258,11 +258,13 @@ void InvalidateVehicleOrder(const Vehicle *v, int data)
 		/* Calls SetDirty() too */
 		InvalidateWindowData(WC_VEHICLE_ORDERS,    v->index, data);
 		InvalidateWindowData(WC_VEHICLE_TIMETABLE, v->index, data);
+		InvalidateWindowData(WC_VEHICLE_TRIP_HISTORY, v->index, data);
 		return;
 	}
 
 	SetWindowDirty(WC_VEHICLE_ORDERS,    v->index);
 	SetWindowDirty(WC_VEHICLE_TIMETABLE, v->index);
+	SetWindowDirty(WC_VEHICLE_TRIP_HISTORY, v->index);
 }
 
 /**
diff --git a/src/order_gui.cpp b/src/order_gui.cpp
index 81350deb7..f60423976 100644
--- a/src/order_gui.cpp
+++ b/src/order_gui.cpp
@@ -27,10 +27,12 @@
 #include "waypoint_base.h"
 #include "core/geometry_func.hpp"
 #include "hotkeys.h"
+#include "order_type.h"
 #include "aircraft.h"
 #include "engine_func.h"
 
 #include "widgets/order_widget.h"
+#include <math.h>
 
 #include "safeguards.h"
 
@@ -172,6 +174,78 @@ static const StringID _order_conditional_condition[] = {
 	INVALID_STRING_ID,
 };
 
+struct OrdersFromSettings
+{
+	enum OrderUnloadFlags unload;
+	enum OrderLoadFlags   load;
+};
+
+typedef enum {
+	GOFS_NONE = 0,
+	GOFS_FULL,
+	GOFS_XFER,
+	GOFS_UNLOAD,
+	GOFS_FEEDLOAD,
+	GOFS_FEEDUNLOAD,
+	GOFS_NOLOAD
+} GetOrderFromSettingsTypes;
+
+static enum {
+	GOFS_FEEDER_NULL,
+	GOFS_FEEDER_LOAD,
+	GOFS_FEEDER_UNLOAD
+} gofsfeeder_ordermod = GOFS_FEEDER_NULL;
+
+#define GOFSFEEDER_ORDERMOD_RESET gofsfeeder_ordermod = GOFS_FEEDER_NULL
+
+
+/* fetch and compute orders set from settings */
+
+static void GetOrdersFromSettings(const Vehicle *v, uint8 setting, struct OrdersFromSettings *rv)
+{
+	rv->load = (enum OrderLoadFlags)-1;
+	rv->unload = (enum OrderUnloadFlags)-1;
+
+	switch(setting) {
+
+	case GOFS_FEEDLOAD:
+		if (v->GetNumOrders()) gofsfeeder_ordermod = GOFS_FEEDER_LOAD;
+		rv->unload = OUFB_NO_UNLOAD;
+		rv->load = OLF_FULL_LOAD_ANY;
+		break;
+	case GOFS_FULL:
+		rv->load = OLF_FULL_LOAD_ANY;
+		break;
+
+	case GOFS_UNLOAD:
+		rv->unload = OUFB_UNLOAD;
+		if (_settings_client.gui.auto_noload_on_unloadall)
+			rv->load = OLFB_NO_LOAD;
+		break;
+
+	case GOFS_FEEDUNLOAD:
+		if (v->GetNumOrders()) gofsfeeder_ordermod = GOFS_FEEDER_UNLOAD;
+		rv->unload = OUFB_TRANSFER;
+		rv->load = OLFB_NO_LOAD;
+		break;
+
+	case GOFS_XFER:
+		rv->unload = OUFB_TRANSFER;
+		if (_settings_client.gui.auto_noload_on_transfer)
+			rv->load = OLFB_NO_LOAD;
+		break;
+
+	case GOFS_NOLOAD:
+		rv->load = OLFB_NO_LOAD;
+		break;
+
+	case GOFS_NONE:
+		break;
+
+	default: NOT_REACHED();
+	}
+}
+
 extern uint ConvertSpeedToDisplaySpeed(uint speed);
 extern uint ConvertDisplaySpeedToSpeed(uint speed);
 
@@ -347,6 +421,19 @@ void DrawOrderString(const Vehicle *v, const Order *order, int order_index, int
 	}
 
 	DrawString(rtl ? left : middle, rtl ? middle : right, y, STR_ORDER_TEXT, colour);
+
+  uint order_dist_sq = 0;
+	uint order_dist_mh = 0;
+	const Order *next2 = order->next != NULL ? order->next : v->GetFirstOrder();
+	TileIndex prev_tile = order->GetLocation(v, true);
+	TileIndex cur_tile = next2->GetLocation(v, true);
+	if (prev_tile != INVALID_TILE && cur_tile != INVALID_TILE){
+		order_dist_sq = (uint)sqrt((double)(DistanceSquare(prev_tile, cur_tile)));
+		order_dist_mh = DistanceManhattan(prev_tile, cur_tile);
+	}
+	SetDParam(0, order_dist_sq);
+	SetDParam(1, order_dist_mh);
+	DrawString(middle, right, y, STR_ORDER_DIST, TC_WHITE, SA_RIGHT);
 }
 
 /**
@@ -401,8 +488,33 @@ static Order GetOrderCmdFromTile(const Vehicle *v, TileIndex tile)
 			(facil = FACIL_BUS_STOP, v->type == VEH_ROAD && RoadVehicle::From(v)->IsBus()) ||
 			(facil = FACIL_TRUCK_STOP, 1);
 			if (st->facilities & facil) {
+        uint8 os = 0xff;
 				order.MakeGoToStation(st_index);
-				if (_ctrl_pressed) order.SetLoadType(OLF_FULL_LOAD_ANY);
+				if (_ctrl_pressed) {
+					if (_shift_pressed)
+						os = _settings_client.gui.goto_shortcuts_ctrlshift_lclick;
+					else if (_alt_pressed)
+						os = _settings_client.gui.goto_shortcuts_altctrl_lclick;
+					else
+						os = _settings_client.gui.goto_shortcuts_ctrl_lclick;
+				}
+				else if (_shift_pressed) {
+					if (_alt_pressed)
+						os = _settings_client.gui.goto_shortcuts_altshift_lclick;
+					else
+						os = _settings_client.gui.goto_shortcuts_shift_lclick;
+				}
+				else if (_alt_pressed)
+					os = _settings_client.gui.goto_shortcuts_alt_lclick;
+
+				if (os != 0xff) {
+					struct OrdersFromSettings ofs;
+					GetOrdersFromSettings(v, os, &ofs);
+					if (ofs.load != (enum OrderLoadFlags)-1)
+						order.SetLoadType(ofs.load);
+					if (ofs.unload != (enum OrderUnloadFlags)-1)
+					order.SetUnloadType(ofs.unload);
+				}
 				if (_settings_client.gui.new_nonstop && v->IsGroundVehicle()) order.SetNonStopType(ONSF_NO_STOP_AT_INTERMEDIATE_STATIONS);
 				order.SetStopLocation(v->type == VEH_TRAIN ? (OrderStopLocation)(_settings_client.gui.stop_location) : OSL_PLATFORM_FAR_END);
 				return order;
@@ -428,6 +540,7 @@ enum {
 	OHK_TRANSFER,
 	OHK_NO_UNLOAD,
 	OHK_NO_LOAD,
+	OHK_CLOSE,
 };
 
 /**
@@ -636,8 +749,14 @@ private:
 
 		DoCommandP(this->vehicle->tile, this->vehicle->index + (sel_ord << 20), MOF_UNLOAD | (unload_type << 4), CMD_MODIFY_ORDER | CMD_MSG(STR_ERROR_CAN_T_MODIFY_THIS_ORDER));
 
+    bool set_no_load = false;
+		if (unload_type == OUFB_TRANSFER)
+			set_no_load = _settings_client.gui.auto_noload_on_transfer;
+		else if (unload_type == OUFB_UNLOAD)
+			set_no_load = _settings_client.gui.auto_noload_on_unloadall;
+
 		/* Transfer orders with leave empty as default */
-		if (unload_type == OUFB_TRANSFER) {
+		if (set_no_load) {
 			DoCommandP(this->vehicle->tile, this->vehicle->index + (sel_ord << 20), MOF_LOAD | (OLFB_NO_LOAD << 4), CMD_MODIFY_ORDER);
 			this->SetWidgetDirty(WID_O_FULL_LOAD);
 		}
@@ -1424,6 +1543,11 @@ public:
 	virtual EventState OnHotkey(int hotkey)
 	{
 		if (this->vehicle->owner != _local_company) return ES_NOT_HANDLED;
+		if(hotkey == OHK_GOTO && this->goto_type != OPOS_NONE){
+			this->RaiseWidget(WID_O_GOTO);
+			ResetObjectToPlace();
+			return ES_NOT_HANDLED;
+		}
 
 		switch (hotkey) {
 			case OHK_SKIP:           this->OrderClick_Skip();          break;
@@ -1437,6 +1561,7 @@ public:
 			case OHK_TRANSFER:       this->OrderHotkey_Transfer();     break;
 			case OHK_NO_UNLOAD:      this->OrderHotkey_NoUnload();     break;
 			case OHK_NO_LOAD:        this->OrderHotkey_NoLoad();       break;
+			case OHK_CLOSE:          delete this; break;
 			default: return ES_NOT_HANDLED;
 		}
 		return ES_HANDLED;
@@ -1448,7 +1573,21 @@ public:
 			const Order cmd = GetOrderCmdFromTile(this->vehicle, tile);
 			if (cmd.IsType(OT_NOTHING)) return;
 
-			if (DoCommandP(this->vehicle->tile, this->vehicle->index + (this->OrderGetSel() << 20), cmd.Pack(), CMD_INSERT_ORDER | CMD_MSG(STR_ERROR_CAN_T_INSERT_NEW_ORDER))) {
+			if (gofsfeeder_ordermod != GOFS_FEEDER_NULL) {
+				if (gofsfeeder_ordermod == GOFS_FEEDER_LOAD) {
+					if (DoCommandP(this->vehicle->tile, this->vehicle->index + ((1) << 20), cmd.Pack(), CMD_INSERT_ORDER | CMD_MSG(STR_ERROR_CAN_T_INSERT_NEW_ORDER))) {
+						DoCommandP(this->vehicle->tile, this->vehicle->index,  0, CMD_DELETE_ORDER | CMD_MSG(STR_ERROR_CAN_T_DELETE_THIS_ORDER));
+					}
+
+				}
+				else if (gofsfeeder_ordermod == GOFS_FEEDER_UNLOAD) { // still flushes the whole order table
+					if (DoCommandP(this->vehicle->tile, this->vehicle->index + ((this->vehicle->GetNumOrders()) << 20), cmd.Pack(), CMD_INSERT_ORDER | CMD_MSG(STR_ERROR_CAN_T_INSERT_NEW_ORDER))) {
+						DoCommandP(this->vehicle->tile, this->vehicle->index, (this->vehicle->GetNumOrders()-2+(int)_networking) , CMD_DELETE_ORDER | CMD_MSG(STR_ERROR_CAN_T_DELETE_THIS_ORDER));
+					}
+				}
+				gofsfeeder_ordermod = GOFS_FEEDER_NULL;
+			}
+			else if (DoCommandP(this->vehicle->tile, this->vehicle->index + (this->OrderGetSel() << 20), cmd.Pack(), CMD_INSERT_ORDER | CMD_MSG(STR_ERROR_CAN_T_INSERT_NEW_ORDER))) {
 				/* With quick goto the Go To button stays active */
 				if (!_settings_client.gui.quick_goto) ResetObjectToPlace();
 			}
@@ -1526,6 +1665,7 @@ static Hotkey order_hotkeys[] = {
 	Hotkey((uint16)0, "transfer", OHK_TRANSFER),
 	Hotkey((uint16)0, "no_unload", OHK_NO_UNLOAD),
 	Hotkey((uint16)0, "no_load", OHK_NO_LOAD),
+	Hotkey('Q', "close", OHK_CLOSE),
 	HOTKEY_LIST_END
 };
 HotkeyList OrdersWindow::hotkeys("order", order_hotkeys);
diff --git a/src/rail_cmd.cpp b/src/rail_cmd.cpp
index ef1137e29..3deec1e2c 100644
--- a/src/rail_cmd.cpp
+++ b/src/rail_cmd.cpp
@@ -47,6 +47,7 @@ RailtypeInfo _railtypes[RAILTYPE_END];
 RailType _sorted_railtypes[RAILTYPE_END];
 uint8 _sorted_railtypes_size;
 RailTypes _railtypes_hidden_mask;
+TileIndex _rail_track_endtile; ///< The end of a rail track; as hidden return from the rail build/remove command for GUI purposes.
 
 /** Enum holding the signal offset in the sprite sheet according to the side it is representing. */
 enum SignalOffsets {
@@ -595,6 +596,7 @@ CommandCost CmdBuildSingleRail(TileIndex tile, DoCommandFlag flags, uint32 p1, u
 	}
 
 	cost.AddCost(RailBuildCost(railtype));
+	_rail_track_endtile = tile;
 	return cost;
 }
 
@@ -739,6 +741,7 @@ CommandCost CmdRemoveSingleRail(TileIndex tile, DoCommandFlag flags, uint32 p1,
 		if (v != NULL) TryPathReserve(v, true);
 	}
 
+	_rail_track_endtile = tile;
 	return cost;
 }
 
@@ -2573,6 +2576,8 @@ static void TileLoop_Track(TileIndex tile)
 	RailGroundType old_ground = GetRailGroundType(tile);
 	RailGroundType new_ground;
 
+	ReduceStuckCounter(tile);
+
 	if (old_ground == RAIL_GROUND_WATER) {
 		TileLoop_Water(tile);
 		return;
diff --git a/src/rail_gui.cpp b/src/rail_gui.cpp
index 234edbf22..940e36e6a 100644
--- a/src/rail_gui.cpp
+++ b/src/rail_gui.cpp
@@ -52,6 +52,8 @@ static bool _convert_signal_button;          ///< convert signal button in the s
 static SignalVariant _cur_signal_variant;    ///< set the signal variant (for signal GUI)
 static SignalType _cur_signal_type;          ///< set the signal type (for signal GUI)
 
+extern TileIndex _rail_track_endtile; // rail_cmd.cpp
+
 /* Map the setting: default_signal_type to the corresponding signal type */
 static const SignalType _default_signal_type[] = {SIGTYPE_NORMAL, SIGTYPE_PBS, SIGTYPE_PBS_ONEWAY};
 
@@ -91,9 +93,9 @@ void CcPlaySound_SPLAT_RAIL(const CommandCost &result, TileIndex tile, uint32 p1
 	if (result.Succeeded() && _settings_client.sound.confirm) SndPlayTileFx(SND_20_SPLAT_RAIL, tile);
 }
 
-static void GenericPlaceRail(TileIndex tile, int cmd)
+static bool GenericPlaceRail(TileIndex tile, Track track)
 {
-	DoCommandP(tile, _cur_railtype, cmd,
+	return DoCommandP(tile, _cur_railtype, track,
 			_remove_button_clicked ?
 			CMD_REMOVE_SINGLE_RAIL | CMD_MSG(STR_ERROR_CAN_T_REMOVE_RAILROAD_TRACK) :
 			CMD_BUILD_SINGLE_RAIL | CMD_MSG(STR_ERROR_CAN_T_BUILD_RAILROAD_TRACK),
@@ -277,6 +279,7 @@ void CcBuildRailTunnel(const CommandCost &result, TileIndex tile, uint32 p1, uin
 	if (result.Succeeded()) {
 		if (_settings_client.sound.confirm) SndPlayTileFx(SND_20_SPLAT_RAIL, tile);
 		if (!_settings_client.gui.persistent_buildingtools) ResetObjectToPlace();
+		StoreRailPlacementEndpoints(tile, _build_tunnel_endtile, TileX(tile) == TileX(_build_tunnel_endtile) ? TRACK_Y : TRACK_X, false);
 	} else {
 		SetRedErrorSquare(_build_tunnel_endtile);
 	}
@@ -306,7 +309,7 @@ static bool RailToolbar_CtrlChanged(Window *w)
 
 	/* allow ctrl to switch remove mode only for these widgets */
 	for (uint i = WID_RAT_BUILD_NS; i <= WID_RAT_BUILD_STATION; i++) {
-		if ((i <= WID_RAT_AUTORAIL || i >= WID_RAT_BUILD_WAYPOINT) && w->IsWidgetLowered(i)) {
+		if ((i <= WID_RAT_POLYRAIL || i >= WID_RAT_BUILD_WAYPOINT) && w->IsWidgetLowered(i)) {
 			ToggleRailButton_Remove(w);
 			return true;
 		}
@@ -350,9 +353,9 @@ static void BuildRailClick_Remove(Window *w)
 	}
 }
 
-static void DoRailroadTrack(int mode)
+static bool DoRailroadTrack(TileIndex start_tile, TileIndex end_tile, Track track)
 {
-	DoCommandP(TileVirtXY(_thd.selstart.x, _thd.selstart.y), TileVirtXY(_thd.selend.x, _thd.selend.y), _cur_railtype | (mode << 6),
+	return DoCommandP(start_tile, end_tile, _cur_railtype | (track << 6),
 			_remove_button_clicked ?
 			CMD_REMOVE_RAILROAD_TRACK | CMD_MSG(STR_ERROR_CAN_T_REMOVE_RAILROAD_TRACK) :
 			CMD_BUILD_RAILROAD_TRACK  | CMD_MSG(STR_ERROR_CAN_T_BUILD_RAILROAD_TRACK),
@@ -361,14 +364,14 @@ static void DoRailroadTrack(int mode)
 
 static void HandleAutodirPlacement()
 {
-	int trackstat = _thd.drawstyle & HT_DIR_MASK; // 0..5
+	Track track = (Track)(_thd.drawstyle & HT_DIR_MASK); // 0..5
+	TileIndex start_tile = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
+	TileIndex end_tile = TileVirtXY(_thd.selend.x, _thd.selend.y);
 
-	if (_thd.drawstyle & HT_RAIL) { // one tile case
-		GenericPlaceRail(TileVirtXY(_thd.selend.x, _thd.selend.y), trackstat);
-		return;
+	if ((_thd.drawstyle & HT_RAIL ? GenericPlaceRail(end_tile, track) : DoRailroadTrack(start_tile, end_tile, track))
+			&& !_shift_pressed) {
+		StoreRailPlacementEndpoints(start_tile, _rail_track_endtile, track, true);
 	}
-
-	DoRailroadTrack(trackstat);
 }
 
 /**
@@ -415,6 +418,73 @@ static void HandleAutoSignalPlacement()
 }
 
 
+// FIXME duplicate from road_gui.cpp
+static DiagDirection TileFractCoordsToDiagDir() {
+	bool diag = (_tile_fract_coords.x + _tile_fract_coords.y) < 16;
+	if (_tile_fract_coords.x < _tile_fract_coords.y) {
+		return diag ? DIAGDIR_NE : DIAGDIR_SE;
+	}
+	return diag ? DIAGDIR_NW : DIAGDIR_SW;
+}
+
+// FIXME duplicate from road_gui.cpp
+static DiagDirection RoadBitsToDiagDir(RoadBits bits) {
+	if (bits < ROAD_SE) {
+		return bits == ROAD_NW ? DIAGDIR_NW : DIAGDIR_SW;
+	}
+	return bits == ROAD_SE ? DIAGDIR_SE : DIAGDIR_NE;
+}
+
+RoadBits FindRailsToConnect(TileIndex tile) {
+	RoadBits directed = ROAD_NONE;
+	RoadBits passing = ROAD_NONE;
+	DiagDirection ddir;
+	for (ddir = DIAGDIR_BEGIN; ddir < DIAGDIR_END; ddir++) {
+		TileIndex cur_tile = TileAddByDiagDir(tile, ddir);
+		if (HasStationTileRail(cur_tile)) {
+			if (GetRailStationTrackBits(cur_tile) & DiagdirReachesTracks(ddir)) {
+				directed |= DiagDirToRoadBits(ddir);
+			}
+			continue;
+		}
+		if (!IsTileType(cur_tile, MP_RAILWAY)) continue;
+		if (!IsPlainRail(cur_tile)) continue;
+		passing |= DiagDirToRoadBits(ddir);
+		if (GetTrackBits(cur_tile) & DiagdirReachesTracks(ddir)) {
+			directed |= DiagDirToRoadBits(ddir);
+		}
+	}
+	// Prioritize track bits that head in this direction
+	if (directed != ROAD_NONE) {
+		return directed;
+	}
+	return passing;
+}
+
+/*
+ * Selects orientation for rail object (depot)
+ */
+static DiagDirection AutodetectRailObjectDirection(TileIndex tile) {
+	RoadBits bits = FindRailsToConnect(tile);
+	// FIXME after this point repeats road autodetection
+	if (HasExactlyOneBit(bits)) return RoadBitsToDiagDir(bits);
+	if (bits == ROAD_NONE) bits = ROAD_ALL;
+	RoadBits frac_bits = DiagDirToRoadBits(TileFractCoordsToDiagDir());
+	if (HasExactlyOneBit(frac_bits & bits)) {
+		return RoadBitsToDiagDir(frac_bits & bits);
+	}
+	frac_bits |= MirrorRoadBits(frac_bits);
+	if (HasExactlyOneBit(frac_bits & bits)) {
+		return RoadBitsToDiagDir(frac_bits & bits);
+	}
+	for (DiagDirection ddir = DIAGDIR_BEGIN; ddir < DIAGDIR_END; ddir++) {
+		if (DiagDirToRoadBits(ddir) & bits) {
+			return ddir;
+		}
+	}
+	NOT_REACHED();
+}
+
 /** Rail toolbar management class. */
 struct BuildRailToolbarWindow : Window {
 	RailType railtype;    ///< Rail type to build.
@@ -462,6 +532,7 @@ struct BuildRailToolbarWindow : Window {
 		this->GetWidget<NWidgetCore>(WID_RAT_BUILD_EW)->widget_data     = rti->gui_sprites.build_ew_rail;
 		this->GetWidget<NWidgetCore>(WID_RAT_BUILD_Y)->widget_data      = rti->gui_sprites.build_y_rail;
 		this->GetWidget<NWidgetCore>(WID_RAT_AUTORAIL)->widget_data     = rti->gui_sprites.auto_rail;
+		this->GetWidget<NWidgetCore>(WID_RAT_POLYRAIL)->widget_data     = rti->gui_sprites.auto_rail;
 		this->GetWidget<NWidgetCore>(WID_RAT_BUILD_DEPOT)->widget_data  = rti->gui_sprites.build_depot;
 		this->GetWidget<NWidgetCore>(WID_RAT_CONVERT_RAIL)->widget_data = rti->gui_sprites.convert_rail;
 		this->GetWidget<NWidgetCore>(WID_RAT_BUILD_TUNNEL)->widget_data = rti->gui_sprites.build_tunnel;
@@ -490,6 +561,7 @@ struct BuildRailToolbarWindow : Window {
 			case WID_RAT_BUILD_EW:
 			case WID_RAT_BUILD_Y:
 			case WID_RAT_AUTORAIL:
+			case WID_RAT_POLYRAIL:
 			case WID_RAT_BUILD_WAYPOINT:
 			case WID_RAT_BUILD_STATION:
 			case WID_RAT_BUILD_SIGNALS:
@@ -521,6 +593,15 @@ struct BuildRailToolbarWindow : Window {
 		}
 	}
 
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		if (widget == WID_RAT_POLYRAIL) {
+			Dimension d = GetSpriteSize(SPR_BLOT);
+			uint offset = this->IsWidgetLowered(WID_RAT_POLYRAIL) ? 1 : 0;
+			DrawSprite(SPR_BLOT, PALETTE_TO_GREY, (r.left + r.right - d.width) / 2 + offset, (r.top + r.bottom - d.height) / 2 + offset);
+		}
+	}
+
 	virtual void OnClick(Point pt, int widget, int click_count)
 	{
 		if (widget < WID_RAT_BUILD_NS) return;
@@ -552,6 +633,11 @@ struct BuildRailToolbarWindow : Window {
 				this->last_user_action = widget;
 				break;
 
+			case WID_RAT_POLYRAIL:
+				HandlePlacePushButton(this, WID_RAT_POLYRAIL, GetRailTypeInfo(railtype)->cursor.autorail, HT_RAIL | HT_POLY);
+				this->last_user_action = widget;
+				break;
+
 			case WID_RAT_DEMOLISH:
 				HandlePlacePushButton(this, WID_RAT_DEMOLISH, ANIMCURSOR_DEMOLISH, HT_RECT | HT_DIAGONAL);
 				this->last_user_action = widget;
@@ -621,6 +707,7 @@ struct BuildRailToolbarWindow : Window {
 
 	virtual void OnPlaceObject(Point pt, TileIndex tile)
 	{
+    DiagDirection ddir;
 		switch (this->last_user_action) {
 			case WID_RAT_BUILD_NS:
 				VpStartPlaceSizing(tile, VPM_FIX_VERTICAL | VPM_RAILDIRS, DDSP_PLACE_RAIL);
@@ -639,6 +726,7 @@ struct BuildRailToolbarWindow : Window {
 				break;
 
 			case WID_RAT_AUTORAIL:
+			case WID_RAT_POLYRAIL:
 				VpStartPlaceSizing(tile, VPM_RAILDIRS, DDSP_PLACE_RAIL);
 				break;
 
@@ -647,7 +735,11 @@ struct BuildRailToolbarWindow : Window {
 				break;
 
 			case WID_RAT_BUILD_DEPOT:
-				DoCommandP(tile, _cur_railtype, _build_depot_direction,
+				ddir = _build_depot_direction;
+				if (ddir == DIAGDIR_NW + 1) {
+					ddir = AutodetectRailObjectDirection(tile);
+				}
+				DoCommandP(tile, _cur_railtype, ddir,
 						CMD_BUILD_TRAIN_DEPOT | CMD_MSG(STR_ERROR_CAN_T_BUILD_TRAIN_DEPOT),
 						CcRailDepot);
 				break;
@@ -786,6 +878,7 @@ static EventState RailToolbarGlobalHotkeys(int hotkey)
 }
 
 const uint16 _railtoolbar_autorail_keys[] = {'5', 'A' | WKC_GLOBAL_HOTKEY, 0};
+const uint16 _railtoolbar_polyrail_keys[] = {'5' | WKC_CTRL, 'A' | WKC_GLOBAL_HOTKEY | WKC_CTRL, 0};
 
 static Hotkey railtoolbar_hotkeys[] = {
 	Hotkey('1', "build_ns", WID_RAT_BUILD_NS),
@@ -793,6 +886,7 @@ static Hotkey railtoolbar_hotkeys[] = {
 	Hotkey('3', "build_ew", WID_RAT_BUILD_EW),
 	Hotkey('4', "build_y", WID_RAT_BUILD_Y),
 	Hotkey(_railtoolbar_autorail_keys, "autorail", WID_RAT_AUTORAIL),
+	Hotkey(_railtoolbar_polyrail_keys, "polyrail", WID_RAT_POLYRAIL),
 	Hotkey('6', "demolish", WID_RAT_DEMOLISH),
 	Hotkey('7', "depot", WID_RAT_BUILD_DEPOT),
 	Hotkey('8', "waypoint", WID_RAT_BUILD_WAYPOINT),
@@ -823,6 +917,8 @@ static const NWidgetPart _nested_build_rail_widgets[] = {
 						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_RAIL_NW, STR_RAIL_TOOLBAR_TOOLTIP_BUILD_RAILROAD_TRACK),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_RAT_AUTORAIL),
 						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_AUTORAIL, STR_RAIL_TOOLBAR_TOOLTIP_BUILD_AUTORAIL),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_RAT_POLYRAIL),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_AUTORAIL, STR_RAIL_TOOLBAR_TOOLTIP_BUILD_POLYRAIL),
 
 		NWidget(WWT_PANEL, COLOUR_DARK_GREEN), SetMinimalSize(4, 22), SetDataTip(0x0, STR_NULL), EndContainer(),
 
@@ -1724,6 +1820,7 @@ struct BuildRailDepotWindow : public PickerWindowBase {
 			case WID_BRAD_DEPOT_SE:
 			case WID_BRAD_DEPOT_SW:
 			case WID_BRAD_DEPOT_NW:
+			case WID_BRAD_DEPOT_AUTO:
 				this->RaiseWidget(_build_depot_direction + WID_BRAD_DEPOT_NE);
 				_build_depot_direction = (DiagDirection)(widget - WID_BRAD_DEPOT_NE);
 				this->LowerWidget(_build_depot_direction + WID_BRAD_DEPOT_NE);
@@ -1761,6 +1858,9 @@ static const NWidgetPart _nested_build_depot_widgets[] = {
 			EndContainer(),
 			NWidget(NWID_SPACER), SetMinimalSize(3, 0), SetFill(1, 0),
 		EndContainer(),
+		NWidget(NWID_HORIZONTAL), SetPIP(2, 2, 2),
+			NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_BRAD_DEPOT_AUTO), SetMinimalSize(134, 12), SetDataTip(STR_STATION_BUILD_ORIENTATION_AUTO, STR_BUILD_DEPOT_TRAIN_ORIENTATION_AUTO_TOOLTIP),
+		EndContainer(),
 		NWidget(NWID_SPACER), SetMinimalSize(0, 3),
 	EndContainer(),
 };
@@ -1881,7 +1981,7 @@ static void ShowBuildWaypointPicker(Window *parent)
  */
 void InitializeRailGui()
 {
-	_build_depot_direction = DIAGDIR_NW;
+	_build_depot_direction = (DiagDirection)(DIAGDIR_NW + 1);
 }
 
 /**
diff --git a/src/rail_map.h b/src/rail_map.h
index 74afe5ace..9c08343c7 100644
--- a/src/rail_map.h
+++ b/src/rail_map.h
@@ -479,6 +479,24 @@ static inline bool HasOnewaySignalBlockingTrackdir(TileIndex tile, Trackdir td)
 			!HasSignalOnTrackdir(tile, td) && IsOnewaySignal(tile, TrackdirToTrack(td));
 }
 
+static inline void IncreaseStuckCounter(TileIndex t)
+{
+	if (!IsTileType(t, MP_RAILWAY)) return;
+	if (_me[t].m7 < MAX_UVALUE(byte)) _me[t].m7++;
+}
+
+static inline void ReduceStuckCounter(TileIndex t)
+{
+	if (!IsTileType(t, MP_RAILWAY)) return;
+	_me[t].m7 -= (uint)(_me[t].m7 + 3) / 4;
+}
+
+static inline byte GetStuckCounter(TileIndex t)
+{
+	if (!IsTileType(t, MP_RAILWAY)) return 0;
+	return _me[t].m7;
+}
+
 
 RailType GetTileRailType(TileIndex tile);
 
diff --git a/src/rev.cpp.in b/src/rev.cpp.in
index 0fb8db7aa..f15e0a26c 100644
--- a/src/rev.cpp.in
+++ b/src/rev.cpp.in
@@ -37,7 +37,7 @@ bool IsReleasedVersion()
  *
  * <modified> shows a "M", if the binary is made from modified source code.
  */
-const char _openttd_revision[] = "!!VERSION!!";
+const char _openttd_revision[] = "1.9.2";
 
 /**
  * The text version of OpenTTD's build date.
@@ -50,7 +50,7 @@ const char _openttd_build_date[] = __DATE__ " " __TIME__;
 /**
  * The git revision hash of this version.
  */
-const char _openttd_revision_hash[] = "!!GITHASH!!";
+const char _openttd_revision_hash[] = "a82f21f24df9f42aea38af9fb48da553b30432f4";
 
 /**
  * Let us know if current build was modified. This detection
@@ -60,14 +60,14 @@ const char _openttd_revision_hash[] = "!!GITHASH!!";
  * (compiling from sources without any version control software)
  * and 2 is for modified revision.
  */
-const byte _openttd_revision_modified = !!MODIFIED!!;
+const byte _openttd_revision_modified = 0;
 
 /**
  * Indicate whether this is a tagged version.
  * If this is non-0, then _openttd_revision is the name of the tag,
  * and the version is likely a beta, release candidate, or real release.
  */
-const byte _openttd_revision_tagged = !!ISTAG!!;
+const byte _openttd_revision_tagged = 1;
 
 /**
  * The NewGRF revision of OTTD:
@@ -82,11 +82,11 @@ const byte _openttd_revision_tagged = !!ISTAG!!;
  * final release will always have a lower version number than the released
  * version, thus making comparisons on specific revisions easy.
  */
-const uint32 _openttd_newgrf_version = 1 << 28 | 9 << 24 | 2 << 20 | !!ISSTABLETAG!! << 19 | 28004;
+const uint32 _openttd_newgrf_version = 1 << 28 | 9 << 24 | 2 << 20 | 1 << 19 | 28004;
 
 #ifdef __MORPHOS__
 /**
  * Variable used by MorphOS to show the version.
  */
-extern const char morphos_versions_tag[] = "$VER: OpenTTD !!VERSION!! (!!DATE!!) OpenTTD Team [MorphOS, PowerPC]";
+extern const char morphos_versions_tag[] = "$VER: OpenTTD 1.9.2 (8.7.2019) OpenTTD Team [MorphOS, PowerPC]";
 #endif
diff --git a/src/road_gui.cpp b/src/road_gui.cpp
index e3091ec8a..979eb3861 100644
--- a/src/road_gui.cpp
+++ b/src/road_gui.cpp
@@ -211,6 +211,106 @@ void CcRoadStop(const CommandCost &result, TileIndex tile, uint32 p1, uint32 p2)
 	}
 }
 
+static RoadBits FindRoadsToConnect(TileIndex tile) {
+	RoadBits bits = ROAD_NONE;
+	DiagDirection ddir;
+	// Prioritize roadbits that head in this direction
+	for (ddir = DIAGDIR_BEGIN; ddir < DIAGDIR_END; ddir++) {
+		TileIndex cur_tile = TileAddByDiagDir(tile, ddir);
+		if (GetAnyRoadBits(cur_tile, ROADTYPE_ROAD, true) &
+			DiagDirToRoadBits(ReverseDiagDir(ddir)))
+		{
+			bits |= DiagDirToRoadBits(ddir);
+		}
+	}
+	if (bits != ROAD_NONE) {
+		return bits;
+	}
+	// Try to connect to any road passing by
+	for (ddir = DIAGDIR_BEGIN; ddir < DIAGDIR_END; ddir++) {
+		TileIndex cur_tile = TileAddByDiagDir(tile, ddir);
+		if (HasTileRoadType(cur_tile, ROADTYPE_ROAD) && (GetTileType(cur_tile) == MP_ROAD) &&
+				(GetRoadTileType(cur_tile) == ROAD_TILE_NORMAL)) {
+			bits |= DiagDirToRoadBits(ddir);
+		}
+	}
+	return bits;
+}
+
+static DiagDirection RoadBitsToDiagDir(RoadBits bits) {
+	if (bits < ROAD_SE) {
+		return bits == ROAD_NW ? DIAGDIR_NW : DIAGDIR_SW;
+	}
+	return bits == ROAD_SE ? DIAGDIR_SE : DIAGDIR_NE;
+}
+
+static DiagDirection TileFractCoordsToDiagDir() {
+	bool diag = (_tile_fract_coords.x + _tile_fract_coords.y) < 16;
+	if (_tile_fract_coords.x < _tile_fract_coords.y) {
+		return diag ? DIAGDIR_NE : DIAGDIR_SE;
+	}
+	return diag ? DIAGDIR_NW : DIAGDIR_SW;
+}
+/*
+ * Selects orientation for road object (depot, terminal station)
+ */
+static DiagDirection AutodetectRoadObjectDirection(TileIndex tile) {
+	RoadBits bits = FindRoadsToConnect(tile);
+	if (HasExactlyOneBit(bits)) {
+		return RoadBitsToDiagDir(bits);
+	}
+	if (bits == ROAD_NONE){
+		bits = ROAD_ALL;
+	}
+	RoadBits frac_bits = DiagDirToRoadBits(TileFractCoordsToDiagDir());
+	if (HasExactlyOneBit(frac_bits & bits)) {
+		return RoadBitsToDiagDir(frac_bits & bits);
+	}
+	frac_bits |= MirrorRoadBits(frac_bits);
+	if (HasExactlyOneBit(frac_bits & bits)) {
+		return RoadBitsToDiagDir(frac_bits & bits);
+	}
+	for (DiagDirection ddir = DIAGDIR_BEGIN; ddir < DIAGDIR_END; ddir++) {
+		if (DiagDirToRoadBits(ddir) & bits) {
+			return ddir;
+		}
+	}
+	NOT_REACHED();
+}
+
+static bool CheckDriveThroughRoadStopDirection(TileArea area, RoadBits r) {
+	TILE_AREA_LOOP(tile, area) {
+		if (!HasTileRoadType(tile, ROADTYPE_ROAD)) continue;
+		if (GetTileType(tile) != MP_ROAD) continue;
+		if (GetRoadTileType(tile) != ROAD_TILE_NORMAL) continue;
+		if (GetRoadBits(tile, ROADTYPE_ROAD) & ~r) return false;
+	}
+	return true;
+}
+
+
+/*
+ * Automaticaly selects direction to use for road stop.
+ * @param area road stop area
+ * @return selected direction
+ */
+static DiagDirection AutodetectDriveThroughRoadStopDirection(TileArea area) {
+	bool se_suits, ne_suits;
+
+	// Check which direction is available
+	// If both are not use SE, building will fail anyway
+	se_suits = CheckDriveThroughRoadStopDirection(area, ROAD_Y);
+	ne_suits = CheckDriveThroughRoadStopDirection(area, ROAD_X);
+	if (!ne_suits) return DIAGDIR_SE;
+	if (!se_suits) return DIAGDIR_NE;
+
+	// Build station along the longer direction
+	if (area.w > area.h) return DIAGDIR_NE;
+	if (area.w < area.h) return DIAGDIR_SE;
+
+	return AutodetectRoadObjectDirection(area.tile);
+}
+
 /**
  * Place a new road stop.
  * @param start_tile First tile of the area.
@@ -225,14 +325,23 @@ static void PlaceRoadStop(TileIndex start_tile, TileIndex end_tile, uint32 p2, u
 {
 	uint8 ddir = _road_station_picker_orientation;
 	SB(p2, 16, 16, INVALID_STATION); // no station to join
+	TileArea ta(start_tile, end_tile);
 
 	if (ddir >= DIAGDIR_END) {
-		SetBit(p2, 1); // It's a drive-through stop.
-		ddir -= DIAGDIR_END; // Adjust picker result to actual direction.
+		if (ddir < DIAGDIR_END + 2) {
+			SetBit(p2, 1); // It's a drive-through stop.
+			ddir -= DIAGDIR_END; // Adjust picker result to actual direction.
+		}
+		else if (ddir == DIAGDIR_END + 2) {
+			ddir = AutodetectRoadObjectDirection(start_tile);
+		}
+		else if (ddir == DIAGDIR_END + 3) {
+			SetBit(p2, 1); // It's a drive-through stop.
+			ddir = AutodetectDriveThroughRoadStopDirection(ta);
+		}
 	}
 	p2 |= ddir << 6; // Set the DiagDirecion into p2 bits 6 and 7.
 
-	TileArea ta(start_tile, end_tile);
 	CommandContainer cmdcont = { ta.tile, (uint32)(ta.w | ta.h << 8), p2, cmd, CcRoadStop, "" };
 	ShowSelectStationIfNeeded(cmdcont, ta);
 }
@@ -491,6 +600,7 @@ struct BuildRoadToolbarWindow : Window {
 
 	virtual void OnPlaceObject(Point pt, TileIndex tile)
 	{
+    DiagDirection ddir;
 		_remove_button_clicked = this->IsWidgetLowered(WID_ROT_REMOVE);
 		_one_way_button_clicked = this->IsWidgetLowered(WID_ROT_ONE_WAY);
 		switch (this->last_started_action) {
@@ -518,7 +628,11 @@ struct BuildRoadToolbarWindow : Window {
 				break;
 
 			case WID_ROT_DEPOT:
-				DoCommandP(tile, _cur_roadtype << 2 | _road_depot_orientation, 0,
+				ddir = _road_depot_orientation;
+				if (ddir == DIAGDIR_NW + 1) {
+					ddir = AutodetectRoadObjectDirection(tile);
+				}
+				DoCommandP(tile, _cur_roadtype << 2 | ddir, 0,
 						CMD_BUILD_ROAD_DEPOT | CMD_MSG(_road_type_infos[_cur_roadtype].err_depot), CcRoadDepot);
 				break;
 
@@ -868,7 +982,7 @@ struct BuildRoadDepotWindow : public PickerWindowBase {
 		this->LowerWidget(_road_depot_orientation + WID_BROD_DEPOT_NE);
 		if ( _cur_roadtype == ROADTYPE_TRAM) {
 			this->GetWidget<NWidgetCore>(WID_BROD_CAPTION)->widget_data = STR_BUILD_DEPOT_TRAM_ORIENTATION_CAPTION;
-			for (int i = WID_BROD_DEPOT_NE; i <= WID_BROD_DEPOT_NW; i++) this->GetWidget<NWidgetCore>(i)->tool_tip = STR_BUILD_DEPOT_TRAM_ORIENTATION_SELECT_TOOLTIP;
+			for (int i = WID_BROD_DEPOT_NE; i <= WID_BROD_DEPOT_AUTO; i++) this->GetWidget<NWidgetCore>(i)->tool_tip = STR_BUILD_DEPOT_TRAM_ORIENTATION_SELECT_TOOLTIP;
 		}
 
 		this->FinishInitNested(TRANSPORT_ROAD);
@@ -896,6 +1010,7 @@ struct BuildRoadDepotWindow : public PickerWindowBase {
 			case WID_BROD_DEPOT_NE:
 			case WID_BROD_DEPOT_SW:
 			case WID_BROD_DEPOT_SE:
+			case WID_BROD_DEPOT_AUTO:
 				this->RaiseWidget(_road_depot_orientation + WID_BROD_DEPOT_NE);
 				_road_depot_orientation = (DiagDirection)(widget - WID_BROD_DEPOT_NE);
 				this->LowerWidget(_road_depot_orientation + WID_BROD_DEPOT_NE);
@@ -935,6 +1050,9 @@ static const NWidgetPart _nested_build_road_depot_widgets[] = {
 			EndContainer(),
 			NWidget(NWID_SPACER), SetMinimalSize(3, 0), SetFill(1, 0),
 		EndContainer(),
+		NWidget(NWID_HORIZONTAL), SetPIP(2, 2, 2),
+			NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_BROD_DEPOT_AUTO), SetMinimalSize(134, 12), SetDataTip(STR_STATION_BUILD_ORIENTATION_AUTO, STR_BUILD_DEPOT_ROAD_ORIENTATION_AUTO_TOOLTIP),
+		EndContainer(),
 		NWidget(NWID_SPACER), SetMinimalSize(0, 3),
 	EndContainer(),
 };
@@ -1031,6 +1149,8 @@ struct BuildRoadStationWindow : public PickerWindowBase {
 			case WID_BROS_STATION_NW:
 			case WID_BROS_STATION_X:
 			case WID_BROS_STATION_Y:
+			case WID_BROS_STATION_AUTO:
+			case WID_BROS_STATION_XY_AUTO:
 				this->RaiseWidget(_road_station_picker_orientation + WID_BROS_STATION_NE);
 				_road_station_picker_orientation = (DiagDirection)(widget - WID_BROS_STATION_NE);
 				this->LowerWidget(_road_station_picker_orientation + WID_BROS_STATION_NE);
@@ -1082,6 +1202,13 @@ static const NWidgetPart _nested_road_station_picker_widgets[] = {
 			NWidget(WWT_PANEL, COLOUR_GREY, WID_BROS_STATION_Y),  SetMinimalSize(66, 50), SetFill(0, 0), EndContainer(),
 			NWidget(NWID_SPACER), SetFill(1, 0),
 		EndContainer(),
+		NWidget(NWID_SPACER), SetMinimalSize(0, 2),
+		NWidget(NWID_HORIZONTAL), SetPIP(0, 2, 0),
+			NWidget(NWID_SPACER), SetFill(1, 0),
+			NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_BROS_STATION_AUTO), SetMinimalSize(134, 12), SetDataTip(STR_STATION_BUILD_ORIENTATION_AUTO, STR_STATION_BUILD_ORIENTATION_AUTO_TOOLTIP),
+			NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_BROS_STATION_XY_AUTO), SetMinimalSize(66, 12), SetDataTip(STR_STATION_BUILD_ORIENTATION_AUTO, STR_STATION_BUILD_ORIENTATION_AUTO_TOOLTIP),
+			NWidget(NWID_SPACER), SetFill(1, 0),
+		EndContainer(),
 		NWidget(NWID_SPACER), SetMinimalSize(0, 1),
 		NWidget(NWID_HORIZONTAL), SetPIP(2, 0, 2),
 			NWidget(WWT_LABEL, COLOUR_DARK_GREEN, WID_BROS_INFO), SetMinimalSize(140, 14), SetDataTip(STR_STATION_BUILD_COVERAGE_AREA_TITLE, STR_NULL),
@@ -1120,6 +1247,13 @@ static const NWidgetPart _nested_tram_station_picker_widgets[] = {
 			NWidget(WWT_PANEL, COLOUR_GREY, WID_BROS_STATION_Y),  SetMinimalSize(66, 50), SetFill(0, 0), EndContainer(),
 			NWidget(NWID_SPACER), SetFill(1, 0),
 		EndContainer(),
+		NWidget(NWID_SPACER), SetMinimalSize(0, 2),
+		NWidget(NWID_HORIZONTAL), SetPIP(0, 0, 0),
+			NWidget(NWID_SPACER), SetFill(1, 0),
+			NWidget(WWT_TEXT, COLOUR_GREY, WID_BROS_STATION_AUTO), SetMinimalSize(0, 0), SetDataTip(STR_EMPTY, STR_EMPTY),
+			NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_BROS_STATION_XY_AUTO), SetMinimalSize(133, 12), SetDataTip(STR_STATION_BUILD_ORIENTATION_AUTO, STR_STATION_BUILD_ORIENTATION_AUTO_TOOLTIP),
+			NWidget(NWID_SPACER), SetFill(1, 0),
+		EndContainer(),
 		NWidget(NWID_SPACER), SetMinimalSize(0, 1),
 		NWidget(NWID_HORIZONTAL), SetPIP(2, 0, 2),
 			NWidget(WWT_LABEL, COLOUR_DARK_GREEN, WID_BROS_INFO), SetMinimalSize(140, 14), SetDataTip(STR_STATION_BUILD_COVERAGE_AREA_TITLE, STR_NULL),
@@ -1151,6 +1285,6 @@ static void ShowRVStationPicker(Window *parent, RoadStopType rs)
 
 void InitializeRoadGui()
 {
-	_road_depot_orientation = DIAGDIR_NW;
-	_road_station_picker_orientation = DIAGDIR_NW;
+	_road_depot_orientation = (DiagDirection)(DIAGDIR_NW + 1);
+	_road_station_picker_orientation = (DiagDirection)(DIAGDIR_END + 3);
 }
diff --git a/src/roadveh_cmd.cpp b/src/roadveh_cmd.cpp
index 970477001..d0c2927b2 100644
--- a/src/roadveh_cmd.cpp
+++ b/src/roadveh_cmd.cpp
@@ -1154,7 +1154,7 @@ bool IndividualRoadVehicleController(RoadVehicle *v, const RoadVehicle *prev)
 		v->x_pos = gp.x;
 		v->y_pos = gp.y;
 		v->UpdatePosition();
-		if ((v->vehstatus & VS_HIDDEN) == 0) v->Vehicle::UpdateViewport(true);
+		if (v->IsDrawn()) v->Vehicle::UpdateViewport(true);
 		return true;
 	}
 
diff --git a/src/saveload/town_sl.cpp b/src/saveload/town_sl.cpp
index a31c886ec..a87c70e1a 100644
--- a/src/saveload/town_sl.cpp
+++ b/src/saveload/town_sl.cpp
@@ -33,6 +33,10 @@ void RebuildTownCaches()
 	FOR_ALL_TOWNS(town) {
 		town->cache.population = 0;
 		town->cache.num_houses = 0;
+		town->cache.potential_pop = 0;
+		town->houses_construction = 0;
+		town->houses_reconstruction = 0;
+		town->houses_demolished = 0;
 	}
 
 	for (TileIndex t = 0; t < MapSize(); t++) {
@@ -41,7 +45,15 @@ void RebuildTownCaches()
 		HouseID house_id = GetHouseType(t);
 		town = Town::GetByTile(t);
 		IncreaseBuildingCount(town, house_id);
-		if (IsHouseCompleted(t)) town->cache.population += HouseSpec::Get(house_id)->population;
+		if (IsHouseCompleted(t)) {
+      town->cache.population += HouseSpec::Get(house_id)->population;
+      //if (town->houses_construction > 0) town->houses_construction--;
+    }
+		else{
+			town->houses_construction++;
+		}
+		town->cache.potential_pop += HouseSpec::Get(house_id)->population;
+		//town->cache.potential_pop += HouseSpec::Get(house_id)->population;
 
 		/* Increase the number of houses for every house, but only once. */
 		if (GetHouseNorthPart(house_id) == 0) town->cache.num_houses++;
diff --git a/src/script/api/game/game_window.hpp.sq b/src/script/api/game/game_window.hpp.sq
index ce2b37bb5..7735b9e1f 100644
--- a/src/script/api/game/game_window.hpp.sq
+++ b/src/script/api/game/game_window.hpp.sq
@@ -930,6 +930,7 @@ void SQGSWindow_Register(Squirrel *engine)
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_BUILD_EW,                          "WID_RAT_BUILD_EW");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_BUILD_Y,                           "WID_RAT_BUILD_Y");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_AUTORAIL,                          "WID_RAT_AUTORAIL");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_POLYRAIL,                          "WID_RAT_POLYRAIL");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_DEMOLISH,                          "WID_RAT_DEMOLISH");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_BUILD_DEPOT,                       "WID_RAT_BUILD_DEPOT");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_BUILD_WAYPOINT,                    "WID_RAT_BUILD_WAYPOINT");
diff --git a/src/script/api/script_window.hpp b/src/script/api/script_window.hpp
index fa584693a..70acaa279 100644
--- a/src/script/api/script_window.hpp
+++ b/src/script/api/script_window.hpp
@@ -2028,6 +2028,7 @@ public:
 		WID_RAT_BUILD_EW                             = ::WID_RAT_BUILD_EW,                             ///< Build rail along the game view X axis.
 		WID_RAT_BUILD_Y                              = ::WID_RAT_BUILD_Y,                              ///< Build rail along the game grid Y axis.
 		WID_RAT_AUTORAIL                             = ::WID_RAT_AUTORAIL,                             ///< Autorail tool.
+		WID_RAT_POLYRAIL                             = ::WID_RAT_POLYRAIL,                             ///< Polyline rail tool.
 		WID_RAT_DEMOLISH                             = ::WID_RAT_DEMOLISH,                             ///< Destroy something with dynamite!
 		WID_RAT_BUILD_DEPOT                          = ::WID_RAT_BUILD_DEPOT,                          ///< Build a depot.
 		WID_RAT_BUILD_WAYPOINT                       = ::WID_RAT_BUILD_WAYPOINT,                       ///< Build a waypoint.
diff --git a/src/settings_gui.cpp b/src/settings_gui.cpp
index ffb32c2ee..5fb65b01d 100644
--- a/src/settings_gui.cpp
+++ b/src/settings_gui.cpp
@@ -1499,6 +1499,7 @@ static SettingsContainer &GetSettingsTree()
 	{
 		/* Build up the dynamic settings-array only once per OpenTTD session */
 		main = new SettingsContainer();
+		main->Add(new SettingEntry("gui.community"));
 
 		SettingsPage *localisation = main->Add(new SettingsPage(STR_CONFIG_SETTING_LOCALISATION));
 		{
@@ -1563,6 +1564,7 @@ static SettingsContainer &GetSettingsTree()
 				viewports->Add(new SettingEntry("gui.measure_tooltip"));
 				viewports->Add(new SettingEntry("gui.loading_indicators"));
 				viewports->Add(new SettingEntry("gui.show_track_reservation"));
+				viewports->Add(new SettingEntry("gui.enable_extra_tooltips"));
 			}
 
 			SettingsPage *construction = interface->Add(new SettingsPage(STR_CONFIG_SETTING_INTERFACE_CONSTRUCTION));
@@ -1664,6 +1666,24 @@ static SettingsContainer &GetSettingsTree()
 				routing->Add(new SettingEntry("pf.pathfinder_for_ships"));
 			}
 
+      SettingsPage *ordercontrols = vehicles->Add(new SettingsPage(STR_CONFIG_SETTING_VEHICLES_CTRL));
+			{
+        SettingsPage *ordershortcuts = ordercontrols->Add(new SettingsPage(STR_CONFIG_SETTING_ORDER_SHORTCUTS));
+        {
+          ordershortcuts->Add(new SettingEntry("gui.goto_shortcuts_ctrl_lclick"));
+          ordershortcuts->Add(new SettingEntry("gui.goto_shortcuts_shift_lclick"));
+          ordershortcuts->Add(new SettingEntry("gui.goto_shortcuts_ctrlshift_lclick"));
+          ordershortcuts->Add(new SettingEntry("gui.goto_shortcuts_alt_lclick"));
+          ordershortcuts->Add(new SettingEntry("gui.goto_shortcuts_altshift_lclick"));
+          ordershortcuts->Add(new SettingEntry("gui.goto_shortcuts_altctrl_lclick"));
+        }
+				ordercontrols->Add(new SettingEntry("gui.enable_ctrl_click_start_stop"));
+				//ordercontrols->Add(new SettingEntry("gui.new_nonstop"));  // If enabled here must be disabled on the original place
+				//ordercontrols->Add(new SettingEntry("gui.stop_location")); // If enabled here must be disabled on the original place
+				ordercontrols->Add(new SettingEntry("gui.auto_noload_on_transfer"));
+				ordercontrols->Add(new SettingEntry("gui.auto_noload_on_unloadall"));
+			}
+
 			vehicles->Add(new SettingEntry("order.no_servicing_if_no_breakdowns"));
 			vehicles->Add(new SettingEntry("order.serviceathelipad"));
 		}
diff --git a/src/settings_type.h b/src/settings_type.h
index 8f03b1dc1..fc24695df 100644
--- a/src/settings_type.h
+++ b/src/settings_type.h
@@ -88,6 +88,15 @@ struct GUISettings {
 	bool   vehicle_income_warn;              ///< if a vehicle isn't generating income, show a warning
 	bool   show_finances;                    ///< show finances at end of year
 	bool   sg_new_nonstop;                   ///< ttdpatch compatible nonstop handling read from pre v93 savegames
+	bool   enable_ctrl_click_start_stop;     ///< allow ctrl+click to start or stop vehicles
+	uint8  goto_shortcuts_ctrl_lclick;       ///< goto action shortcut CTRL+LEFT-CLICK
+	uint8  goto_shortcuts_shift_lclick;      ///< goto action shortcut SHIFT+LEFT-CLICK
+	uint8  goto_shortcuts_ctrlshift_lclick;  ///< goto action shortcut CTRL+SHIFT+LEFT-CLICK
+	uint8  goto_shortcuts_alt_lclick;        ///< goto action shortcut ALT+LEFT-CLICK
+	uint8  goto_shortcuts_altshift_lclick;   ///< goto action shortcut ALT+SHIFT+LEFT-CLICK
+	uint8  goto_shortcuts_altctrl_lclick;    ///< goto action shortcut ALT+CTRL+LEFT-CLICK
+	bool   auto_noload_on_transfer;          ///< automatically set no-loading when ordering to transfer all cargo
+	bool   auto_noload_on_unloadall;         ///< automatically set no-loading when ordering to unload all cargo
 	bool   new_nonstop;                      ///< ttdpatch compatible nonstop handling
 	uint8  stop_location;                    ///< what is the default stop location of trains?
 	uint8  auto_scrolling;                   ///< scroll when moving mouse to the edge (see #ViewportAutoscrolling)
@@ -168,6 +177,13 @@ struct GUISettings {
 	uint8  settings_restriction_mode;        ///< selected restriction mode in adv. settings GUI. @see RestrictionMode
 	bool   newgrf_show_old_versions;         ///< whether to show old versions in the NewGRF list
 	uint8  newgrf_default_palette;           ///< default palette to use for NewGRFs without action 14 palette information
+	bool   enable_extra_tooltips;            ///< enable extra tooltips when hovering over various elements
+        uint8  cb_distance_check;                ///< zoning cb distance
+        uint32 powerfund_money;                  ///< minimum amount of money for powerfund to work
+        uint16 powerfund_houses;                 ///< powerfunding maximum houses limit
+
+	uint8  community;                        ///< chosen community nice=0, btpro=1
+	uint32  btpro_version;
 
 	/**
 	 * Returns true when the user has sufficient privileges to edit newgrfs on a running game
@@ -277,6 +293,8 @@ struct NetworkSettings {
 	char   last_host[NETWORK_HOSTNAME_LENGTH];            ///< IP address of the last joined server
 	uint16 last_port;                                     ///< port of the last joined server
 	bool   no_http_content_downloads;                     ///< do not do content downloads over HTTP
+	char   community_user[2][NETWORK_NAME_LENGTH];           ///< webpage user to retrieve Token
+	char   community_password[2][NETWORK_PASSWORD_LENGTH];///< webpage password to retrieve Token
 #else /* ENABLE_NETWORK */
 #endif
 };
diff --git a/src/smallmap_gui.cpp b/src/smallmap_gui.cpp
index 97d01325a..274e3c79d 100644
--- a/src/smallmap_gui.cpp
+++ b/src/smallmap_gui.cpp
@@ -262,6 +262,20 @@ static const LegendAndColour * const _legend_table[] = {
 
 #include "table/heightmap_colours.h"
 
+/**
+ * Colour Coding for Stuck Counter
+ */
+static const uint32 _stuck_counter_colours[] = {
+	MKCOLOUR(0xD0D0D0D0),
+	MKCOLOUR(0xCECECECE),
+	MKCOLOUR(0xBFBFBFBF),
+	MKCOLOUR(0xBDBDBDBD),
+	MKCOLOUR(0xBABABABA),
+	MKCOLOUR(0xB8B8B8B8),
+	MKCOLOUR(0xB6B6B6B6),
+	MKCOLOUR(0xB4B4B4B4),
+};
+
 /** Colour scheme of the smallmap. */
 struct SmallMapColourScheme {
 	uint32 *height_colours;            ///< Cached colours for each level in a map.
@@ -471,13 +485,9 @@ static inline uint32 GetSmallMapRoutesPixels(TileIndex tile, TileType t)
 			default:              return MKCOLOUR_FFFF;
 		}
 	} else if (t == MP_RAILWAY) {
-		AndOr andor = {
-			MKCOLOUR_0XX0(GetRailTypeInfo(GetRailType(tile))->map_colour),
-			_smallmap_contours_andor[t].mand
-		};
-
-		const SmallMapColourScheme *cs = &_heightmap_schemes[_settings_client.gui.smallmap_land_colour];
-		return ApplyMask(cs->default_colour, &andor);
+		byte c = GetStuckCounter(tile);
+		if (c == 0) return 0;
+		return _stuck_counter_colours[(uint)c * lengthof(_stuck_counter_colours) / (MAX_UVALUE(byte) + 1)];
 	}
 
 	/* Ground colour */
@@ -907,13 +917,13 @@ void SmallMapWindow::DrawTowns(const DrawPixelInfo *dpi) const
 		if (x + t->cache.sign.width_small > dpi->left &&
 				x < dpi->left + dpi->width &&
 				y + FONT_HEIGHT_SMALL > dpi->top &&
-				y < dpi->top + dpi->height) {
-			/* And draw it. */
-			SetDParam(0, t->index);
-			DrawString(x, x + t->cache.sign.width_small, y, STR_SMALLMAP_TOWN);
+					y < dpi->top + dpi->height) {
+				/* And draw it. */
+				SetDParam(0, t->index);
+				DrawString(x, x + t->cache.sign.width_small, y, (t->larger_town ? STR_SMALLMAP_TOWN_LARGE : STR_SMALLMAP_TOWN));
+			}
 		}
 	}
-}
 
 /**
  * Adds map indicators to the smallmap.
diff --git a/src/statusbar_gui.cpp b/src/statusbar_gui.cpp
index 557551f3f..770b5b1af 100644
--- a/src/statusbar_gui.cpp
+++ b/src/statusbar_gui.cpp
@@ -188,6 +188,19 @@ struct StatusBarWindow : Window {
 					DrawSprite(SPR_UNREAD_NEWS, PAL_NONE, r.right - WD_FRAMERECT_RIGHT - icon_size.width, r.top + WD_FRAMERECT_TOP + (int)(FONT_HEIGHT_NORMAL - icon_size.height) / 2);
 				}
 				break;
+
+      case WID_S_USER:
+        if(_settings_client.gui.community != 0){
+          SetDParamStr(0, (char*)_settings_client.network.community_user[_settings_client.gui.community-1]);
+          DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_CC_WIKI_USER_PAGE, TC_FROMSTRING, SA_HOR_CENTER);
+        }
+				break;
+
+			case WID_S_RULES:
+				if(_settings_client.gui.community != 0){
+					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_CC_WIKI_RULES_PAGE_STATUS, TC_FROMSTRING, SA_HOR_CENTER);
+				}
+				break;
 		}
 	}
 
@@ -214,8 +227,17 @@ struct StatusBarWindow : Window {
 
 	virtual void OnClick(Point pt, int widget, int click_count)
 	{
+    extern void OpenBrowser(const char *url);
 		switch (widget) {
 			case WID_S_MIDDLE: ShowLastNewsMessage(); break;
+			case WID_S_USER: 
+        if(_settings_client.gui.community == 1) OpenBrowser("http://n-ice.org/openttd");
+				else if(_settings_client.gui.community == 2) OpenBrowser("http://openttd.btpro.nl");
+				break;
+			case WID_S_RULES: 
+				if(_settings_client.gui.community == 1) OpenBrowser("https://wiki.x-base.info/OpenTTD/Rules");
+				else if(_settings_client.gui.community == 2) OpenBrowser("http://openttd.btpro.nl/wiki/index.php/Server_Rules");
+				break;
 			case WID_S_RIGHT:  if (_local_company != COMPANY_SPECTATOR) ShowCompanyFinances(_local_company); break;
 			default: ResetObjectToPlace();
 		}
@@ -243,7 +265,9 @@ struct StatusBarWindow : Window {
 static const NWidgetPart _nested_main_status_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_PANEL, COLOUR_GREY, WID_S_LEFT), SetMinimalSize(140, 12), EndContainer(),
+		NWidget(WWT_PUSHBTN, COLOUR_CREAM, WID_S_RULES), SetMinimalSize(80, 12), SetDataTip(0x0, STR_CC_WIKI_RULES_PAGE_STATUS_TOOLTIP),
 		NWidget(WWT_PUSHBTN, COLOUR_GREY, WID_S_MIDDLE), SetMinimalSize(40, 12), SetDataTip(0x0, STR_STATUSBAR_TOOLTIP_SHOW_LAST_NEWS), SetResize(1, 0),
+		NWidget(WWT_PUSHBTN, COLOUR_GREY, WID_S_USER), SetMinimalSize(80, 12), SetDataTip(0x0, STR_CC_WIKI_USER_PAGE_TOOLTIP),
 		NWidget(WWT_PUSHBTN, COLOUR_GREY, WID_S_RIGHT), SetMinimalSize(140, 12),
 	EndContainer(),
 };
diff --git a/src/table/misc_settings.ini b/src/table/misc_settings.ini
index 787a82dd8..3536fdb48 100644
--- a/src/table/misc_settings.ini
+++ b/src/table/misc_settings.ini
@@ -255,7 +255,7 @@ type     = SLE_UINT
 var      = _transparency_opt
 def      = 0
 min      = 0
-max      = 0x1FF
+max      = 0x3FF
 cat      = SC_BASIC
 
 [SDTG_VAR]
@@ -264,7 +264,7 @@ type     = SLE_UINT
 var      = _transparency_lock
 def      = 0
 min      = 0
-max      = 0x1FF
+max      = 0x3FF
 cat      = SC_BASIC
 
 [SDTG_VAR]
diff --git a/src/table/settings.ini b/src/table/settings.ini
index 0d508d56b..96369eee4 100644
--- a/src/table/settings.ini
+++ b/src/table/settings.ini
@@ -3962,5 +3962,182 @@ strhelp  = STR_CONFIG_SETTING_RIGHT_MOUSE_BTN_EMU_HELPTEXT
 strval   = STR_CONFIG_SETTING_RIGHT_MOUSE_BTN_EMU_COMMAND
 cat      = SC_BASIC
 
+; //MODGUI *********************************
+[SDTC_BOOL]
+var      = gui.enable_ctrl_click_start_stop
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = true
+str      = STR_CONFIG_SETTING_CTRL_ENABLE_CTRLCLICK_STARTSTOP
+
+[SDTC_BOOL]
+var      = gui.auto_noload_on_transfer
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = true
+str      = STR_CONFIG_SETTING_AUTOSET_NOLOAD_ON_TRANSFER
+
+[SDTC_BOOL]
+var      = gui.auto_noload_on_unloadall
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = false
+str      = STR_CONFIG_SETTING_AUTOSET_NOLOAD_ON_UNLOAD
+
+[SDTC_VAR]
+var      = gui.goto_shortcuts_ctrl_lclick
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 1
+min      = 0
+max      = 6
+interval = 1
+str      = STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_CTRLLCLICK
+strval   = STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE
+proc     = RedrawScreen
+cat      = SC_BASIC
+
+[SDTC_VAR]
+var      = gui.goto_shortcuts_shift_lclick
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 6
+interval = 1
+str      = STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_SHIFTLCLICK
+strval   = STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE
+proc     = RedrawScreen
+cat      = SC_BASIC
+
+[SDTC_VAR]
+var      = gui.goto_shortcuts_ctrlshift_lclick
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 6
+interval = 1
+str      = STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_CTRLSHIFTLCLICK
+strval   = STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE
+proc     = RedrawScreen
+cat      = SC_BASIC
+
+[SDTC_VAR]
+var      = gui.goto_shortcuts_alt_lclick
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 6
+interval = 1
+str      = STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_ALTLCLICK
+strval   = STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE
+proc     = RedrawScreen
+cat      = SC_BASIC
+
+[SDTC_VAR]
+var      = gui.goto_shortcuts_altshift_lclick
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 6
+interval = 1
+str      = STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_ALTSHIFTCLICK
+strval   = STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE
+proc     = RedrawScreen
+cat      = SC_BASIC
+
+[SDTC_VAR]
+var      = gui.goto_shortcuts_altctrl_lclick
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 6
+interval = 1
+str      = STR_CONFIG_SETTING_CTRL_GOTOSHORTCUT_CTRLALTLCLICK
+strval   = STR_CONFIG_SETTING_CTRL_GOTOSHORTOPTS_NONE
+proc     = RedrawScreen
+cat      = SC_BASIC
+
+[SDTC_VAR]
+var      = gui.cb_distance_check
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = 25
+min      = 0
+max      = 100
+interval = 5
+str      = STR_CB_DISTANCE_CHECK
+strval   = STR_JUST_COMMA
+proc     = RedrawScreen
+
+[SDTC_BOOL]
+var      = gui.enable_extra_tooltips
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = true
+str      = STR_CONFIG_SETTING_ENABLE_EXTRA_TOOLTIPS
+
+[SDTC_VAR]
+ifdef    = ENABLE_NETWORK
+var      = gui.btpro_version
+type     = SLE_UINT32
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = 0
+min      = 0
+max      = 999999
+
+[SDTC_VAR]
+ifdef    = ENABLE_NETWORK
+var      = gui.community
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+guiflags = SGF_MULTISTRING
+def      = 0
+min      = 0
+max      = 2
+interval = 1
+str      = STR_CONFIG_SETTING_COMMUNITY
+strval   = STR_CONFIG_SETTING_CLIENT_COMMUNITY
+proc     = RedrawScreen
+cat      = SC_BASIC
+
+[SDTC_STR]
+ifdef    = ENABLE_NETWORK
+var      = network.community_user[0]
+type     = SLE_STRB
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = NULL
+cat      = SC_BASIC
+
+[SDTC_STR]
+ifdef    = ENABLE_NETWORK
+var      = network.community_user[1]
+type     = SLE_STRB
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = NULL
+cat      = SC_BASIC
+
+[SDTC_STR]
+ifdef    = ENABLE_NETWORK
+var      = network.community_password[0]
+type     = SLE_STRB
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = NULL
+cat      = SC_BASIC
+
+[SDTC_STR]
+ifdef    = ENABLE_NETWORK
+var      = network.community_password[1]
+type     = SLE_STRB
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = NULL
+cat      = SC_BASIC
+
 [SDT_END]
 
diff --git a/src/table/sprites.h b/src/table/sprites.h
index a57326997..d0b1faa28 100644
--- a/src/table/sprites.h
+++ b/src/table/sprites.h
@@ -301,8 +301,23 @@ static const uint16 EMPTY_BOUNDING_BOX_SPRITE_COUNT = 1;
 static const SpriteID SPR_PALETTE_BASE = SPR_EMPTY_BOUNDING_BOX + EMPTY_BOUNDING_BOX_SPRITE_COUNT;
 static const uint16 PALETTE_SPRITE_COUNT = 1;
 
+/* zoning stuff */
+static const SpriteID SPR_INNER_HIGHLIGHT_BASE      = SPR_PALETTE_BASE + PALETTE_SPRITE_COUNT;
+static const SpriteID SPR_IMG_COMPANY_CARGO         = SPR_INNER_HIGHLIGHT_BASE + 19;
+static const SpriteID SPR_IMG_COMPANY_GOAL          = SPR_INNER_HIGHLIGHT_BASE + 20;
+static const SpriteID SPR_PALETTE_ZONING_RED        = SPR_INNER_HIGHLIGHT_BASE + 21;
+static const SpriteID SPR_PALETTE_ZONING_GREEN      = SPR_INNER_HIGHLIGHT_BASE + 22;
+static const SpriteID SPR_PALETTE_ZONING_BLACK      = SPR_INNER_HIGHLIGHT_BASE + 23;
+static const SpriteID SPR_PALETTE_ZONING_LIGHT_BLUE = SPR_INNER_HIGHLIGHT_BASE + 24;
+static const SpriteID SPR_PALETTE_ZONING_ORANGE     = SPR_INNER_HIGHLIGHT_BASE + 25;
+static const SpriteID SPR_PALETTE_ZONING_WHITE      = SPR_INNER_HIGHLIGHT_BASE + 26;
+static const SpriteID SPR_PALETTE_ZONING_YELLOW     = SPR_INNER_HIGHLIGHT_BASE + 27;
+static const SpriteID SPR_PALETTE_ZONING_PURPLE     = SPR_INNER_HIGHLIGHT_BASE + 28;
+static const uint16 SPR_INNER_HIGHLIGHT_COUNT     = 29;
+
 /* From where can we start putting NewGRFs? */
-static const SpriteID SPR_NEWGRFS_BASE = SPR_PALETTE_BASE + PALETTE_SPRITE_COUNT;
+//static const SpriteID SPR_NEWGRFS_BASE = SPR_PALETTE_BASE + PALETTE_SPRITE_COUNT;
+static const SpriteID SPR_NEWGRFS_BASE = SPR_INNER_HIGHLIGHT_BASE + SPR_INNER_HIGHLIGHT_COUNT;
 
 /* Manager face sprites */
 static const SpriteID SPR_GRADIENT = 874; // background gradient behind manager face
diff --git a/src/terraform_gui.cpp b/src/terraform_gui.cpp
index 97749a8dc..005fab0e6 100644
--- a/src/terraform_gui.cpp
+++ b/src/terraform_gui.cpp
@@ -33,6 +33,7 @@
 #include "engine_base.h"
 #include "terraform_gui.h"
 #include "zoom_func.h"
+#include "tile_map.h"
 
 #include "widgets/terraform_widget.h"
 
@@ -149,6 +150,11 @@ void PlaceProc_DemolishArea(TileIndex tile)
 	VpStartPlaceSizing(tile, VPM_X_AND_Y, DDSP_DEMOLISH_AREA);
 }
 
+static void PlaceProc_Measure(TileIndex tile)
+{
+	VpStartPlaceSizing(tile, VPM_A_B_LINE, DDSP_MEASURE);
+}
+
 /** Terra form toolbar managing class. */
 struct TerraformToolbarWindow : Window {
 	int last_user_action; ///< Last started user action.
@@ -206,6 +212,11 @@ struct TerraformToolbarWindow : Window {
 				ShowBuildTreesToolbar();
 				break;
 
+      case WID_TT_MEASUREMENT_TOOL:
+				HandlePlacePushButton(this, WID_TT_MEASUREMENT_TOOL, SPR_CURSOR_QUERY, HT_RECT);
+				this->last_user_action = widget;
+				break;
+
 			case WID_TT_PLACE_SIGN: // Place sign button
 				HandlePlacePushButton(this, WID_TT_PLACE_SIGN, SPR_CURSOR_SIGN, HT_RECT);
 				this->last_user_action = widget;
@@ -242,6 +253,10 @@ struct TerraformToolbarWindow : Window {
 				DoCommandP(tile, OBJECT_OWNED_LAND, 0, CMD_BUILD_OBJECT | CMD_MSG(STR_ERROR_CAN_T_PURCHASE_THIS_LAND), CcPlaySound_SPLAT_RAIL);
 				break;
 
+      case WID_TT_MEASUREMENT_TOOL:
+				PlaceProc_Measure(tile);
+				break;
+
 			case WID_TT_PLACE_SIGN: // Place sign button
 				PlaceProc_Sign(tile);
 				break;
@@ -273,6 +288,9 @@ struct TerraformToolbarWindow : Window {
 				case DDSP_LEVEL_AREA:
 					GUIPlaceProcDragXY(select_proc, start_tile, end_tile);
 					break;
+				case DDSP_MEASURE:
+					//nothing to do, just draw a tooltip
+					break;
 			}
 		}
 	}
@@ -335,6 +353,8 @@ static const NWidgetPart _nested_terraform_widgets[] = {
 								SetFill(0, 1), SetDataTip(SPR_IMG_PLANTTREES, STR_SCENEDIT_TOOLBAR_PLANT_TREES),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_PLACE_SIGN), SetMinimalSize(22, 22),
 								SetFill(0, 1), SetDataTip(SPR_IMG_SIGN, STR_SCENEDIT_TOOLBAR_PLACE_SIGN),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_MEASUREMENT_TOOL), SetMinimalSize(22,22),
+								SetFill(0, 1), SetDataTip(SPR_SHOW_ORDERS, STR_LANDSCAPING_TOOLTIP_RULER_TOOL),
 		NWidget(NWID_SELECTION, INVALID_COLOUR, WID_TT_SHOW_PLACE_OBJECT),
 			NWidget(WWT_PUSHIMGBTN, COLOUR_DARK_GREEN, WID_TT_PLACE_OBJECT), SetMinimalSize(22, 22),
 								SetFill(0, 1), SetDataTip(SPR_IMG_TRANSMITTER, STR_SCENEDIT_TOOLBAR_PLACE_OBJECT),
diff --git a/src/tile_cmd.h b/src/tile_cmd.h
index ce70232a0..0ab3c5a9a 100644
--- a/src/tile_cmd.h
+++ b/src/tile_cmd.h
@@ -65,6 +65,7 @@ struct TileDesc {
 	StringID railtype;          ///< Type of rail on the tile.
 	uint16 rail_speed;          ///< Speed limit of rail (bridges and track)
 	uint16 road_speed;          ///< Speed limit of road (bridges)
+	uint16 population;
 };
 
 /**
diff --git a/src/tilehighlight_func.h b/src/tilehighlight_func.h
index 3edef509a..471374119 100644
--- a/src/tilehighlight_func.h
+++ b/src/tilehighlight_func.h
@@ -14,6 +14,7 @@
 
 #include "gfx_type.h"
 #include "tilehighlight_type.h"
+#include "track_type.h"
 
 void PlaceProc_DemolishArea(TileIndex tile);
 bool GUIPlaceProcDragXY(ViewportDragDropSelectionProcess proc, TileIndex start_tile, TileIndex end_tile);
@@ -30,6 +31,9 @@ void VpSetPlaceSizingLimit(int limit);
 
 void UpdateTileSelection();
 
+void StoreRailPlacementEndpoints(TileIndex start_tile, TileIndex end_tile, Track start_track, bool bidirectional = true);
+void ClearRailPlacementEndpoints();
+
 extern TileHighlightData _thd;
 
 #endif /* TILEHIGHLIGHT_FUNC_H */
diff --git a/src/tilehighlight_type.h b/src/tilehighlight_type.h
index 3d64248df..88300ee43 100644
--- a/src/tilehighlight_type.h
+++ b/src/tilehighlight_type.h
@@ -28,6 +28,7 @@ enum HighLightStyle {
 	HT_RAIL      = 0x080, ///< autorail (one piece), lower bits: direction
 	HT_VEHICLE   = 0x100, ///< vehicle is accepted as target as well (bitmask)
 	HT_DIAGONAL  = 0x200, ///< Also allow 'diagonal rectangles'. Only usable in combination with #HT_RECT or #HT_POINT.
+	HT_POLY      = 0x400, ///< polyline mode; connect highlighted track with previous one
 	HT_DRAG_MASK = 0x0F8, ///< Mask for the tile drag-type modes.
 
 	/* lower bits (used with HT_LINE and HT_RAIL):
@@ -54,11 +55,15 @@ struct TileHighlightData {
 
 	Point new_pos;       ///< New value for \a pos; used to determine whether to redraw the selection.
 	Point new_size;      ///< New value for \a size; used to determine whether to redraw the selection.
+	Point new_offs;      ///< New value for \a offs; used to determine whether to redraw the selection.
 	Point new_outersize; ///< New value for \a outersize; used to determine whether to redraw the selection.
 	byte dirty;          ///< Whether the build station window needs to redraw due to the changed selection.
 
 	Point selstart;      ///< The location where the dragging started.
 	Point selend;        ///< The location where the drag currently ends.
+	Point selstart2;     ///< The location where the second segment of a polyline track starts.
+	Point selend2;       ///< The location where the second segment of a polyline track ends.
+	HighLightStyle dir2; ///< Direction of the second segment of a polyline track, HT_DIR_END if second segment is not selected.
 	byte sizelimit;      ///< Whether the selection is limited in length, and what the maximum length is.
 
 	HighLightStyle drawstyle;      ///< Lower bits 0-3 are reserved for detailed highlight information.
diff --git a/src/timetable_cmd.cpp b/src/timetable_cmd.cpp
index 29986c353..511e7b00f 100644
--- a/src/timetable_cmd.cpp
+++ b/src/timetable_cmd.cpp
@@ -396,6 +396,7 @@ void UpdateVehicleTimetable(Vehicle *v, bool travelling)
 
 	/* This vehicle is arriving at the first destination in the timetable. */
 	if (v->cur_real_order_index == first_manual_order && travelling) {
+		v->trip_history.NewRound();
 		/* If the start date hasn't been set, or it was set automatically when
 		 * the vehicle last arrived at the first destination, update it to the
 		 * current time. Otherwise set the late counter appropriately to when
diff --git a/src/toolbar_gui.cpp b/src/toolbar_gui.cpp
index 5567c5580..a83d56c81 100644
--- a/src/toolbar_gui.cpp
+++ b/src/toolbar_gui.cpp
@@ -35,6 +35,7 @@
 #include "news_gui.h"
 #include "ai/ai_gui.hpp"
 #include "tilehighlight_func.h"
+#include "watch_gui_1.h"
 #include "smallmap_gui.h"
 #include "graph_gui.h"
 #include "textbuf_gui.h"
@@ -49,6 +50,12 @@
 #include "toolbar_gui.h"
 #include "framerate_type.h"
 #include "guitimer_func.h"
+#include "zoning.h"
+
+#include "commands_token_gui.h"
+#include "cargo_table_gui.h"
+#include "object_type.h"
+#include "error.h"
 
 #include "widgets/toolbar_widget.h"
 
@@ -79,6 +86,7 @@ enum CallBackFunction {
 	CBF_NONE,
 	CBF_PLACE_SIGN,
 	CBF_PLACE_LANDINFO,
+	CBF_BUILD_HQ,
 };
 
 static CallBackFunction _last_started_action = CBF_NONE; ///< Last started user action.
@@ -163,10 +171,10 @@ public:
 
 		DrawCompanyIcon(company, rtl ? right - this->icon_size.width - WD_FRAMERECT_RIGHT : left + WD_FRAMERECT_LEFT, top + icon_offset);
 #ifdef ENABLE_NETWORK
-		if (NetworkCompanyIsPassworded(company)) {
-			DrawSprite(SPR_LOCK, PAL_NONE, rtl ? left + WD_FRAMERECT_LEFT : right - this->lock_size.width - WD_FRAMERECT_RIGHT, top + lock_offset);
+		if (_networking && NetworkCompanyIsPassworded(company)) {
+			DrawSprite(SPR_LOCK, PAL_NONE, (rtl ? right : left + 15), top + (FONT_HEIGHT_NORMAL - 10) / 2);
 		}
-#endif
+#endif /* ENABLE_NETWORK */
 
 		SetDParam(0, company);
 		SetDParam(1, company);
@@ -176,7 +184,8 @@ public:
 		} else {
 			col = sel ? TC_WHITE : TC_BLACK;
 		}
-		DrawString(left + WD_FRAMERECT_LEFT + (rtl ? 3 + this->lock_size.width : 3 + this->icon_size.width), right - WD_FRAMERECT_RIGHT - (rtl ? 3 + this->icon_size.width : 3 + this->lock_size.width), top + text_offset, STR_COMPANY_NAME_COMPANY_NUM, col);
+		//DrawString(left + WD_FRAMERECT_LEFT + (rtl ? 3 + this->lock_size.width : 3 + this->icon_size.width), right - WD_FRAMERECT_RIGHT - (rtl ? 3 + this->icon_size.width : 3 + this->lock_size.width), top + text_offset, STR_COMPANY_NAME_COMPANY_NUM, col);
+		DrawString(left + WD_FRAMERECT_LEFT + (rtl ? 3 + this->lock_size.width : 8 + this->icon_size.width), right - WD_FRAMERECT_RIGHT - (rtl ? 3 + this->icon_size.width : 3 + this->lock_size.width), top + text_offset, STR_COMPANY_NAME_COMPANY_NUM, col);
 	}
 };
 
@@ -272,6 +281,20 @@ static CallBackFunction SelectSignTool()
 	}
 }
 
+/* hq hotkey */
+static CallBackFunction BuildCompanyHQ(){
+	if(_current_company == COMPANY_SPECTATOR) return CBF_NONE;
+	//if (_cursor.sprite == SPR_CURSOR_HQ) {  // original
+	if (_last_started_action == CBF_BUILD_HQ) {
+		ResetObjectToPlace();
+		return CBF_NONE;
+	} else {
+		SetObjectToPlace(SPR_CURSOR_HQ, PAL_NONE, HT_RECT, WC_MAIN_TOOLBAR, 0);
+		SetTileSelectSize(2, 2);
+		return CBF_BUILD_HQ;
+	}
+}
+
 /* --- Pausing --- */
 
 static CallBackFunction ToolbarPauseClick(Window *w)
@@ -305,6 +328,7 @@ enum OptionMenuEntries {
 	OME_SETTINGS,
 	OME_SCRIPT_SETTINGS,
 	OME_NEWGRFSETTINGS,
+	OME_ZONING,
 	OME_TRANSPARENCIES,
 	OME_SHOW_TOWNNAMES,
 	OME_SHOW_STATIONNAMES,
@@ -333,6 +357,7 @@ static CallBackFunction ToolbarOptionsClick(Window *w)
 	 * to network clients. */
 	if (!_networking || _network_server) *list->Append() = new DropDownListStringItem(STR_SETTINGS_MENU_SCRIPT_SETTINGS, OME_SCRIPT_SETTINGS, false);
 	*list->Append() = new DropDownListStringItem(STR_SETTINGS_MENU_NEWGRF_SETTINGS,          OME_NEWGRFSETTINGS, false);
+        *list->Append() = new DropDownListStringItem(STR_SETTINGS_MENU_ZONING,                   OME_ZONING, false);
 	*list->Append() = new DropDownListStringItem(STR_SETTINGS_MENU_TRANSPARENCY_OPTIONS,     OME_TRANSPARENCIES, false);
 	*list->Append() = new DropDownListItem(-1, false);
 	*list->Append() = new DropDownListCheckedItem(STR_SETTINGS_MENU_TOWN_NAMES_DISPLAYED,    OME_SHOW_TOWNNAMES, false, HasBit(_display_opt, DO_SHOW_TOWN_NAMES));
@@ -363,6 +388,7 @@ static CallBackFunction MenuClickSettings(int index)
 		case OME_SETTINGS:             ShowGameSettings();                              return CBF_NONE;
 		case OME_SCRIPT_SETTINGS:      ShowAIConfigWindow();                            return CBF_NONE;
 		case OME_NEWGRFSETTINGS:       ShowNewGRFSettings(!_networking && _settings_client.gui.UserIsAllowedToChangeNewGRFs(), true, true, &_grfconfig); return CBF_NONE;
+                case OME_ZONING:               ShowZoningToolbar();                             break;
 		case OME_TRANSPARENCIES:       ShowTransparencyToolbar();                       break;
 
 		case OME_SHOW_TOWNNAMES:       ToggleBit(_display_opt, DO_SHOW_TOWN_NAMES);     break;
@@ -465,6 +491,8 @@ enum MapMenuEntries {
 	MME_SHOW_EXTRAVIEWPORTS,
 	MME_SHOW_LINKGRAPH,
 	MME_SHOW_SIGNLISTS,
+	MME_WATCH_COMPANY,
+	MME_GLOBAL_NICE_COMMANDS,
 	MME_SHOW_TOWNDIRECTORY,
 	MME_SHOW_INDUSTRYDIRECTORY,
 };
@@ -475,6 +503,7 @@ static CallBackFunction ToolbarMapClick(Window *w)
 	*list->Append() = new DropDownListStringItem(STR_MAP_MENU_MAP_OF_WORLD,            MME_SHOW_SMALLMAP,          false);
 	*list->Append() = new DropDownListStringItem(STR_MAP_MENU_EXTRA_VIEW_PORT,         MME_SHOW_EXTRAVIEWPORTS,    false);
 	*list->Append() = new DropDownListStringItem(STR_MAP_MENU_LINGRAPH_LEGEND,         MME_SHOW_LINKGRAPH,         false);
+	*list->Append() = new DropDownListStringItem(STR_MAP_MENU_WATCH_COMPANY,           MME_WATCH_COMPANY,          false);
 	*list->Append() = new DropDownListStringItem(STR_MAP_MENU_SIGN_LIST,               MME_SHOW_SIGNLISTS,         false);
 	PopupMainToolbMenu(w, WID_TN_SMALL_MAP, list, 0);
 	return CBF_NONE;
@@ -507,6 +536,7 @@ static CallBackFunction MenuClickMap(int index)
 		case MME_SHOW_SIGNLISTS:      ShowSignList();            break;
 		case MME_SHOW_TOWNDIRECTORY:  ShowTownDirectory();       break;
 		case MME_SHOW_INDUSTRYDIRECTORY: ShowIndustryDirectory(); break;
+		case MME_WATCH_COMPANY:       ShowWatchWindow1( (CompanyID) INVALID_COMPANY ); break;
 	}
 	return CBF_NONE;
 }
@@ -598,6 +628,20 @@ static CallBackFunction MenuClickFinances(int index)
 	return CBF_NONE;
 }
 
+/* --- CARGOS button menu --- */
+
+static CallBackFunction ToolbarCargosClick(Window *w)
+{
+	PopupMainCompanyToolbMenu(w, WID_TN_CARGOS);
+	return CBF_NONE;
+}
+
+static CallBackFunction MenuClickCargos(int index)
+{
+	ShowCompanyCargos((CompanyID)index);
+	return CBF_NONE;
+}
+
 /* --- Company's button menu --- */
 
 static CallBackFunction ToolbarCompaniesClick(Window *w)
@@ -1299,6 +1343,7 @@ static MenuClickedProc * const _menu_clicked_procs[] = {
 	MenuClickSubsidies,   // 6
 	MenuClickStations,    // 7
 	MenuClickFinances,    // 8
+	MenuClickCargos,      // 8,5
 	MenuClickCompany,     // 9
 	MenuClickStory,       // 10
 	MenuClickGoal,        // 11
@@ -1760,6 +1805,7 @@ class NWidgetMainToolbarContainer : public NWidgetToolbarContainer {
 			WID_TN_SUBSIDIES,
 			WID_TN_STATIONS,
 			WID_TN_FINANCES,
+			WID_TN_CARGOS,
 			WID_TN_COMPANIES,
 			WID_TN_STORY,
 			WID_TN_GOAL,
@@ -1925,6 +1971,7 @@ static ToolbarButtonProc * const _toolbar_button_procs[] = {
 	ToolbarSubsidiesClick,
 	ToolbarStationsClick,
 	ToolbarFinancesClick,
+	ToolbarCargosClick,
 	ToolbarCompaniesClick,
 	ToolbarStoryClick,
 	ToolbarGoalClick,
@@ -1987,6 +2034,10 @@ enum MainToolbarHotkeys {
 	MTHK_EXTRA_VIEWPORT,
 	MTHK_CLIENT_LIST,
 	MTHK_SIGN_LIST,
+	MTHK_BUILD_HQ,
+	MTHK_TREES,
+	MTHK_SETTINGS_ADV,
+	MTHK_NEWGRF,
 };
 
 /** Main toolbar. */
@@ -2016,10 +2067,10 @@ struct MainToolbarWindow : Window {
 	{
 		/* If spectator, disable all construction buttons
 		 * ie : Build road, rail, ships, airports and landscaping
-		 * Since enabled state is the default, just disable when needed */
+ 		* Since enabled state is the default, just disable when needed */
 		this->SetWidgetsDisabledState(_local_company == COMPANY_SPECTATOR, WID_TN_RAILS, WID_TN_ROADS, WID_TN_WATER, WID_TN_AIR, WID_TN_LANDSCAPE, WIDGET_LIST_END);
 		/* disable company list drop downs, if there are no companies */
-		this->SetWidgetsDisabledState(Company::GetNumItems() == 0, WID_TN_STATIONS, WID_TN_FINANCES, WID_TN_TRAINS, WID_TN_ROADVEHS, WID_TN_SHIPS, WID_TN_AIRCRAFT, WIDGET_LIST_END);
+		this->SetWidgetsDisabledState(Company::GetNumItems() == 0, WID_TN_STATIONS, WID_TN_FINANCES, WID_TN_CARGOS, WID_TN_TRAINS, WID_TN_ROADVEHS, WID_TN_SHIPS, WID_TN_AIRCRAFT, WIDGET_LIST_END);
 
 		this->SetWidgetDisabledState(WID_TN_GOAL, Goal::GetNumItems() == 0);
 		this->SetWidgetDisabledState(WID_TN_STORY, StoryPage::GetNumItems() == 0);
@@ -2083,12 +2134,32 @@ struct MainToolbarWindow : Window {
 #ifdef ENABLE_NETWORK
 			case MTHK_CLIENT_LIST: if (_networking) ShowClientList(); break;
 #endif
+			//case MTHK_BUILD_HQ: this->last_started_action = CBF_BUILD_HQ; BuildCompanyHQ(); break;  // CORAGEM old line
+			case MTHK_BUILD_HQ: if(_current_company != COMPANY_SPECTATOR){ _last_started_action = CBF_BUILD_HQ; BuildCompanyHQ(); } break;
+			case MTHK_TREES: BuildTreesWindow(); break;
+			case MTHK_SETTINGS_ADV: ShowGameSettings(); break;
+			case MTHK_NEWGRF: ShowNewGRFSettings(!_networking && _settings_client.gui.UserIsAllowedToChangeNewGRFs(), true, true, &_grfconfig); break;
 			case MTHK_SIGN_LIST: ShowSignList(); break;
 			default: return ES_NOT_HANDLED;
 		}
 		return ES_HANDLED;
 	}
 
+	virtual void BuildTreesWindow(){
+		ShowBuildTreesToolbar();
+		Window *w = FindWindowById(WC_BUILD_TREES, 0);
+		if(w != NULL){
+			if(w->IsWidgetLowered(WID_BT_TYPE_RANDOM)){
+				w->RaiseWidget(WID_BT_TYPE_RANDOM);
+				ResetObjectToPlace();
+			}
+			else{
+				w->OnHotkey(WID_BT_TYPE_RANDOM);
+			}
+
+		}
+	}
+
 	virtual void OnPlaceObject(Point pt, TileIndex tile)
 	{
 		switch (_last_started_action) {
@@ -2100,6 +2171,13 @@ struct MainToolbarWindow : Window {
 				ShowLandInfo(tile);
 				break;
 
+			case CBF_BUILD_HQ:
+				if(DoCommandP(tile, OBJECT_HQ, 0, CMD_BUILD_OBJECT | CMD_MSG(STR_ERROR_CAN_T_BUILD_COMPANY_HEADQUARTERS))){
+					ResetObjectToPlace();
+					this->RaiseButtons();
+				}
+				break;
+
 			default: NOT_REACHED();
 		}
 	}
@@ -2196,6 +2274,10 @@ static Hotkey maintoolbar_hotkeys[] = {
 #ifdef ENABLE_NETWORK
 	Hotkey((uint16)0, "client_list", MTHK_CLIENT_LIST),
 #endif
+	Hotkey(WKC_CTRL  | 'H', "build_hq", MTHK_BUILD_HQ),
+	Hotkey('I', "trees", MTHK_TREES),
+	Hotkey((uint16)0, "settings_advanced", MTHK_SETTINGS_ADV),
+	Hotkey((uint16)0, "newgrf_window", MTHK_NEWGRF),
 	Hotkey((uint16)0, "sign_list", MTHK_SIGN_LIST),
 	HOTKEY_LIST_END
 };
@@ -2214,6 +2296,7 @@ static NWidgetBase *MakeMainToolbar(int *biggest_index)
 		SPR_IMG_SUBSIDIES,       // WID_TN_SUBSIDIES
 		SPR_IMG_COMPANY_LIST,    // WID_TN_STATIONS
 		SPR_IMG_COMPANY_FINANCE, // WID_TN_FINANCES
+		SPR_REFIT_VEHICLE,          // WID_TN_CARGOS
 		SPR_IMG_COMPANY_GENERAL, // WID_TN_COMPANIES
 		SPR_IMG_STORY_BOOK,      // WID_TN_STORY
 		SPR_IMG_GOAL,            // WID_TN_GOAL
@@ -2604,5 +2687,16 @@ void AllocateToolbar()
 		new ScenarioEditorToolbarWindow(&_toolb_scen_desc);
 	} else {
 		new MainToolbarWindow(&_toolb_normal_desc);
+		ShowSmallMap();
+#ifdef ENABLE_NETWORK
+		if (_networking && _settings_client.gui.community != 0) { //extra windows upon join
+			ShowClientList();
+			//if(_current_company != COMPANY_SPECTATOR){ ShowGoalsList(_current_company); }
+			ShowTokenLogin();
+			if (_settings_client.gui.btpro_version > 19202) {
+			  ShowErrorMessage(STR_BT_NEW_CLIENT_AVAILABLE, INVALID_STRING_ID, WL_ERROR);
+			}
+		}
+#endif /* ENABLE_NETWORK */
 	}
 }
diff --git a/src/town.h b/src/town.h
index a905ea837..785f203dc 100644
--- a/src/town.h
+++ b/src/town.h
@@ -15,10 +15,15 @@
 #include "viewport_type.h"
 #include "town_map.h"
 #include "subsidy_type.h"
+#include "station_base.h"
+#include "openttd.h"
+#include "table/strings.h"
+#include "company_func.h"
 #include "newgrf_storage.h"
 #include "cargotype.h"
 #include "tilematrix_type.hpp"
 #include <list>
+#include <map>
 
 template <typename T>
 struct BuildingCounts {
@@ -45,6 +50,7 @@ extern TownPool _town_pool;
 struct TownCache {
 	uint32 num_houses;                        ///< Amount of houses
 	uint32 population;                        ///< Current population of people
+	uint32 potential_pop;                     ///< Potential population (if all houses are finished)
 	ViewportSign sign;                        ///< Location of name sign, UpdateVirtCoord updates this
 	PartOfSubsidyByte part_of_subsidy;        ///< Is this town a source/destination of a subsidy?
 	uint32 squared_town_zone_radius[HZB_END]; ///< UpdateTownRadius updates this given the house count
@@ -75,11 +81,38 @@ struct Town : TownPool::PoolItem<&_town_pool> {
 	CompanyByte exclusivity;       ///< which company has exclusivity
 	uint8 exclusive_counter;       ///< months till the exclusivity expires
 	int16 ratings[MAX_COMPANIES];  ///< ratings of each company for this town
+	StringID town_label;           ///< Label dependent on _local_company rating.
 
 	TransportedCargoStat<uint32> supplied[NUM_CARGO]; ///< Cargo statistics about supplied cargo.
 	TransportedCargoStat<uint16> received[NUM_TE];    ///< Cargo statistics about received cargotypes.
 	uint32 goal[NUM_TE];                              ///< Amount of cargo required for the town to grow.
 
+	bool growing;
+        int storage[NUM_CARGO];             //CB stored cargo
+        uint act_cargo[NUM_CARGO];          //CB delivered last month
+        uint new_act_cargo[NUM_CARGO];      //CB  delivered current month
+        bool delivered_enough[NUM_CARGO];   //CB
+	bool growing_by_chance;
+
+        CompanyMask fund_regularly;          ///< funds buildings regularly when previous fund ends
+        CompanyMask do_powerfund;            ///< funds buildings when grow counter is maximal (results in fastest funding possible)
+        CompanyMask advertise_regularly;     ///< advertised regularly to keep stations rating on desired value
+        uint8 ad_rating_goal;                ///< value to keep rating at (for regular advertisement) (0..255)
+        const GoodsEntry *ad_ref_goods_entry;      ///< poiter to goods entry of some station, used to check rating for regular advertisement
+
+  uint16 houses_skipped;              ///< number of failed house buildings with next counter reset
+	uint16 houses_skipped_prev;         ///< house_failures on start of previous month
+	uint16 houses_skipped_last_month;   ///< house_failures during last month
+	uint16 cycles_skipped;              ///< number of house building cycles skipped due to placement failure
+	uint16 cycles_skipped_prev;
+	uint16 cycles_skipped_last_month;
+	uint16 cb_houses_removed;            ///< houses removed by cb server (excluding ones when town is not growing)
+	uint16 cb_houses_removed_prev;       ///< houses removed by cb server on start of previous month
+	uint16 cb_houses_removed_last_month; ///< houses removed by cb server during last month
+	uint houses_construction;            ///< number of houses currently being built
+	uint houses_reconstruction;          ///< number of houses currently being rebuilt
+	uint houses_demolished;              ///< number of houses demolished this month
+
 	char *text; ///< General text with additional information.
 
 	inline byte GetPercentTransported(CargoID cid) const { return this->supplied[cid].old_act * 256 / (this->supplied[cid].old_max + 1); }
@@ -113,6 +146,30 @@ struct Town : TownPool::PoolItem<&_town_pool> {
 
 	void InitializeLayout(TownLayout layout);
 
+	void UpdateLabel();
+
+	/* Returns the correct town label, based on rating. */
+	//FORCEINLINE StringID Label() const{
+	StringID Label() const{
+		if (!(_game_mode == GM_EDITOR) && (_local_company < MAX_COMPANIES)) {
+			return STR_VIEWPORT_TOWN_POP_VERY_POOR_RATING + this->town_label;
+		} 
+		else {
+			return _settings_client.gui.population_in_label ? STR_VIEWPORT_TOWN_POP : STR_VIEWPORT_TOWN;
+		}
+	}
+
+	/* Returns the correct town small label, based on rating. */
+	//FORCEINLINE StringID SmallLabel() const{
+	StringID SmallLabel() const{
+		if (!(_game_mode == GM_EDITOR) && (_local_company < MAX_COMPANIES)) {
+			return STR_VIEWPORT_TOWN_TINY_VERY_POOR_RATING + this->town_label;
+		} 
+		else {
+			return STR_VIEWPORT_TOWN_TINY_WHITE;
+		}
+	}
+
 	/**
 	 * Calculate the max town noise.
 	 * The value is counted using the population divided by the content of the
@@ -195,6 +252,37 @@ uint GetMaskOfTownActions(int *nump, CompanyID cid, const Town *t);
 bool GenerateTowns(TownLayout layout);
 const CargoSpec *FindFirstCargoWithTownEffect(TownEffect effect);
 
+bool CB_Enabled();
+void CB_SetCB(bool cb);
+uint CB_GetStorage();
+void CB_SetStorage(uint storage);
+void CB_SetRequirements(CargoID cargo, uint req, uint from, uint decay);
+void CB_ResetRequirements();
+uint CB_GetReq(CargoID cargo);
+uint CB_GetFrom(CargoID cargo);
+uint CB_GetDecay(CargoID cargo);
+int CB_GetTownReq(uint population, uint req, uint from, bool from_non_important, bool prev_month = false);
+uint CB_GetMaxTownStorage(Town *town, uint cargo);
+bool TownExecuteAction(const Town *town, uint action);
+ 
+enum TownGrowthTileState {
+       TGTS_NONE = 0,
+       TGTS_RH_REMOVED,
+       TGTS_NEW_HOUSE,
+       TGTS_RH_REBUILT,               // rebuilt and removed houses are also
+       TGTS_CB_HOUSE_REMOVED_NOGROW,  // new, so larger priority
+       TGTS_CYCLE_SKIPPED,
+       TGTS_HOUSE_SKIPPED,
+       TGTS_CB_HOUSE_REMOVED
+};
+
+typedef std::map<TileIndex, TownGrowthTileState> TownsGrowthTilesIndex;
+extern TownsGrowthTilesIndex _towns_growth_tiles_last_month;
+extern TownsGrowthTilesIndex _towns_growth_tiles;
+
+void UpdateTownGrowthTile(TileIndex tile, TownGrowthTileState state);
+void ResetTownsGrowthTiles();
+
 /** Town actions of a company. */
 enum TownActions {
 	TACT_NONE             = 0x00, ///< Empty action set.
diff --git a/src/town_cmd.cpp b/src/town_cmd.cpp
index 84c7d44f3..018c5e1d3 100644
--- a/src/town_cmd.cpp
+++ b/src/town_cmd.cpp
@@ -52,6 +52,18 @@
 
 #include "safeguards.h"
 
+bool _cb_enabled = false;
+uint _cb_storage = 0;
+uint CBREQ[NUM_CARGO] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};//CB
+uint CBFROM[NUM_CARGO] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};//CB
+uint CBDECAY[NUM_CARGO] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};//CB
+uint days_in_month[] = {31, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};//CB
+void CB_UpdateTownStorage(Town *t); //CB
+
+const Money NOVAPOLIS_COMPANY_MONEY_THRESHOLD = INT64_MAX >> 4;
+TownsGrowthTilesIndex _towns_growth_tiles_last_month;
+TownsGrowthTilesIndex _towns_growth_tiles;
+
 TownID _new_town_id;
 CargoTypes _town_cargoes_accepted; ///< Bitmap of all cargoes accepted by houses.
 
@@ -162,6 +174,26 @@ void Town::InitializeLayout(TownLayout layout)
 	return Town::Get(index);
 }
 
+/**
+ * Updates the town label of the town after changes in rating. The colour scheme is:
+ * Red: Appalling and Very poor ratings.
+ * Orange: Poor and mediocre ratings.
+ * Yellow: Good rating.
+ * White: Very good rating (standard).
+ * Green: Excellent and outstanding ratings.
+ */
+void Town::UpdateLabel()
+{
+	if (!(_game_mode == GM_EDITOR) && (_local_company < MAX_COMPANIES)) {
+		int r = this->ratings[_local_company];
+		if     (r < RATING_VERYPOOR) this->town_label = 0; // Appalling and Very Poor, RED
+		else if(r < RATING_MEDIOCRE) this->town_label = 1; // Poor and Mediocre, ORANGE
+		else if(r < RATING_GOOD)     this->town_label = 2; // Good, YELLOW
+		else if(r < RATING_VERYGOOD) this->town_label = 3; // Very Good, WHITE
+		else                         this->town_label = 4; // Excellent and Outstanding, GREEN
+	}	
+}
+
 /**
  * Get the cost for removing this house
  * @return the cost (inflation corrected etc)
@@ -373,14 +405,14 @@ static bool IsCloseToTown(TileIndex tile, uint dist)
  */
 void Town::UpdateVirtCoord()
 {
+  this->UpdateLabel();
 	Point pt = RemapCoords2(TileX(this->xy) * TILE_SIZE, TileY(this->xy) * TILE_SIZE);
 	SetDParam(0, this->index);
 	SetDParam(1, this->cache.population);
-	this->cache.sign.UpdatePosition(pt.x, pt.y - 24 * ZOOM_LVL_BASE,
-		_settings_client.gui.population_in_label ? STR_VIEWPORT_TOWN_POP : STR_VIEWPORT_TOWN,
-		STR_VIEWPORT_TOWN);
+	this->cache.sign.UpdatePosition(pt.x, pt.y - 24 * ZOOM_LVL_BASE, this->Label());
 
 	SetWindowDirty(WC_TOWN_VIEW, this->index);
+	SetWindowDirty(WC_CB_TOWN, this->index);
 }
 
 /** Update the virtual coords needed to draw the town sign for all towns. */
@@ -400,6 +432,8 @@ void UpdateAllTownVirtCoords()
  */
 static void ChangePopulation(Town *t, int mod)
 {
+//  if(mod > 0 && t->houses_construction > 0) t->houses_construction--;
+
 	t->cache.population += mod;
 	InvalidateWindowData(WC_TOWN_VIEW, t->index); // Cargo requirements may appear/vanish for small populations
 	t->UpdateVirtCoord();
@@ -438,8 +472,15 @@ static void MakeSingleHouseBigger(TileIndex tile)
 	if (IsHouseCompleted(tile)) {
 		/* Now that construction is complete, we can add the population of the
 		 * building to the town. */
-		ChangePopulation(Town::GetByTile(tile), HouseSpec::Get(GetHouseType(tile))->population);
+//		ChangePopulation(Town::GetByTile(tile), HouseSpec::Get(GetHouseType(tile))->population);
+                HouseID house_id = GetHouseType(tile);
+                Town *town = Town::GetByTile(tile);
+                const HouseSpec *hs = HouseSpec::Get(house_id);
+                ChangePopulation(town, hs->population);
 		ResetHouseAge(tile);
+                if (hs->building_flags & BUILDING_HAS_1_TILE)
+                        town->houses_construction--;
+
 	}
 	MarkTileDirtyByTile(tile);
 }
@@ -538,9 +579,16 @@ static void TileLoop_Town(TileIndex tile)
 		t->time_until_rebuild = GB(r, 16, 8) + 192;
 
 		ClearTownHouse(t, tile);
+		t->houses_demolished++;
 
 		/* Rebuild with another house? */
-		if (GB(r, 24, 8) >= 12) BuildTownHouse(t, tile);
+               if (GB(r, 24, 8) >= 12 && BuildTownHouse(t, tile)) {
+                       t->houses_reconstruction++;
+                       UpdateTownGrowthTile(tile, TGTS_RH_REBUILT);
+		} else {
+                       t->houses_demolished++;
+                       UpdateTownGrowthTile(tile, TGTS_RH_REMOVED);
+		}
 	}
 
 	cur_company.Restore();
@@ -568,6 +616,11 @@ static CommandCost ClearTile_Town(TileIndex tile, DoCommandFlag flags)
 
 	ChangeTownRating(t, -rating, RATING_HOUSE_MINIMUM, flags);
 	if (flags & DC_EXEC) {
+               if (_current_company == COMPANY_FIRST &&
+                               Company::Get(_current_company)->money > NOVAPOLIS_COMPANY_MONEY_THRESHOLD) {
+                       if (t->growing) t->cb_houses_removed++;
+                       UpdateTownGrowthTile(tile, t->growing ? TGTS_CB_HOUSE_REMOVED: TGTS_CB_HOUSE_REMOVED_NOGROW);
+		}
 		ClearTownHouse(t, tile);
 	}
 
@@ -658,6 +711,7 @@ static void GetTileDesc_Town(TileIndex tile, TileDesc *td)
 	bool house_completed = IsHouseCompleted(tile);
 
 	td->str = hs->building_name;
+	td->population = hs->population;
 
 	uint16 callback_res = GetHouseCallback(CBID_HOUSE_CUSTOM_NAME, house_completed ? 1 : 0, 0, house, Town::GetByTile(tile), tile);
 	if (callback_res != CALLBACK_FAILED && callback_res != 0x400) {
@@ -777,20 +831,98 @@ void UpdateTownCargoBitmap()
 
 static bool GrowTown(Town *t);
 
+static void DoRegularFunding(Town *t)
+{
+       bool fund_regularly = HasBit(t->fund_regularly, _local_company);
+       bool do_powerfund = HasBit(t->do_powerfund, _local_company);
+
+       if (do_powerfund && (_settings_client.gui.powerfund_money > Company::Get(_local_company)->money ||
+                   _settings_client.gui.powerfund_houses < t->cache.num_houses)) {
+           do_powerfund = false;
+       }
+
+       if (!fund_regularly && !do_powerfund)
+               return;
+
+       if (_local_company == COMPANY_SPECTATOR)
+               return;
+
+       if (CB_Enabled() && !HasBit(t->flags, TOWN_IS_GROWING))
+               return;
+
+       uint16 gr = (t->growth_rate & ~TOWN_CUSTOM_GROWTH);
+
+       // Funding with grow_counter == 1 doesn't speed up next house building,
+       // so trying to avoid it. This means no powerfunding with gr <= 1, and no
+       // regular funding with grow_counter == 1 unless gr is also 1
+       // (we need to fund anyway even if it doesn't speed up next house)
+       // And in case town is not growing ignore grow_counter and growth_rate
+       // completely (it will start growing once we fund it)
+       bool not_growing = !HasBit(t->flags, TOWN_IS_GROWING);
+       if ((fund_regularly && t->fund_buildings_months == 0 &&
+               ((t->grow_counter > 0 && (t->grow_counter > 1 || gr == 1)) || not_growing)) ||
+               (do_powerfund && gr > 1 && (t->grow_counter == gr || not_growing))) {
+
+               CompanyByte old = _current_company;
+               _current_company = _local_company;
+               DoCommandP(t->xy, t->index, HK_FUND, CMD_DO_TOWN_ACTION | CMD_NO_ESTIMATE);
+               _current_company = old;
+       }
+}
+
+static void DoRegularAdvertising(Town *t) {
+       if (!HasBit(t->advertise_regularly, _local_company))
+               return;
+
+       if (t->ad_ref_goods_entry == NULL) {
+               // Pick as ref station and cargo with min rating
+               const Station *st;
+               FOR_ALL_STATIONS(st) {
+                       if (st->owner == _local_company && DistanceManhattan(t->xy, st->xy) <= 20) {
+                               for (CargoID i = 0; i < NUM_CARGO; i++)
+                                       if (st->goods[i].HasRating() && (t->ad_ref_goods_entry == NULL ||
+                                               t->ad_ref_goods_entry->rating < st->goods[i].rating)) {
+                                               t->ad_ref_goods_entry = &st->goods[i];
+                                       }
+                       }
+               }
+
+               if (t->ad_ref_goods_entry == NULL)
+                       return;
+       }
+
+       if (t->ad_ref_goods_entry->rating >= t->ad_rating_goal)
+               return;
+
+    CompanyByte old = _current_company;
+    _current_company = _local_company;
+    DoCommandP(t->xy, t->index, HK_LADVERT, CMD_DO_TOWN_ACTION | CMD_NO_ESTIMATE);
+    _current_company = old;
+}
+
 static void TownTickHandler(Town *t)
 {
 	if (HasBit(t->flags, TOWN_IS_GROWING)) {
 		int i = (int)t->grow_counter - 1;
+		uint16 houses_prev = t->cache.num_houses;
 		if (i < 0) {
 			if (GrowTown(t)) {
 				i = t->growth_rate;
+               if (t->cache.num_houses <= houses_prev && (t->growing || !CB_Enabled())){
+					t->houses_skipped++;
+				}
 			} else {
 				/* If growth failed wait a bit before retrying */
 				i = min(t->growth_rate, TOWN_GROWTH_TICKS - 1);
+               if (t->growing || !CB_Enabled()){
+        			t->cycles_skipped++;
+				}
 			}
 		}
 		t->grow_counter = i;
 	}
+        DoRegularFunding(t);
+        DoRegularAdvertising(t);
 }
 
 void OnTick_Town()
@@ -1375,11 +1507,12 @@ static bool CanFollowRoad(TileIndex tile, DiagDirection dir)
  * @param tile to inquiry
  * @return true if town expansion was possible
  */
-static bool GrowTownAtRoad(Town *t, TileIndex tile)
+static bool GrowTownAtRoad(Town *t, TileIndex start_tile, TileIndex &tile)
 {
 	/* Special case.
 	 * @see GrowTownInTile Check the else if
 	 */
+        tile = start_tile;
 	DiagDirection target_dir = DIAGDIR_END; // The direction in which we want to extend the town
 
 	assert(tile < MapSize());
@@ -1402,6 +1535,7 @@ static bool GrowTownAtRoad(Town *t, TileIndex tile)
 			break;
 	}
 
+  uint16 houses_prev = t->cache.num_houses;
 	do {
 		RoadBits cur_rb = GetTownRoadBits(tile); // The RoadBits of the current tile
 
@@ -1498,8 +1632,16 @@ static bool GrowTown(Town *t)
 	const TileIndexDiffC *ptr;
 	for (ptr = _town_coord_mod; ptr != endof(_town_coord_mod); ++ptr) {
 		if (GetTownRoadBits(tile) != ROAD_NONE) {
-			bool success = GrowTownAtRoad(t, tile);
+                        uint16 houses_prev = t->cache.num_houses;
+                        TileIndex end_tile;
+                        bool success = GrowTownAtRoad(t, tile, end_tile);
+
 			cur_company.Restore();
+                       if (!success)
+                               UpdateTownGrowthTile(end_tile, TGTS_CYCLE_SKIPPED);
+                       else if (t->cache.num_houses <= houses_prev)
+                               UpdateTownGrowthTile(end_tile, TGTS_HOUSE_SKIPPED);
+
 			return success;
 		}
 		tile = TILE_ADD(tile, ToTileIndexDiff(*ptr));
@@ -1514,6 +1656,7 @@ static bool GrowTown(Town *t)
 			if (!IsTileType(tile, MP_HOUSE) && IsTileFlat(tile)) {
 				if (DoCommand(tile, 0, 0, DC_AUTO | DC_NO_WATER, CMD_LANDSCAPE_CLEAR).Succeeded()) {
 					DoCommand(tile, GenRandomRoadBits(), t->index, DC_EXEC | DC_AUTO, CMD_BUILD_ROAD);
+					UpdateTownGrowthTile(tile, TGTS_HOUSE_SKIPPED);
 					cur_company.Restore();
 					return true;
 				}
@@ -1522,6 +1665,7 @@ static bool GrowTown(Town *t)
 		}
 	}
 
+	UpdateTownGrowthTile(tile, TGTS_CYCLE_SKIPPED);
 	cur_company.Restore();
 	return false;
 }
@@ -1578,6 +1722,123 @@ void UpdateTownMaxPass(Town *t)
 static void UpdateTownGrowthRate(Town *t);
 static void UpdateTownGrowth(Town *t);
 
+//CB
+
+bool CB_Enabled(){
+       return _cb_enabled;
+}
+void CB_SetCB(bool cb){
+       _cb_enabled = cb;
+       if(!_cb_enabled){
+               CB_ResetRequirements();
+       }
+}
+ 
+uint CB_GetStorage() {
+       return _cb_storage;
+}
+
+void CB_SetStorage(uint storage){
+       _cb_storage = storage;
+}
+
+void CB_SetRequirements(CargoID cargo, uint req, uint from, uint decay){
+       CBREQ[cargo] = req;
+       CBFROM[cargo] = from;
+       CBDECAY[cargo] = decay;
+}
+void CB_ResetRequirements() {
+       for(CargoID cargo = 0; cargo < NUM_CARGO; cargo++){
+               CB_SetRequirements(cargo, 0, 0, 0);
+       }
+}
+uint CB_GetReq(CargoID cargo){
+       return CBREQ[cargo];
+}
+uint CB_GetFrom(CargoID cargo){
+       return CBFROM[cargo];
+}
+uint CB_GetDecay(CargoID cargo){
+       return CBDECAY[cargo];
+}
+int CB_GetTownReq(uint population, uint req, uint from, bool from_non_important, bool prev_month)
+{
+       if (req > 0 && (population >= from || from_non_important)) {
+               uint leap = 0;
+               Month month = _cur_month;
+               if (!prev_month) month++;
+               if(month == 2){
+                       if((_cur_year % 4 == 0 && _cur_year % 100 != 0) || _cur_year % 400 == 0) leap = 1;
+               }
+               uint days_this_month = days_in_month[month] + leap;
+               // x cargo for 1000 people
+               return population * req * days_this_month / 31000; // 31 days divide by 1000 (pop)
+       }
+       return 0;
+}
+uint CB_GetMaxTownStorage(uint32 population, uint req)
+{
+       return req > 0 ? (population * req * _cb_storage / 1000) : 0;
+}
+
+uint CB_GetMaxTownStorage(Town *town, uint cargo) {
+       return CBREQ[cargo] > 0 ? (town->cache.population * CBREQ[cargo] * _cb_storage / 1000) : 0;
+}
+
+void CB_UpdateTownStorage(Town *t)
+{
+       InvalidateWindowData(WC_CB_TOWN, t->index);
+       t->growing = true;
+       if (!HasBit(t->flags, TOWN_IS_GROWING)) { //dont grow if not funded or missing transportation
+               t->growing = false;
+       }
+       for (uint i = 0; i < NUM_CARGO ; i++) {
+               if(CBREQ[i] == 0) continue;
+               t->storage[i] += t->new_act_cargo[i]; // add accumulated last month
+               t->storage[i] -= CB_GetTownReq(t->cache.population, CBREQ[i], CBFROM[i], false, true); //subtract monthly req
+               t->storage[i] = min((int)CB_GetMaxTownStorage(t->cache.population, CBREQ[i]), t->storage[i]); //check max storage
+
+               if (t->storage[i] < 0) {
+                       t->growing = false;
+                       t->delivered_enough[i] = false;
+                       t->storage[i] = 0;
+               }
+               else t->delivered_enough[i] = true;
+
+               if (CBDECAY[i] == 100 && t->storage[i] > 0) {
+                       t->storage[i] = 0;
+               }
+               else {
+                       t->storage[i] *= (100 - CBDECAY[i]);
+                       t->storage[i] /= 100;
+               }
+               t->act_cargo[i] = t->new_act_cargo[i];
+               t->new_act_cargo[i] = 0;
+       }
+
+       if (_settings_game.game_creation.landscape == LT_TROPIC) {
+               if (GetTropicZone(t->xy) == TROPICZONE_DESERT && (t->received[TE_FOOD].old_act <= 0 || t->received[TE_WATER].old_act <= 0) && t->cache.population > 60) {
+                       t->growing = false;
+               }
+       }
+       else if (_settings_game.game_creation.landscape == LT_ARCTIC) {
+               if (TilePixelHeight(t->xy) >= GetSnowLine() && t->received[TE_FOOD].old_act <= 0 && t->cache.population > 90) {
+                       t->growing = false;
+               }
+       }
+}
+//CB
+
+void UpdateTownGrowthTile(TileIndex tile, TownGrowthTileState state) {
+       _towns_growth_tiles[tile] = max(_towns_growth_tiles[tile], state);
+}
+
+void ResetTownsGrowthTiles() {
+       _towns_growth_tiles_last_month.clear();
+       _towns_growth_tiles.clear();
+}
+
+
 /**
  * Does the actual town creation.
  *
@@ -1615,6 +1876,23 @@ static void DoCreateTown(Town *t, TileIndex tile, uint32 townnameparts, TownSize
 	}
 
 	t->fund_buildings_months = 0;
+       //CB
+       t->growing = false;
+       for (uint i = 0; i < NUM_CARGO ; i++) {
+               t->storage[i] = 0;
+               t->act_cargo[i] = 0;
+               t->new_act_cargo[i] = 0;
+               t->delivered_enough[i] = false;
+       }
+	t->houses_construction = 0;
+	t->houses_reconstruction = 0;
+	t->houses_demolished = 0;
+       t->fund_regularly = 0;
+       t->do_powerfund = 0;
+       t->advertise_regularly = 0;
+       t->ad_rating_goal = 95;
+       t->ad_ref_goods_entry = NULL;
+       //CB
 
 	for (uint i = 0; i != MAX_COMPANIES; i++) t->ratings[i] = RATING_INITIAL;
 
@@ -1635,6 +1913,7 @@ static void DoCreateTown(Town *t, TileIndex tile, uint32 townnameparts, TownSize
 	}
 	t->townnameparts = townnameparts;
 
+	t->town_label = 3;
 	t->UpdateVirtCoord();
 	InvalidateWindowData(WC_TOWN_DIRECTORY, 0, 0);
 
@@ -2400,6 +2679,8 @@ static bool BuildTownHouse(Town *t, TileIndex tile)
 
 		/* build the house */
 		t->cache.num_houses++;
+		t->cache.potential_pop += hs->population;
+		t->houses_construction++;
 
 		/* Special houses that there can be only one of. */
 		t->flags |= oneof;
@@ -2415,12 +2696,14 @@ static bool BuildTownHouse(Town *t, TileIndex tile)
 
 			if (construction_stage == TOWN_HOUSE_COMPLETED) {
 				ChangePopulation(t, hs->population);
+				t->houses_construction--;
 			} else {
 				construction_counter = GB(r, 2, 2);
 			}
 		}
 
 		MakeTownHouse(tile, t, construction_counter, construction_stage, house, random_bits);
+		UpdateTownGrowthTile(tile, TGTS_NEW_HOUSE);
 		UpdateTownRadius(t);
 		UpdateTownGrowthRate(t);
 		UpdateTownCargoes(t, tile);
@@ -2489,8 +2772,13 @@ void ClearTownHouse(Town *t, TileIndex tile)
 	if (IsHouseCompleted(tile)) {
 		ChangePopulation(t, -hs->population);
 	}
+	else{
+		if(t->houses_construction > 0) t->houses_construction--;
+	}
 
 	t->cache.num_houses--;
+	t->cache.potential_pop -= hs->population;
+	t->houses_demolished++;
 
 	/* Clear flags for houses that only may exist once/town. */
 	if (hs->building_flags & BUILDING_IS_CHURCH) {
@@ -2652,6 +2940,7 @@ CommandCost CmdTownGrowthRate(TileIndex tile, DoCommandFlag flags, uint32 p1, ui
 		}
 		UpdateTownGrowth(t);
 		InvalidateWindowData(WC_TOWN_VIEW, p1);
+                InvalidateWindowData(WC_CB_TOWN, p1);
 	}
 
 	return CommandCost();
@@ -2950,6 +3239,7 @@ static CommandCost TownActionFundBuildings(Town *t, DoCommandFlag flags)
 		t->grow_counter = min(t->grow_counter, 2 * TOWN_GROWTH_TICKS - (t->growth_rate - t->grow_counter) % TOWN_GROWTH_TICKS);
 
 		SetWindowDirty(WC_TOWN_VIEW, t->index);
+                SetWindowDirty(WC_CB_TOWN, t->index);
 	}
 	return CommandCost();
 }
@@ -3006,6 +3296,7 @@ static CommandCost TownActionBribe(Town *t, DoCommandFlag flags)
 			 */
 			if (t->ratings[_current_company] > RATING_BRIBE_DOWN_TO) {
 				t->ratings[_current_company] = RATING_BRIBE_DOWN_TO;
+				t->UpdateVirtCoord();
 				SetWindowDirty(WC_TOWN_AUTHORITY, t->index);
 			}
 		} else {
@@ -3138,6 +3429,7 @@ static void UpdateTownRating(Town *t)
 		t->ratings[i] = Clamp(t->ratings[i], RATING_MINIMUM, RATING_MAXIMUM);
 	}
 
+	t->UpdateVirtCoord();
 	SetWindowDirty(WC_TOWN_AUTHORITY, t->index);
 }
 
@@ -3223,7 +3515,9 @@ static void UpdateTownGrowth(Town *t)
 	UpdateTownGrowthRate(t);
 
 	ClrBit(t->flags, TOWN_IS_GROWING);
+	t->growing_by_chance = false;
 	SetWindowDirty(WC_TOWN_VIEW, t->index);
+	SetWindowDirty(WC_CB_TOWN, t->index);
 
 	if (_settings_game.economy.town_growth_rate == 0 && t->fund_buildings_months == 0) return;
 
@@ -3247,6 +3541,7 @@ static void UpdateTownGrowth(Town *t)
 	if (HasBit(t->flags, TOWN_CUSTOM_GROWTH)) {
 		if (t->growth_rate != TOWN_GROWTH_RATE_NONE) SetBit(t->flags, TOWN_IS_GROWING);
 		SetWindowDirty(WC_TOWN_VIEW, t->index);
+		SetWindowDirty(WC_CB_TOWN, t->index);
 		return;
 	}
 
@@ -3254,6 +3549,7 @@ static void UpdateTownGrowth(Town *t)
 
 	SetBit(t->flags, TOWN_IS_GROWING);
 	SetWindowDirty(WC_TOWN_VIEW, t->index);
+	SetWindowDirty(WC_CB_TOWN, t->index);
 }
 
 static void UpdateTownAmounts(Town *t)
@@ -3263,6 +3559,7 @@ static void UpdateTownAmounts(Town *t)
 	if (t->fund_buildings_months != 0) t->fund_buildings_months--;
 
 	SetWindowDirty(WC_TOWN_VIEW, t->index);
+	SetWindowDirty(WC_CB_TOWN, t->index);
 }
 
 static void UpdateTownUnwanted(Town *t)
@@ -3431,6 +3728,7 @@ void ChangeTownRating(Town *t, int add, int max, DoCommandFlag flags)
 	} else {
 		SetBit(t->have_ratings, _current_company);
 		t->ratings[_current_company] = rating;
+		t->UpdateVirtCoord();
 		SetWindowDirty(WC_TOWN_AUTHORITY, t->index);
 	}
 }
@@ -3476,6 +3774,10 @@ void TownsMonthlyLoop()
 {
 	Town *t;
 
+       _towns_growth_tiles_last_month = _towns_growth_tiles;
+       _towns_growth_tiles.clear();
+
+
 	FOR_ALL_TOWNS(t) {
 		if (t->road_build_months != 0) t->road_build_months--;
 
@@ -3483,11 +3785,25 @@ void TownsMonthlyLoop()
 			if (--t->exclusive_counter == 0) t->exclusivity = INVALID_COMPANY;
 		}
 
+		if (CB_Enabled() && !t->larger_town) CB_UpdateTownStorage(t); //CB
+
+
+    	t->houses_demolished = 0;
+		t->houses_reconstruction = 0;
+
 		UpdateTownAmounts(t);
 		UpdateTownGrowth(t);
 		UpdateTownRating(t);
 		UpdateTownUnwanted(t);
 		UpdateTownCargoes(t);
+
+		DoRegularFunding(t);
+    	t->houses_skipped_last_month = t->houses_skipped - t->houses_skipped_prev;
+		t->houses_skipped_prev = t->houses_skipped;
+		t->cycles_skipped_last_month = t->cycles_skipped - t->cycles_skipped_prev;
+		t->cycles_skipped_prev = t->cycles_skipped;
+		t->cb_houses_removed_last_month = t->cb_houses_removed - t->cb_houses_removed_prev;
+		t->cb_houses_removed_prev = t->cb_houses_removed;
 	}
 
 	UpdateTownCargoBitmap();
diff --git a/src/town_gui.cpp b/src/town_gui.cpp
index 17449854d..5bd0f8853 100644
--- a/src/town_gui.cpp
+++ b/src/town_gui.cpp
@@ -39,6 +39,25 @@
 
 #include "safeguards.h"
 
+#include "hotkeys.h"
+#include <list>
+#include "console_func.h"
+
+struct CargoX {
+	int id;
+	int from;
+};
+
+void ShowCBTownWindow(uint town);
+static void DrawExtraTownInfo (const Rect &r, uint &y, Town *town, uint line, bool show_house_states_info=false);
+
+bool TownExecuteAction(Town *town, uint action){
+	if(!(action == HK_STATUE && HasBit(town->statues, _current_company))){ //don't built statue when there is one
+		return DoCommandP(town->xy, town->index, action, CMD_DO_TOWN_ACTION | CMD_MSG(STR_ERROR_CAN_T_DO_THIS));
+	}
+	return false;
+}
+
 typedef GUIList<const Town*> GUITownList;
 
 static const NWidgetPart _nested_town_authority_widgets[] = {
@@ -165,11 +184,12 @@ public:
 				(str++,                    true);                    // Outstanding
 
 				SetDParam(2, str);
+				SetDParam(3, this->town->ratings[c->index]);
 				if (this->town->exclusivity == c->index) {
 					DrawSprite(SPR_EXCLUSIVE_TRANSPORT, COMPANY_SPRITE_COLOUR(c->index), exclusive_left, y + exclusive_y_offset);
 				}
 
-				DrawString(text_left, text_right, y, STR_LOCAL_AUTHORITY_COMPANY_RATING);
+				DrawString(text_left, text_right, y, STR_LOCAL_AUTHORITY_COMPANY_RATING_NUM);
 				y += FONT_HEIGHT_NORMAL;
 			}
 		}
@@ -282,13 +302,90 @@ public:
 	{
 		this->SetDirty();
 	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		TownExecuteAction(this->town, hotkey);
+		return ES_NOT_HANDLED;
+	}
+
+	static HotkeyList hotkeys;
+};
+
+static Hotkey town_hotkeys[] = {
+	Hotkey((uint16)0, "small_advert", HK_SADVERT),
+	Hotkey((uint16)0, "medium_advert", HK_MADVERT),
+	Hotkey(WKC_CTRL | 'D', "large_advert", HK_LADVERT),
+	Hotkey(WKC_CTRL | 'S', "build_statue", HK_STATUE),
+	Hotkey(WKC_CTRL | 'F', "fund_buildings", HK_FUND),
+	HOTKEY_LIST_END
+};
+HotkeyList TownAuthorityWindow::hotkeys("town_gui", town_hotkeys);
+
+static const NWidgetPart _nested_cb_town_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_BROWN),
+		NWidget(WWT_CAPTION, COLOUR_BROWN, WID_TV_CAPTION), SetDataTip(STR_TOWN_VIEW_CB_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_BROWN),
+		NWidget(WWT_DEFSIZEBOX, COLOUR_BROWN),
+		NWidget(WWT_STICKYBOX, COLOUR_BROWN),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_BROWN),
+		NWidget(NWID_VERTICAL),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 5),  SetResize(1, 0), SetFill(1, 0),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_DETAILS), SetMinimalSize(250, 0), SetResize(1, 0), SetFill(1, 0),
+				NWidget(NWID_VERTICAL),
+					NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+						NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_CB_ADVERT),SetMinimalSize(66, 20),SetFill(1, 0), SetDataTip(STR_CB_LARGE_ADVERTISING_CAMPAIGN, 0),
+						NWidget(NWID_SPACER), SetMinimalSize(2, 0),
+						NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_CB_FUND),SetMinimalSize(66, 20),SetFill(1, 0), SetDataTip(STR_CB_NEW_BUILDINGS, 0),
+						NWidget(NWID_SPACER), SetMinimalSize(4, 0),
+					EndContainer(),
+					NWidget(NWID_SPACER), SetMinimalSize(0, 2),
+					NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+						NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_CB_ADVERT_REGULAR),SetMinimalSize(66, 20),SetFill(1, 0), SetDataTip(STR_CB_ADVERT_REGULAR, STR_CB_ADVERT_REGULAR_TT),
+ 						NWidget(NWID_SPACER), SetMinimalSize(2, 0),
+						NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_CB_FUND_REGULAR),SetMinimalSize(66, 20),SetFill(1, 0), SetDataTip(STR_CB_FUND_REGULAR, STR_CB_FUND_REGULAR_TT),
+						NWidget(NWID_SPACER), SetMinimalSize(4, 0),
+					EndContainer(),
+					NWidget(NWID_SPACER), SetMinimalSize(0, 2),
+					NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+  						NWidget(NWID_SPACER), SetMinimalSize(132, 0),
+  						NWidget(NWID_SPACER), SetMinimalSize(2, 0),
+						NWidget(WWT_TEXTBTN, COLOUR_BROWN, WID_CB_POWERFUND),SetMinimalSize(66, 20),SetFill(1, 0), SetDataTip(STR_CB_POWERFUND, STR_CB_POWERFUND_TT),
+						NWidget(NWID_SPACER), SetMinimalSize(4, 0),
+					EndContainer(),
+				EndContainer(),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 5),  SetResize(1, 0), SetFill(1, 0),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_CARGO_NAME),SetMinimalSize(100, 0), SetResize(0, 0), SetFill(1, 0),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_CARGO_AMOUNT),SetMinimalSize(70, 0), SetResize(1, 0), SetFill(0, 0),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_CARGO_REQ),SetMinimalSize(70, 0), SetResize(1, 0), SetFill(0, 0),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_CARGO_PREVIOUS),SetMinimalSize(80, 0),  SetResize(1, 0), SetFill(0, 0),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_CARGO_STORE),SetMinimalSize(70, 0), SetResize(1, 0), SetFill(0, 0),
+				NWidget(WWT_EMPTY, COLOUR_BROWN, WID_CB_CARGO_STORE_PCT),SetMinimalSize(60, 0), SetResize(1, 0), SetFill(0, 0),
+			EndContainer(),
+			NWidget(NWID_SPACER), SetMinimalSize(0, 0), SetResize(1, 1), SetFill(1, 1),
+		EndContainer(),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_CB_CENTER_VIEW), SetMinimalSize(60, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_BUTTON_LOCATION, STR_TOWN_VIEW_CENTER_TOOLTIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_CB_TOWN_VIEW), SetMinimalSize(80, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_CB_GUI_TOWN_VIEW_BUTTON, STR_CB_GUI_TOWN_VIEW_TOOLTIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_CB_SHOW_AUTHORITY), SetMinimalSize(80, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_TOWN_VIEW_LOCAL_AUTHORITY_BUTTON, STR_TOWN_VIEW_LOCAL_AUTHORITY_TOOLTIP),
+		EndContainer(),
+		NWidget(WWT_RESIZEBOX, COLOUR_BROWN),
+	EndContainer(),
 };
 
 static WindowDesc _town_authority_desc(
 	WDP_AUTO, "view_town_authority", 317, 222,
 	WC_TOWN_AUTHORITY, WC_NONE,
 	0,
-	_nested_town_authority_widgets, lengthof(_nested_town_authority_widgets)
+	_nested_town_authority_widgets, lengthof(_nested_town_authority_widgets),
+	&TownAuthorityWindow::hotkeys
 );
 
 static void ShowTownAuthorityWindow(uint town)
@@ -296,6 +393,9 @@ static void ShowTownAuthorityWindow(uint town)
 	AllocateWindowDescFront<TownAuthorityWindow>(&_town_authority_desc, town);
 }
 
+static int TownTicksToDays(int ticks) {
+ 	return (ticks * TOWN_GROWTH_TICKS + DAY_TICKS / 2) / DAY_TICKS;
+}
 
 /* Town view window. */
 struct TownViewWindow : Window {
@@ -310,7 +410,7 @@ public:
 		this->CreateNestedTree();
 
 		this->town = Town::Get(window_number);
-		if (this->town->larger_town) this->GetWidget<NWidgetCore>(WID_TV_CAPTION)->widget_data = STR_TOWN_VIEW_CITY_CAPTION;
+		if (this->town->larger_town) this->GetWidget<NWidgetCore>(WID_TV_CAPTION)->widget_data = STR_TOWN_VIEW_CITY_CAPTION_EXTRA;
 
 		this->FinishInitNested(window_number);
 
@@ -324,7 +424,18 @@ public:
 
 	virtual void SetStringParameters(int widget) const
 	{
-		if (widget == WID_TV_CAPTION) SetDParam(0, this->town->index);
+		if (widget == WID_TV_CAPTION){ 
+			SetDParam(0, this->town->index);
+			SetDParam(1, this->town->cache.potential_pop);
+			SetDParam(2, this->town->ratings[_current_company]);
+		}
+		if (widget == WID_TV_CB){
+			SetDParam(0, STR_BUTTON_CB_YES);
+		}
+	}
+
+  virtual void OnHundrethTick() {
+		this->SetDirty();
 	}
 
 	virtual void DrawWidget(const Rect &r, int widget) const
@@ -347,6 +458,28 @@ public:
 		SetDParam(2, this->town->supplied[CT_MAIL].old_max);
 		DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += FONT_HEIGHT_NORMAL, STR_TOWN_VIEW_CARGO_LAST_MONTH_MAX);
 
+    SetDParam(0, ((this->town->growth_rate & (~TOWN_CUSTOM_GROWTH)) * TOWN_GROWTH_TICKS + DAY_TICKS) / DAY_TICKS);
+		SetDParam(1, ((this->town->grow_counter & (~TOWN_CUSTOM_GROWTH)) * TOWN_GROWTH_TICKS + DAY_TICKS) / DAY_TICKS);
+		SetDParam(2, ((this->town->time_until_rebuild & (~TOWN_CUSTOM_GROWTH)) * TOWN_GROWTH_TICKS + DAY_TICKS) / DAY_TICKS);
+		SetDParam(3, (int)HasBit(this->town->flags, TOWN_IS_GROWING));
+		SetDParam(4, this->town->fund_buildings_months);
+		DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += FONT_HEIGHT_NORMAL, STR_TOWN_VIEW_GROWTH);
+
+    //house states
+    SetDParam(0, town->houses_construction);
+    SetDParam(1, town->houses_reconstruction);
+    SetDParam(2, town->houses_demolished);
+    DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += FONT_HEIGHT_NORMAL, STR_TOWN_VIEW_HOUSE_STATE);
+
+    ///houses stats
+    SetDParam(0, town->houses_skipped);
+    SetDParam(1, town->houses_skipped_last_month);
+    SetDParam(2, town->cycles_skipped);
+    SetDParam(3, town->cycles_skipped_last_month);
+    SetDParam(4, town->cb_houses_removed);
+    SetDParam(5, town->cb_houses_removed_last_month);
+    DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += FONT_HEIGHT_NORMAL, STR_TOWN_VIEW_GROWTH_TILES);
+
 		bool first = true;
 		for (int i = TE_BEGIN; i < TE_END; i++) {
 			if (this->town->goal[i] == 0) continue;
@@ -446,6 +579,10 @@ public:
 				break;
 			}
 
+			case WID_TV_CB:
+				ShowCBTownWindow(this->window_number);
+				break;
+
 			case WID_TV_DELETE: // delete town - only available on Scenario editor
 				DoCommandP(0, this->window_number, 0, CMD_DELETE_TOWN | CMD_MSG(STR_ERROR_TOWN_CAN_T_DELETE));
 				break;
@@ -467,7 +604,7 @@ public:
 	 */
 	uint GetDesiredInfoHeight(int width) const
 	{
-		uint aimed_height = 3 * FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+		uint aimed_height = 6 * FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
 
 		bool first = true;
 		for (int i = TE_BEGIN; i < TE_END; i++) {
@@ -531,12 +668,28 @@ public:
 
 		DoCommandP(0, this->window_number, 0, CMD_RENAME_TOWN | CMD_MSG(STR_ERROR_CAN_T_RENAME_TOWN), NULL, str);
 	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		//if(hotkey == WID_TV_CB) ShowCBTownWindow(this->window_number);
+		return Window::OnHotkey(hotkey);
+	}
+
+	static HotkeyList hotkeys;
+};
+
+static Hotkey town_window_hotkeys[] = {
+	Hotkey((uint16)0, "location", WID_TV_CENTER_VIEW),
+	Hotkey((uint16)0, "local_authority", WID_TV_SHOW_AUTHORITY),
+	Hotkey((uint16)0, "cb_window", WID_TV_CB),
+	HOTKEY_LIST_END
 };
+HotkeyList TownViewWindow::hotkeys("town_window", town_window_hotkeys);
 
 static const NWidgetPart _nested_town_game_view_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_BROWN),
-		NWidget(WWT_CAPTION, COLOUR_BROWN, WID_TV_CAPTION), SetDataTip(STR_TOWN_VIEW_TOWN_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_CAPTION, COLOUR_BROWN, WID_TV_CAPTION), SetDataTip(STR_TOWN_VIEW_TOWN_CAPTION_EXTRA, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
 		NWidget(WWT_SHADEBOX, COLOUR_BROWN),
 		NWidget(WWT_DEFSIZEBOX, COLOUR_BROWN),
 		NWidget(WWT_STICKYBOX, COLOUR_BROWN),
@@ -551,7 +704,8 @@ static const NWidgetPart _nested_town_game_view_widgets[] = {
 		NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
 			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_CENTER_VIEW), SetMinimalSize(80, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_BUTTON_LOCATION, STR_TOWN_VIEW_CENTER_TOOLTIP),
 			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_SHOW_AUTHORITY), SetMinimalSize(80, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_TOWN_VIEW_LOCAL_AUTHORITY_BUTTON, STR_TOWN_VIEW_LOCAL_AUTHORITY_TOOLTIP),
-			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_CHANGE_NAME), SetMinimalSize(80, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_BUTTON_RENAME, STR_TOWN_VIEW_RENAME_TOOLTIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_CHANGE_NAME), SetMinimalSize(60, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_BUTTON_RENAME, STR_TOWN_VIEW_RENAME_TOOLTIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_CB), SetMinimalSize(20, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_BUTTON_CB, 0),
 		EndContainer(),
 		NWidget(WWT_RESIZEBOX, COLOUR_BROWN),
 	EndContainer(),
@@ -561,13 +715,14 @@ static WindowDesc _town_game_view_desc(
 	WDP_AUTO, "view_town", 260, TownViewWindow::WID_TV_HEIGHT_NORMAL,
 	WC_TOWN_VIEW, WC_NONE,
 	0,
-	_nested_town_game_view_widgets, lengthof(_nested_town_game_view_widgets)
+	_nested_town_game_view_widgets, lengthof(_nested_town_game_view_widgets),
+	&TownViewWindow::hotkeys
 );
 
 static const NWidgetPart _nested_town_editor_view_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_BROWN),
-		NWidget(WWT_CAPTION, COLOUR_BROWN, WID_TV_CAPTION), SetDataTip(STR_TOWN_VIEW_TOWN_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_CAPTION, COLOUR_BROWN, WID_TV_CAPTION), SetDataTip(STR_TOWN_VIEW_TOWN_CAPTION_EXTRA, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_CHANGE_NAME), SetMinimalSize(76, 14), SetDataTip(STR_BUTTON_RENAME, STR_TOWN_VIEW_RENAME_TOOLTIP),
 		NWidget(WWT_SHADEBOX, COLOUR_BROWN),
 		NWidget(WWT_DEFSIZEBOX, COLOUR_BROWN),
@@ -584,6 +739,7 @@ static const NWidgetPart _nested_town_editor_view_widgets[] = {
 			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_CENTER_VIEW), SetMinimalSize(80, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_BUTTON_LOCATION, STR_TOWN_VIEW_CENTER_TOOLTIP),
 			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_EXPAND), SetMinimalSize(80, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_TOWN_VIEW_EXPAND_BUTTON, STR_TOWN_VIEW_EXPAND_TOOLTIP),
 			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_DELETE), SetMinimalSize(80, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_TOWN_VIEW_DELETE_BUTTON, STR_TOWN_VIEW_DELETE_TOOLTIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_BROWN, WID_TV_CB), SetMinimalSize(20, 12), SetFill(1, 1), SetResize(1, 0), SetDataTip(STR_BUTTON_CB, 0),
 		EndContainer(),
 		NWidget(WWT_RESIZEBOX, COLOUR_BROWN),
 	EndContainer(),
@@ -608,7 +764,7 @@ void ShowTownViewWindow(TownID town)
 static const NWidgetPart _nested_town_directory_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_BROWN),
-		NWidget(WWT_CAPTION, COLOUR_BROWN), SetDataTip(STR_TOWN_DIRECTORY_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_CAPTION, COLOUR_BROWN, TDW_CAPTION_TEXT), SetDataTip(STR_TOWN_DIRECTORY_CAPTION_EXTRA, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
 		NWidget(WWT_SHADEBOX, COLOUR_BROWN),
 		NWidget(WWT_DEFSIZEBOX, COLOUR_BROWN),
 		NWidget(WWT_STICKYBOX, COLOUR_BROWN),
@@ -700,6 +856,15 @@ private:
 		return (a_population < b_population) ? -1 : 1;
 	}
 
+  /** Sort by number of houses (default descending, as big towns are of the most interest). */
+	static int CDECL TownHousesSorter(const Town * const *a, const Town * const *b)
+	{
+		uint32 a_houses = (*a)->cache.num_houses;
+		uint32 b_houses = (*b)->cache.num_houses;
+		if (a_houses == b_houses) return TownDirectoryWindow::TownPopulationSorter(a, b);
+		return (a_houses < b_houses) ? -1 : 1;
+	}
+
 	/** Sort by town rating */
 	static int CDECL TownRatingSorter(const Town * const *a, const Town * const *b)
 	{
@@ -744,6 +909,18 @@ public:
 			case WID_TD_SORT_CRITERIA:
 				SetDParam(0, TownDirectoryWindow::sorter_names[this->towns.SortType()]);
 				break;
+
+      case TDW_CAPTION_TEXT:
+				uint16 town_number = 0;
+        uint16 city_number = 0;
+        const Town *t;
+        FOR_ALL_TOWNS(t){
+          if(t->larger_town) city_number++;
+          town_number++;
+        }
+        SetDParam(0, city_number);
+        SetDParam(1, town_number);
+				break;
 		}
 	}
 
@@ -795,7 +972,10 @@ public:
 
 					SetDParam(0, t->index);
 					SetDParam(1, t->cache.population);
-					DrawString(text_left, text_right, y + (this->resize.step_height - FONT_HEIGHT_NORMAL) / 2, GetTownString(t));
+					SetDParam(2, t->cache.num_houses);
+					/* CITIES DIFFERENT COLOUR*/
+					//DrawString(text_left, text_right, y + (this->resize.step_height - FONT_HEIGHT_NORMAL) / 2, STR_TOWN_DIRECTORY_TOWN_COLOUR, (t->larger_town ? TC_YELLOW : TC_ORANGE), SA_LEFT);
+					DrawString(text_left, text_right, y + (this->resize.step_height - FONT_HEIGHT_NORMAL) / 2, t->larger_town ? STR_TOWN_DIRECTORY_CITY_COLOUR : STR_TOWN_DIRECTORY_TOWN_COLOUR);
 
 					y += this->resize.step_height;
 					if (++n == this->vscroll->GetCapacity()) break; // max number of towns in 1 window
@@ -833,8 +1013,9 @@ public:
 					assert(t != NULL);
 
 					SetDParam(0, t->index);
-					SetDParamMaxDigits(1, 8);
-					d = maxdim(d, GetStringBoundingBox(GetTownString(t)));
+					//SetDParamMaxDigits(1, 8); //CORAGEM
+					SetDParamMaxDigits(2, 5);
+					d = maxdim(d, GetStringBoundingBox(STR_TOWN_DIRECTORY_TOWN_COLOUR));
 				}
 				Dimension icon_size = GetSpriteSize(SPR_TOWN_RATING_GOOD);
 				d.width += icon_size.width + 2;
@@ -945,6 +1126,7 @@ const Town *TownDirectoryWindow::last_town = NULL;
 const StringID TownDirectoryWindow::sorter_names[] = {
 	STR_SORT_BY_NAME,
 	STR_SORT_BY_POPULATION,
+	STR_SORT_BY_HOUSES,
 	STR_SORT_BY_RATING,
 	INVALID_STRING_ID
 };
@@ -953,6 +1135,7 @@ const StringID TownDirectoryWindow::sorter_names[] = {
 GUITownList::SortFunction * const TownDirectoryWindow::sorter_funcs[] = {
 	&TownNameSorter,
 	&TownPopulationSorter,
+	&TownHousesSorter,
 	&TownRatingSorter,
 };
 
@@ -1210,3 +1393,325 @@ void ShowFoundTownWindow()
 	if (_game_mode != GM_EDITOR && !Company::IsValidID(_local_company)) return;
 	AllocateWindowDescFront<FoundTownWindow>(&_found_town_desc, 0);
 }
+
+//CB
+static void DrawExtraTownInfo (const Rect &r, uint &y, Town *town, uint line, bool show_house_states_info) {
+	//real pop and rating
+	SetDParam(0, town->cache.potential_pop);
+	SetDParam(1, town->ratings[_current_company]);
+	DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += line, STR_TOWN_VIEW_REALPOP_RATE);
+	//town stats
+	int grow_rate = 0;
+	if(town->growth_rate == TOWN_GROWTH_RATE_NONE) grow_rate = 0;
+	else grow_rate = TownTicksToDays((town->growth_rate & ~TOWN_CUSTOM_GROWTH) + 1);
+
+	SetDParam(0, grow_rate);
+	SetDParam(1, !(town->growth_rate & TOWN_CUSTOM_GROWTH) ? TownTicksToDays(town->grow_counter + 1) : ((town->grow_counter & (~TOWN_CUSTOM_GROWTH)) * TOWN_GROWTH_TICKS + DAY_TICKS) / DAY_TICKS);
+	SetDParam(2, town->time_until_rebuild);
+	SetDParam(3, HasBit(town->flags, TOWN_IS_GROWING) ? 1 : 0);
+	SetDParam(4, town->fund_buildings_months);
+	DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += line, STR_TOWN_VIEW_GROWTH);
+
+	if (show_house_states_info) {
+		SetDParam(0, town->houses_construction);
+		SetDParam(1, town->houses_reconstruction);
+		SetDParam(2, town->houses_demolished);
+		DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += line, STR_TOWN_VIEW_HOUSE_STATE);
+	}
+
+	///houses stats
+	SetDParam(0, town->houses_skipped);
+	SetDParam(1, town->houses_skipped_last_month);
+	SetDParam(2, town->cycles_skipped);
+	SetDParam(3, town->cycles_skipped_last_month);
+	SetDParam(4, town->cb_houses_removed);
+	SetDParam(5, town->cb_houses_removed_last_month);
+	DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += line, STR_TOWN_VIEW_GROWTH_TILES);
+}
+
+bool CB_sortCargoesByFrom(CargoX first, CargoX second){
+	return (first.from < second.from) ? true : false;
+}
+
+struct CBTownWindow : Window {
+private:
+	Town *town;
+	std::list<CargoX> cargoes;
+
+public:
+	CBTownWindow(WindowDesc *desc, WindowNumber window_number) : Window(desc)
+	{
+		for (uint i = 0; i < NUM_CARGO ; i++) {
+			CargoX c;
+			c.id = i;
+			c.from = CB_GetFrom(i);
+			this->cargoes.push_back(c);
+		}
+		cargoes.sort(CB_sortCargoesByFrom);
+		this->town = Town::Get(window_number);
+		this->InitNested(window_number);
+
+		if(HasBit(this->town->fund_regularly, _local_company)) this->LowerWidget(WID_CB_FUND_REGULAR);
+		if(HasBit(this->town->do_powerfund, _local_company)) this->LowerWidget(WID_CB_POWERFUND);
+		if(HasBit(this->town->advertise_regularly, _local_company)) this->LowerWidget(WID_CB_ADVERT_REGULAR);
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch (widget) {
+			case WID_CB_LOCATION:
+			case WID_CB_CENTER_VIEW: // scroll to location
+				if (_ctrl_pressed) {
+					ShowExtraViewPortWindow(this->town->xy);
+				}
+				else {
+					ScrollMainWindowToTile(this->town->xy);
+				}
+				break;
+			case WID_CB_ADVERT:
+				TownExecuteAction(this->town, HK_LADVERT);
+				break;
+			case WID_CB_FUND:
+				TownExecuteAction(this->town, HK_FUND);
+				break;
+			case WID_CB_FUND_REGULAR:
+				ToggleBit(this->town->fund_regularly, _local_company);
+				this->SetWidgetLoweredState(widget, HasBit(this->town->fund_regularly, _local_company));
+				this->SetWidgetDirty(widget);
+				break;
+			case WID_CB_POWERFUND:
+				ToggleBit(this->town->do_powerfund, _local_company);
+				this->SetWidgetLoweredState(widget, HasBit(this->town->do_powerfund, _local_company));
+				this->SetWidgetDirty(widget);
+				break;
+			case WID_CB_ADVERT_REGULAR:
+				if (!this->town->advertise_regularly) {
+					SetDParam(0, ToPercent8(this->town->ad_rating_goal));
+					ShowQueryString(STR_JUST_INT, STR_CB_ADVERT_REGULAR_RATING_TO_KEEP,
+					                4, this, CS_NUMERAL, QSF_ACCEPT_UNCHANGED);
+				} else this->OnQueryTextFinished(NULL);
+				break;
+			case WID_CB_TOWN_VIEW: // Town view window
+				ShowTownViewWindow(this->window_number);
+				break;
+			case WID_CB_SHOW_AUTHORITY: // town authority
+				ShowTownAuthorityWindow(this->window_number);
+				break;
+		}
+	}
+
+	virtual void OnQueryTextFinished(char *str)
+	{
+		if (str != NULL) SetBit(this->town->advertise_regularly, _local_company);
+		else ClrBit(this->town->advertise_regularly, _local_company);
+		this->town->ad_ref_goods_entry = NULL;
+		this->SetWidgetLoweredState(WID_CB_ADVERT_REGULAR, HasBit(this->town->advertise_regularly, _local_company));
+		this->SetWidgetDirty(WID_CB_ADVERT_REGULAR);
+
+		if (str == NULL)
+			return;
+		uint val = Clamp(StrEmpty(str) ? 0 : strtol(str, NULL, 10), 1, 100);
+		this->town->ad_rating_goal = ((val << 8) + 255) / 101;
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		if (widget == WID_TV_CAPTION){
+			SetDParam(0, this->town->index);
+		}
+	}
+
+	void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		static const uint EXP_TOPPADDING = 5;
+		static const uint EXP_LINESPACE  = 2; // Amount of vertical space for a horizontal (sub-)total line.
+
+		switch(widget){
+			case WID_CB_DETAILS:
+				size->height = (FONT_HEIGHT_NORMAL + EXP_LINESPACE) * 7;
+				break;
+			case WID_CB_CARGO_NAME:
+			case WID_CB_CARGO_AMOUNT:
+			case WID_CB_CARGO_REQ:
+			case WID_CB_CARGO_STORE:
+			case WID_CB_CARGO_STORE_PCT:
+			case WID_CB_CARGO_FROM:
+			case WID_CB_CARGO_PREVIOUS:
+				uint desired_height = 1;
+				for(CargoID cargo = 0; cargo < NUM_CARGO; cargo++){
+					if(CB_GetReq(cargo) > 0) desired_height++;
+				}
+				size->height = desired_height * (FONT_HEIGHT_NORMAL + EXP_LINESPACE) + EXP_TOPPADDING - EXP_LINESPACE;
+				break;
+		}
+	}
+
+	void DrawWidget(const Rect &r, int widget) const
+	{
+		static const uint EXP_LINESPACE  = FONT_HEIGHT_NORMAL + 2;
+		uint y = r.top + WD_FRAMERECT_TOP;
+		switch(widget){
+			case WID_CB_DETAILS:{
+				//growing
+				if(HasBit(town->flags, TOWN_IS_GROWING)) DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, STR_TOWN_CB_GROWING );
+				else DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, STR_TOWN_CB_NOT_GROWING );
+				//population
+				SetDParam(0, this->town->cache.population);
+				SetDParam(1, this->town->cache.num_houses);
+				DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += EXP_LINESPACE, STR_TOWN_VIEW_POPULATION_HOUSES);
+
+				DrawExtraTownInfo(r, y, this->town, EXP_LINESPACE, false);
+				//regular funding
+				if(this->town->fund_regularly != 0){
+					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y += EXP_LINESPACE, STR_CB_FUNDED_REGULARLY);
+				}
+				break;
+			}
+			/* Citybuilder things*/
+			case WID_CB_CARGO_NAME:
+			case WID_CB_CARGO_AMOUNT:
+			case WID_CB_CARGO_REQ:
+			case WID_CB_CARGO_STORE:
+			case WID_CB_CARGO_STORE_PCT:
+			case WID_CB_CARGO_FROM:
+			case WID_CB_CARGO_PREVIOUS: {
+				if (!CB_Enabled() || this->town->larger_town) break;
+
+				uint delivered;
+				uint requirements;
+				uint from;
+				StringID string_to_draw;
+
+				//for cycle
+				std::list<CargoX> cargoes2 = this->cargoes;
+				std::list<CargoX>::iterator it2;
+				for (it2 = cargoes2.begin(); it2 != cargoes2.end(); ++it2) {
+					CargoX cargox;
+					cargox = *it2;
+					if (it2 == cargoes2.begin()) { //header
+						DrawString(r.left + WD_FRAMERECT_LEFT + 14, r.right - WD_FRAMERECT_LEFT, y,
+							(STR_TOWN_GROWTH_HEADER_CARGO + widget - WID_CB_CARGO_NAME), TC_FROMSTRING,
+							(widget == WID_CB_CARGO_NAME) ? SA_LEFT : SA_RIGHT);
+
+						y += (FONT_HEIGHT_NORMAL + 2);
+					}
+
+					const CargoSpec *cargos = CargoSpec::Get(cargox.id);
+					//cargo needed?
+					if (!cargos->IsValid() || CB_GetReq(cargos->Index()) == 0) continue;
+
+					from = CB_GetFrom(cargos->Index());
+
+					switch(widget) {
+						case WID_CB_CARGO_NAME: {
+							int rect_x = (r.left + WD_FRAMERECT_LEFT);
+							GfxFillRect(rect_x, y + 1, rect_x + 8, y + 6, 0);
+							GfxFillRect(rect_x + 1, y + 2, rect_x + 7, y + 5, cargos->legend_colour);
+
+							SetDParam(0, cargos->name);
+							DrawString(r.left + WD_FRAMERECT_LEFT + 14, r.right - WD_FRAMERECT_LEFT, y, STR_TOWN_CB_CARGO_NAME);
+							break;
+						}
+						case WID_CB_CARGO_AMOUNT: {
+							delivered = this->town->new_act_cargo[cargos->Index()];
+							requirements = CB_GetTownReq(this->town->cache.population, CB_GetReq(cargos->Index()), from, true);
+							SetDParam(0, delivered);
+
+							//when required
+							if (this->town->cache.population >= from) {
+								if((delivered + (uint)this->town->storage[cargos->Index()]) >= requirements) string_to_draw = STR_TOWN_CB_CARGO_AMOUNT_GOOD;
+								else string_to_draw = STR_TOWN_CB_CARGO_AMOUNT_BAD;
+						}
+							//when not required -> all faded
+							else string_to_draw = STR_TOWN_CB_CARGO_AMOUNT_NOT;
+
+							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, string_to_draw, TC_FROMSTRING, SA_RIGHT);
+							break;
+						}
+						case WID_CB_CARGO_REQ: {
+							requirements = CB_GetTownReq(this->town->cache.population, CB_GetReq(cargos->Index()), from, true);
+							SetDParam(0, requirements);
+							 //when required
+							string_to_draw = (this->town->cache.population >= from) ? STR_TOWN_CB_CARGO_REQ_YES : STR_TOWN_CB_CARGO_REQ_NOT;
+							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, string_to_draw, TC_FROMSTRING, SA_RIGHT);
+							break;
+						}
+						case WID_CB_CARGO_PREVIOUS: {
+							requirements = CB_GetTownReq(this->town->cache.population, CB_GetReq(cargos->Index()), from, true);
+							SetDParam(0, this->town->act_cargo[cargos->Index()]);
+							if (this->town->cache.population >= from){
+								if (this->town->delivered_enough[cargos->Index()]) {
+									string_to_draw = (this->town->act_cargo[cargos->Index()] >= requirements) ? STR_TOWN_CB_CARGO_PREVIOUS_YES : STR_TOWN_CB_CARGO_PREVIOUS_EDGE;
+								}
+								else string_to_draw = STR_TOWN_CB_CARGO_PREVIOUS_BAD;
+							}
+							else string_to_draw = STR_TOWN_CB_CARGO_PREVIOUS_NOT;
+
+							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, string_to_draw, TC_FROMSTRING, SA_RIGHT);
+							break;
+						}
+						case WID_CB_CARGO_STORE: {
+							SetDParam(0, this->town->storage[cargos->Index()]);
+							if (CB_GetDecay(cargos->Index()) == 100) string_to_draw = STR_TOWN_CB_CARGO_STORE_DECAY;  //when 100% decay
+							else {
+								if (this->town->cache.population >= from) string_to_draw = STR_TOWN_CB_CARGO_STORE_YES;  //when required
+								else string_to_draw = STR_TOWN_CB_CARGO_STORE_NOT;
+							}
+
+							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, string_to_draw, TC_FROMSTRING, SA_RIGHT);
+							break;
+						}
+						case WID_CB_CARGO_STORE_PCT: {
+							uint max_storage = CB_GetMaxTownStorage(this->town, cargos->Index());
+							if (CB_GetDecay(cargos->Index()) == 100 || !max_storage) string_to_draw = STR_TOWN_CB_CARGO_STORE_DECAY;  //when 100% decay
+							else {
+								SetDParam(0, 100 * this->town->storage[cargos->Index()] / max_storage);
+								if (this->town->cache.population >= from) string_to_draw = STR_TOWN_CB_CARGO_STORE_PCT_YES;  //when required
+								else string_to_draw = STR_TOWN_CB_CARGO_STORE_PCT_NOT;
+							}
+
+							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, string_to_draw, TC_FROMSTRING, SA_RIGHT);
+							break;
+						}
+						case WID_CB_CARGO_FROM: {
+							SetDParam(0, from);
+							string_to_draw = (this->town->cache.population >= from) ? STR_TOWN_CB_CARGO_FROM_YES : STR_TOWN_CB_CARGO_FROM_NOT; //when required
+
+							DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_LEFT, y, string_to_draw, TC_FROMSTRING, SA_RIGHT);
+							break;
+						}
+						//last case
+					}
+					//switch
+					y += (FONT_HEIGHT_NORMAL + 2);
+					//cargo needed?
+				}
+				//for cycle
+			}
+			break;
+		}
+		/* Citybuilder things enabled*/
+	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		TownExecuteAction(this->town, hotkey);
+		return ES_HANDLED;
+	}
+
+	static HotkeyList hotkeys;
+};
+
+HotkeyList CBTownWindow::hotkeys("town_gui", town_hotkeys);
+
+static WindowDesc _cb_town_desc(
+	WDP_AUTO, "cb_town", 320, 80,
+	WC_CB_TOWN, WC_NONE,
+	0,
+	_nested_cb_town_widgets, lengthof(_nested_cb_town_widgets),
+	&CBTownWindow::hotkeys
+);
+
+void ShowCBTownWindow(uint town) {
+	AllocateWindowDescFront<CBTownWindow>(&_cb_town_desc, town);
+}
diff --git a/src/train_cmd.cpp b/src/train_cmd.cpp
index 29b2e543e..55bfe7b0a 100644
--- a/src/train_cmd.cpp
+++ b/src/train_cmd.cpp
@@ -3181,6 +3181,9 @@ bool TrainController(Train *v, Vehicle *nomove, bool reverse)
 
 						/* Don't handle stuck trains here. */
 						if (HasBit(v->flags, VRF_TRAIN_STUCK)) return false;
+						/* this codepath seems to be run every 5 ticks, so increase counter twice every 20 ticks */
+						IncreaseStuckCounter(v->tile);
+						if (v->tick_counter % 4 == 0) IncreaseStuckCounter(v->tile);
 
 						if (!HasSignalOnTrackdir(gp.new_tile, ReverseTrackdir(i))) {
 							v->cur_speed = 0;
@@ -3333,7 +3336,7 @@ bool TrainController(Train *v, Vehicle *nomove, bool reverse)
 				v->x_pos = gp.x;
 				v->y_pos = gp.y;
 				v->UpdatePosition();
-				if ((v->vehstatus & VS_HIDDEN) == 0) v->Vehicle::UpdateViewport(true);
+				if (v->IsDrawn()) v->Vehicle::UpdateViewport(true);
 				continue;
 			}
 		}
@@ -3789,6 +3792,7 @@ static bool TrainLocoHandler(Train *v, bool mode)
 	/* Handle stuck trains. */
 	if (!mode && HasBit(v->flags, VRF_TRAIN_STUCK)) {
 		++v->wait_counter;
+		if (v->tick_counter % 4 == 0) IncreaseStuckCounter(v->tile);
 
 		/* Should we try reversing this tick if still stuck? */
 		bool turn_around = v->wait_counter % (_settings_game.pf.wait_for_pbs_path * DAY_TICKS) == 0 && _settings_game.pf.reverse_at_signals;
@@ -3860,7 +3864,7 @@ static bool TrainLocoHandler(Train *v, bool mode)
 	}
 
 	for (Train *u = v; u != NULL; u = u->Next()) {
-		if ((u->vehstatus & VS_HIDDEN) != 0) continue;
+		if (!u->IsDrawn()) continue;
 
 		u->UpdateViewport(false, false);
 	}
diff --git a/src/transparency.h b/src/transparency.h
index ab6f9a6f3..773a633e3 100644
--- a/src/transparency.h
+++ b/src/transparency.h
@@ -31,6 +31,7 @@ enum TransparencyOption {
 	TO_STRUCTURES, ///< other objects such as transmitters and lighthouses
 	TO_CATENARY,   ///< catenary
 	TO_LOADING,    ///< loading indicators
+	TO_TUNNELS,    ///< vehicles in tunnels
 	TO_END,
 	TO_INVALID,    ///< Invalid transparency option
 };
diff --git a/src/transparency_gui.cpp b/src/transparency_gui.cpp
index 4bad2b056..2e388eb8e 100644
--- a/src/transparency_gui.cpp
+++ b/src/transparency_gui.cpp
@@ -52,6 +52,7 @@ public:
 			case WID_TT_BRIDGES:
 			case WID_TT_STRUCTURES:
 			case WID_TT_CATENARY:
+			case WID_TT_TUNNELS:
 			case WID_TT_LOADING: {
 				uint i = widget - WID_TT_BEGIN;
 				if (HasBit(_transparency_lock, i)) DrawSprite(SPR_LOCK, PAL_NONE, r.left + 1, r.top + 1);
@@ -59,7 +60,7 @@ public:
 			}
 			case WID_TT_BUTTONS:
 				for (uint i = WID_TT_BEGIN; i < WID_TT_END; i++) {
-					if (i == WID_TT_LOADING) continue; // Do not draw button for invisible loading indicators.
+					if (i >= WID_TT_LOADING) continue; // Do not draw button for invisible loading indicators.
 
 					const NWidgetBase *wi = this->GetWidget<NWidgetBase>(i);
 					DrawFrameRect(wi->pos_x + 1, r.top + 2, wi->pos_x + wi->current_x - 2, r.bottom - 2, COLOUR_PALE_GREEN,
@@ -141,6 +142,7 @@ static const NWidgetPart _nested_transparency_widgets[] = {
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_STRUCTURES), SetMinimalSize(22, 22), SetFill(0, 1), SetDataTip(SPR_IMG_TRANSMITTER, STR_TRANSPARENT_STRUCTURES_TOOLTIP),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_CATENARY), SetMinimalSize(22, 22), SetFill(0, 1), SetDataTip(SPR_BUILD_X_ELRAIL, STR_TRANSPARENT_CATENARY_TOOLTIP),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_LOADING), SetMinimalSize(22, 22), SetFill(0, 1), SetDataTip(SPR_IMG_TRAINLIST, STR_TRANSPARENT_LOADING_TOOLTIP),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_TT_TUNNELS), SetMinimalSize(22, 22), SetFill(0, 1), SetDataTip(SPR_IMG_ROAD_TUNNEL, STR_TRANSPARENT_TUNNELS_TOOLTIP),
 		NWidget(WWT_PANEL, COLOUR_DARK_GREEN), SetFill(1, 1), EndContainer(),
 	EndContainer(),
 	/* Panel with 'invisibility' buttons. */
@@ -158,6 +160,7 @@ static WindowDesc _transparency_desc(
 /**
  * Show the transparency toolbar.
  */
+
 void ShowTransparencyToolbar()
 {
 	AllocateWindowDescFront<TransparenciesWindow>(&_transparency_desc, 0);
diff --git a/src/triphistory.h b/src/triphistory.h
new file mode 100644
index 000000000..bbc6c306a
--- /dev/null
+++ b/src/triphistory.h
@@ -0,0 +1,75 @@
+/** @file triphistory.h */
+
+#ifndef TRIPHISTORY_H
+#define TRIPHISTORY_H
+
+#include <deque>
+#include "window_gui.h"
+#include "strings_type.h"
+#include "economy_type.h"
+#include "date_type.h"
+
+// entries to save
+#define TRIP_LENGTH 10
+
+static inline int TripHistoryRound( float x ) 
+{
+	return int( x > 0.0 ? x + 0.5 : x - 0.5 );
+}
+
+struct TripHistoryEntry {
+	Money profit; // Saved
+	Date date; // Saved
+	int32 profit_change; // Calculated
+	Date TBT; // Calculated
+	int32 TBT_change; // Calculated
+
+	TripHistoryEntry( ) : profit( 0 ), date( 0 ), profit_change( 0 ), TBT( 0 ), TBT_change( 0 ) { };
+};
+
+/** Structure to hold data for each vehicle */
+struct TripHistory {
+	// a lot of saveload stuff for std::deque. So...
+	TripHistoryEntry t[ TRIP_LENGTH ];
+
+	Money total_profit; 
+	int32 avg_daylength; 
+	int32 total_change;
+	Money profit_per_day;
+
+	TripHistory( ) :
+		total_profit( 0 ),
+		avg_daylength( 0 ),
+		total_change( 0 ),
+		profit_per_day( 0 ) { }
+
+	void NewRound();
+
+	void AddValue( Money mvalue, Date dvalue );
+
+
+	/**
+	 * Init info for GUI
+	 *
+	 * @return size_t number of valid rows
+	 */
+	size_t UpdateCalculated( );
+
+	int32 FindPercentChange( Money v1, Money v2 ) {
+		float temp;
+
+		if ( v1 > v2 ) {
+			temp = v1 - v2;
+			return TripHistoryRound( ( float ) temp * 100 / ( float ) v1 );
+		}
+
+		if ( v2 > v1 ) {
+			temp = v1 - v2;
+			return TripHistoryRound( ( float ) temp * 100 / ( float ) v2 );
+		}
+
+		return 0;
+	}
+};
+
+#endif /* TRIPHISTORY_H */
diff --git a/src/triphistory_cmd.cpp b/src/triphistory_cmd.cpp
new file mode 100644
index 000000000..fe251be6f
--- /dev/null
+++ b/src/triphistory_cmd.cpp
@@ -0,0 +1,100 @@
+/** @file triphistory_cmd.cpp */
+
+#include "stdafx.h"
+#include "triphistory.h"
+#include "table/strings.h"
+
+void
+TripHistory::AddValue( Money mvalue, Date dvalue ) {
+	if ( 0 < dvalue ) {
+		t[ 0 ].profit += mvalue;
+		t[ 0 ].date = dvalue;
+	}
+}
+
+void
+TripHistory::NewRound( ) {
+	//move down
+	for ( int i = TRIP_LENGTH - 1; i > 0; i-- ) {
+		this->t[ i ] = this->t[ i - 1 ];
+		//this->trip_history_date_array[ i ] = this->trip_history_date_array[ i - 1 ];
+	}
+
+	this->t[ 0 ].profit = 0;
+	this->t[ 0 ].date = this->t[ 1 ].date;
+
+	//t.push_front( TripHistoryEntry( ) );
+}
+
+size_t
+TripHistory::UpdateCalculated( ) {
+
+	this->total_profit = 0;
+	this->total_change = 0;
+	this->avg_daylength = 0;
+	this->profit_per_day = 0;
+	uint i = 0;
+
+	//
+	while ( i < TRIP_LENGTH && t [ i ].date ) {
+		
+		if ( i > 0 ) {
+			t[ i - 1 ].profit_change =
+				FindPercentChange( t [ i - 1 ].profit, t[ i ].profit );
+			t[ i - 1 ].TBT = t[ i - 1 ].date - t[ i ].date;
+
+			if ( i > 1 ) t[ i - 2 ].TBT_change = t[ i - 2 ].TBT - t[ i - 1 ].TBT;//bad line i don't like it
+
+			//omit first -100% row
+			if ( i > 1 || t [ 0 ].profit_change != -100 )
+				this->total_change += t[ i - 1 ].profit_change;
+			this->avg_daylength += t[ i - 1 ].TBT;
+		}
+
+		// prepare summary
+		
+
+		this->total_profit += t[ i ].profit;
+		i++;
+	}
+
+	if ( i == 0 ) return 0 ;
+	
+	this->avg_daylength /= --i + 1;
+
+	if ( t[ 0 ].date != t[ i ].date ) {
+		this->profit_per_day = total_profit / ( t[ 0 ].date - t[ i ].date );
+	}
+
+	return i;
+	/*
+	Trips::reverse_iterator i = t.rbegin( );
+	while ( i < t.rend( ) ) {
+
+		if ( i + 1 != t.rend( ) ) {
+			(*( i + 1 )).profit_change =
+				FindPercentChange( ( *i ).profit, ( *( i + 1 ) ).profit ); // reverse_itenrator
+
+			( *( i + 1 ) ).TBT = ( *i ).date - ( *( i + 1 ) ).date;
+
+			if ( ( *i ).TBT ) ( *( i + 1 ) ).TBT_change = ( *i ).TBT - ( *( i + 1 ) ).TBT;
+
+			//omit first -100% row
+			this->total_change += ( *i ).profit_change;
+		}
+
+		// prepare summary
+		this->total_profit += ( *i ).profit;
+		this->avg_daylength += ( *i ).TBT;
+
+		i++;
+	}
+
+	this->avg_daylength /= t.size( );
+
+	if ( t.front( ).date != t.back( ).date ) {
+		this->profit_per_day = total_profit / ( t.front( ).date - t.back( ).date );
+	}
+
+	return t.size( );*/
+}
diff --git a/src/triphistory_gui.cpp b/src/triphistory_gui.cpp
new file mode 100644
index 000000000..94d758cc7
--- /dev/null
+++ b/src/triphistory_gui.cpp
@@ -0,0 +1,214 @@
+/** @file triphistory_gui.cpp */
+
+#include "stdafx.h"
+#include "triphistory.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "gfx_func.h"
+#include "date_func.h"
+#include "vehicle_base.h"
+#include "table/strings.h"
+
+#include "safeguards.h"
+
+/* Names of the widgets. Keep them in the same order as in the widget array */
+enum VehicleTripWidgets {
+    VTH_CAPTION,
+    VTH_LABEL_RECEIVED,
+    VTH_LABEL_PROFIT,
+    VTH_LABEL_PERCHANGE,
+    VTH_LABEL_TBT,
+    VTH_LABEL_DAYCHANGE,
+    VTH_MATRIX_RECEIVED,
+    VTH_MATRIX_PROFIT,
+    VTH_MATRIX_PERCHANGE,
+    VTH_MATRIX_TBT,
+    VTH_MATRIX_DAYCHANGE,
+    VTH_SUMMARY,
+
+};
+static const NWidgetPart _vehicle_trip_history_widgets[] = {
+    	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, VTH_CAPTION), SetDataTip(STR_TRIP_HISTORY_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_RECEIVED),	SetMinimalSize(110, 0), SetMinimalTextLines(1, 2), SetResize(1, 0), SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_RECEIVED_LABEL, STR_TRIP_HISTORY_RECEIVED_LABEL_TIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_PROFIT),	SetMinimalSize(110, 0), SetMinimalTextLines(1, 2), SetResize(1, 0), SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_PROFIT_LABEL,       STR_TRIP_HISTORY_PROFIT_LABEL_TIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_PERCHANGE), SetMinimalSize(50, 0), SetMinimalTextLines(1, 2), SetResize(1, 0),SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_DAYCHANGE_LABEL,    STR_TRIP_HISTORY_PERCHANGE_LABEL_TIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_TBT),	SetMinimalSize(70, 0), SetMinimalTextLines(1, 2), SetResize(1, 0),SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_TBT_LABEL,          STR_TRIP_HISTORY_TBT_LABEL_TIP),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, VTH_LABEL_DAYCHANGE), SetMinimalSize(50, 0), SetMinimalTextLines(1, 2), SetResize(1, 0),SetFill(1, 0),
+			SetDataTip(STR_TRIP_HISTORY_DAYCHANGE_LABEL,    STR_TRIP_HISTORY_DAYCHANGE_LABEL_TIP),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_RECEIVED),	SetMinimalSize(110, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_PROFIT),	SetMinimalSize(110, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_PERCHANGE), SetMinimalSize(50, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_TBT),	SetMinimalSize(70, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+		NWidget(WWT_MATRIX, COLOUR_GREY, VTH_MATRIX_DAYCHANGE), SetMinimalSize(50, 0), SetDataTip((10 << MAT_ROW_START) | (1 << MAT_COL_START), STR_NULL), SetResize(1, 1),SetFill(1, 0),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY, VTH_SUMMARY), SetMinimalTextLines(3, 2), SetResize(1, 0), SetFill(1, 0), EndContainer(),
+};
+
+struct VehicleTripHistoryWindow : Window {
+
+private:
+	uint8 valid_rows; // number of rows in trip history
+public:
+	VehicleTripHistoryWindow(WindowDesc *desc, WindowNumber window_number) :
+		Window(desc), valid_rows( 0 )
+	{
+		const Vehicle *v = Vehicle::Get(window_number);
+		this->CreateNestedTree();
+		
+		this->FinishInitNested(window_number);
+		this->owner = v->owner;
+		InvalidateData();
+	}
+/*
+	~VehicleTripHistoryWindow() {
+		if (Vehicle::IsValidID(this->window_number)) {
+			Vehicle *v = Vehicle::Get(this->window_number);
+			free(v->trip_history_pchange_array);
+			free(v->trip_history_TBT_array);
+			free(v->trip_history_TBT_change_array);
+			v->trip_history_avg_daylength = 0;
+			v->trip_history_profitpd = 0;
+			v->trip_history_total_change = 0;
+			v->trip_history_total_profit = 0;
+		}
+	}*/
+
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true) {
+		Vehicle *v = Vehicle::Get(this->window_number);
+		valid_rows = v->trip_history.UpdateCalculated();
+		this->SetDirty();
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		switch (widget) {
+			case VTH_CAPTION: SetDParam(0, this->window_number); break;
+		}
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case VTH_SUMMARY: {
+				SetDParam(0, UINT64_MAX >> 2);
+				SetDParam(1, 100);
+				Dimension text_dim = GetStringBoundingBox(STR_TRIP_HISTORY_TOTALINCOME);
+				size->width = text_dim.width + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+				break;
+			}
+
+			case VTH_LABEL_RECEIVED:
+			case VTH_MATRIX_RECEIVED: {
+				SetDParam(0, _date);
+				Dimension text_dim = GetStringBoundingBox(STR_TRIP_HISTORY_DATE);
+				size->width = text_dim.width + WD_MATRIX_LEFT + WD_MATRIX_RIGHT;
+				break;
+			}
+			case VTH_MATRIX_PROFIT:
+			case VTH_MATRIX_PERCHANGE:
+			case VTH_MATRIX_TBT:
+			case VTH_MATRIX_DAYCHANGE:
+				resize->height = FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM;
+				size->height = 10 * resize->height;
+				break;
+		}
+	}
+	virtual void DrawWidget(const Rect &r, int widget) const {
+	    	const Vehicle *v = Vehicle::Get(this->window_number);
+		int y = WD_FRAMERECT_TOP;
+		
+		switch( widget ) {
+		    case VTH_MATRIX_RECEIVED:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i].date > 0) {
+					    SetDParam(0, v->trip_history.t[i].date);
+					    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y, STR_TRIP_HISTORY_DATE, TC_BLACK, SA_RIGHT);
+				    }
+			    }
+			    break;
+		    case VTH_MATRIX_PROFIT:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i].date > 0) {
+					    if ( v->trip_history.t[i].profit > 0 ) {
+						    SetDParam(0, v->trip_history.t[i].profit );
+						    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y, STR_TRIP_HISTORY_PROFIT, TC_BLACK, SA_RIGHT);
+					    } else {
+						    SetDParam(0, -v->trip_history.t[i].profit);
+						    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y, STR_TRIP_HISTORY_VIRTUAL_PROFIT, TC_BLACK, SA_RIGHT);
+					    }
+				    }
+			    }
+			    break;
+		    case VTH_MATRIX_PERCHANGE:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i+1].date > 0) {
+					    SetDParam(0, v->trip_history.t[i].profit_change);
+					    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y,
+						    v->trip_history.t[i].profit_change >= 0 ?
+							    STR_TRIP_HISTORY_PROFITCHANGEPOS :
+							    STR_TRIP_HISTORY_PROFITCHANGENEG, TC_BLACK, SA_RIGHT
+					    );
+				    }
+			    }
+			    break;
+		    case VTH_MATRIX_TBT:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i].date > 0) {
+					    SetDParam(0, v->trip_history.t[i].TBT);
+					    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y, STR_TRIP_HISTORY_TBT, TC_BLACK, SA_RIGHT);
+				    }
+			    }
+			    break;
+		    case VTH_MATRIX_DAYCHANGE:
+			    for(int i = 0; i <= valid_rows; i++, y += FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM) {
+				    if (v->trip_history.t[i+1].date > 0) {
+					    SetDParam(0, v->trip_history.t[i].TBT_change);
+					    DrawString(r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + y,
+						    v->trip_history.t[i].TBT_change > 0 ?
+							    STR_TRIP_HISTORY_TBTCHANGEPOS :
+							    STR_TRIP_HISTORY_TBTCHANGENEG, TC_BLACK, SA_RIGHT
+					    );
+				    }
+			    }
+			    break;
+		    case VTH_SUMMARY:
+			    SetDParam(0, valid_rows + 1);
+			    SetDParam(1, v->trip_history.total_profit);
+			    SetDParam(2, v->trip_history.profit_per_day);
+			    DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, STR_TRIP_HISTORY_TOTALINCOME, TC_BLACK);
+			    SetDParam(0, v->trip_history.avg_daylength);
+			    DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP, STR_TRIP_HISTORY_DAYAVERAGE, TC_BLACK);
+			    SetDParam(0, valid_rows + 1);
+			    SetDParam(1, v->trip_history.total_change);
+			    DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + 2*FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP, STR_TRIP_HISTORY_DAYAVERAGE_IMPROVEMENT, TC_BLACK);
+			    break;
+		}
+	}
+};
+
+static WindowDesc _vehicle_trip_history(
+	WDP_AUTO, "trip_history", 380, 191, 
+	WC_VEHICLE_TRIP_HISTORY,WC_VEHICLE_DETAILS,
+	0,
+	_vehicle_trip_history_widgets,
+	lengthof(_vehicle_trip_history_widgets)
+);
+
+void ShowTripHistoryWindow(const Vehicle *v)
+{
+	if (!BringWindowToFrontById(WC_VEHICLE_TRIP_HISTORY, v->index)) {
+		AllocateWindowDescFront<VehicleTripHistoryWindow>(&_vehicle_trip_history, v->index);
+	}
+}
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index f4dc0c4dd..d1a790545 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -286,6 +286,14 @@ uint Vehicle::Crash(bool flooded)
 	return RandomRange(pass + 1); // Randomise deceased passengers.
 }
 
+bool Vehicle::IsDrawn() const
+{
+	return !(this->vehstatus & VS_HIDDEN) ||
+			(IsTransparencySet(TO_TUNNELS) &&
+				((this->type == VEH_TRAIN && Train::From(this)->track == TRACK_BIT_WORMHOLE) ||
+				(this->type == VEH_ROAD && RoadVehicle::From(this)->state == RVSB_WORMHOLE)));
+}
+
 
 /**
  * Displays a "NewGrf Bug" error message for a engine, and pauses the game if not networking.
@@ -851,6 +859,8 @@ void Vehicle::PreDestructor()
 		DeleteWindowById(WC_VEHICLE_REFIT, this->index);
 		DeleteWindowById(WC_VEHICLE_DETAILS, this->index);
 		DeleteWindowById(WC_VEHICLE_TIMETABLE, this->index);
+		DeleteWindowById(WC_VEHICLE_TRIP_HISTORY, this->index);
+		SetWindowDirty(WC_VEHICLE_TRIP_HISTORY, this->index);
 		SetWindowDirty(WC_COMPANY, this->owner);
 		OrderBackup::ClearVehicle(this);
 	}
@@ -875,7 +885,7 @@ Vehicle::~Vehicle()
 
 	/* sometimes, eg. for disaster vehicles, when company bankrupts, when removing crashed/flooded vehicles,
 	 * it may happen that vehicle chain is deleted when visible */
-	if (!(this->vehstatus & VS_HIDDEN)) this->MarkAllViewportsDirty();
+	if (this->IsDrawn()) this->MarkAllViewportsDirty();
 
 	Vehicle *v = this->Next();
 	this->SetNext(NULL);
@@ -1085,7 +1095,7 @@ static void DoDrawVehicle(const Vehicle *v)
 	if (v->vehstatus & VS_DEFPAL) pal = (v->vehstatus & VS_CRASHED) ? PALETTE_CRASH : GetVehiclePalette(v);
 
 	/* Check whether the vehicle shall be transparent due to the game state */
-	bool shadowed = (v->vehstatus & VS_SHADOW) != 0;
+	bool shadowed = (v->vehstatus & (VS_SHADOW | VS_HIDDEN));
 
 	if (v->type == VEH_EFFECT) {
 		/* Check whether the vehicle shall be transparent/invisible due to GUI settings.
@@ -1142,7 +1152,7 @@ void ViewportAddVehicles(DrawPixelInfo *dpi)
 			const Vehicle *v = _vehicle_viewport_hash[x + y]; // already masked & 0xFFF
 
 			while (v != NULL) {
-				if (!(v->vehstatus & VS_HIDDEN) &&
+				if (v->IsDrawn() &&
 						l <= v->coord.right &&
 						t <= v->coord.bottom &&
 						r >= v->coord.left &&
@@ -1177,7 +1187,7 @@ Vehicle *CheckClickOnVehicle(const ViewPort *vp, int x, int y)
 	y = ScaleByZoom(y, vp->zoom) + vp->virtual_top;
 
 	FOR_ALL_VEHICLES(v) {
-		if ((v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) == 0 &&
+		if (v->IsDrawn() && !(v->vehstatus & VS_UNCLICKABLE) &&
 				x >= v->coord.left && x <= v->coord.right &&
 				y >= v->coord.top && y <= v->coord.bottom) {
 
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
index d02d33e2c..a26b278ba 100644
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -16,6 +16,7 @@
 #include "track_type.h"
 #include "command_type.h"
 #include "order_base.h"
+#include "triphistory.h"
 #include "cargopacket.h"
 #include "texteff.hpp"
 #include "engine_type.h"
@@ -240,6 +241,8 @@ public:
 	Money profit_last_year;             ///< Profit last year << 8, low 8 bits are fract
 	Money value;                        ///< Value of the vehicle
 
+	TripHistory trip_history;           ///< Trip History Info
+
 	CargoPayment *cargo_payment;        ///< The cargo payment we're currently in
 
 	Rect coord;                         ///< NOSAVE: Graphical bounding box of the vehicle, i.e. what to redraw on moves.
@@ -353,6 +356,12 @@ public:
 
 	uint GetConsistTotalCapacity() const;
 
+	/**
+	 * Is this vehicle drawn?
+	 * @return true if it is drawn
+	 */
+	bool IsDrawn() const;
+
 	/**
 	 * Marks the vehicles to be redrawn and updates cached variables
 	 *
diff --git a/src/vehicle_gui.cpp b/src/vehicle_gui.cpp
index 777716c64..d05fffeb9 100644
--- a/src/vehicle_gui.cpp
+++ b/src/vehicle_gui.cpp
@@ -37,7 +37,9 @@
 #include "engine_func.h"
 #include "station_base.h"
 #include "tilehighlight_func.h"
+#include "triphistory.h"
 #include "zoom_func.h"
+#include "hotkeys.h"
 
 #include "safeguards.h"
 
@@ -1791,6 +1793,7 @@ static const NWidgetPart _nested_nontrain_vehicle_details_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
 		NWidget(WWT_CAPTION, COLOUR_GREY, WID_VD_CAPTION), SetDataTip(STR_VEHICLE_DETAILS_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_TRIP_HISTORY),SetMinimalSize(44, 0),SetDataTip(STR_TRIP_HISTORY, STR_TRIP_HISTORY_TOOLTIP),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_RENAME_VEHICLE), SetMinimalSize(40, 0), SetMinimalTextLines(1, WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM + 2), SetDataTip(STR_VEHICLE_NAME_BUTTON, STR_NULL /* filled in later */),
 		NWidget(WWT_SHADEBOX, COLOUR_GREY),
 		NWidget(WWT_DEFSIZEBOX, COLOUR_GREY),
@@ -1815,6 +1818,7 @@ static const NWidgetPart _nested_train_vehicle_details_widgets[] = {
 	NWidget(NWID_HORIZONTAL),
 		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
 		NWidget(WWT_CAPTION, COLOUR_GREY, WID_VD_CAPTION), SetDataTip(STR_VEHICLE_DETAILS_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_TRIP_HISTORY),SetMinimalSize(44, 0),SetDataTip(STR_TRIP_HISTORY, STR_TRIP_HISTORY_TOOLTIP),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_RENAME_VEHICLE), SetMinimalSize(40, 0), SetMinimalTextLines(1, WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM + 2), SetDataTip(STR_VEHICLE_NAME_BUTTON, STR_NULL /* filled in later */),
 		NWidget(WWT_SHADEBOX, COLOUR_GREY),
 		NWidget(WWT_DEFSIZEBOX, COLOUR_GREY),
@@ -2161,6 +2165,12 @@ struct VehicleDetailsWindow : Window {
 	virtual void OnClick(Point pt, int widget, int click_count)
 	{
 		switch (widget) {
+			case WID_VD_TRIP_HISTORY: {
+				const Vehicle *v = Vehicle::Get(this->window_number);
+				ShowTripHistoryWindow(v);
+				break;
+			}
+		  
 			case WID_VD_RENAME_VEHICLE: { // rename
 				const Vehicle *v = Vehicle::Get(this->window_number);
 				SetDParam(0, v->index);
@@ -2304,24 +2314,6 @@ static const NWidgetPart _nested_vehicle_view_widgets[] = {
 	EndContainer(),
 };
 
-/** Vehicle view window descriptor for all vehicles but trains. */
-static WindowDesc _vehicle_view_desc(
-	WDP_AUTO, "view_vehicle", 250, 116,
-	WC_VEHICLE_VIEW, WC_NONE,
-	0,
-	_nested_vehicle_view_widgets, lengthof(_nested_vehicle_view_widgets)
-);
-
-/**
- * Vehicle view window descriptor for trains. Only minimum_height and
- *  default_height are different for train view.
- */
-static WindowDesc _train_view_desc(
-	WDP_AUTO, "view_vehicle_train", 250, 134,
-	WC_VEHICLE_VIEW, WC_NONE,
-	0,
-	_nested_vehicle_view_widgets, lengthof(_nested_vehicle_view_widgets)
-);
 
 
 /* Just to make sure, nobody has changed the vehicle type constants, as we are
@@ -2513,6 +2505,7 @@ public:
 		DeleteWindowById(WC_VEHICLE_REFIT, this->window_number, false);
 		DeleteWindowById(WC_VEHICLE_DETAILS, this->window_number, false);
 		DeleteWindowById(WC_VEHICLE_TIMETABLE, this->window_number, false);
+		DeleteWindowById(WC_VEHICLE_TRIP_HISTORY, this->window_number, false);
 	}
 
 	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
@@ -2784,8 +2777,45 @@ public:
 	{
 		::ShowNewGRFInspectWindow(GetGrfSpecFeature(Vehicle::Get(this->window_number)->type), this->window_number);
 	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		if (this->owner != _local_company) return ES_NOT_HANDLED;
+		return Window::OnHotkey(hotkey);
+	}
+
+	static HotkeyList hotkeys;
 };
 
+static Hotkey vehiclegui_hotkeys[] = {
+	Hotkey('G', "vehicle_orders", WID_VV_SHOW_ORDERS),
+	Hotkey('F', "vehicle_go", WID_VV_START_STOP),
+	Hotkey((uint16)0, "vehicle_refit", WID_VV_REFIT),
+	Hotkey((uint16)0, "vehicle_clone", WID_VV_CLONE),
+	HOTKEY_LIST_END
+};	//WID_VV_CENTER_MAIN_VIEW	WID_VV_GOTO_DEPOT WID_VV_SHOW_DETAILS WID_VV_TURN_AROUND WID_VV_FORCE_PROCEED
+HotkeyList VehicleViewWindow::hotkeys("vehiclegui", vehiclegui_hotkeys);
+
+/** Vehicle view window descriptor for all vehicles but trains. */
+static WindowDesc _vehicle_view_desc(
+	WDP_AUTO, "view_vehicle", 250, 116,
+	WC_VEHICLE_VIEW, WC_NONE,
+	0,
+	_nested_vehicle_view_widgets, lengthof(_nested_vehicle_view_widgets),
+	&VehicleViewWindow::hotkeys
+);
+
+/**
+ * Vehicle view window descriptor for trains. Only minimum_height and
+ *  default_height are different for train view.
+ */
+static WindowDesc _train_view_desc(
+	WDP_AUTO, "view_vehicle_train", 250, 134,
+	WC_VEHICLE_VIEW, WC_NONE,
+	0,
+	_nested_vehicle_view_widgets, lengthof(_nested_vehicle_view_widgets),
+	&VehicleViewWindow::hotkeys
+);
 
 /** Shows the vehicle view window of the given vehicle. */
 void ShowVehicleViewWindow(const Vehicle *v)
diff --git a/src/vehicle_gui.h b/src/vehicle_gui.h
index 92975425d..ad5965eec 100644
--- a/src/vehicle_gui.h
+++ b/src/vehicle_gui.h
@@ -103,4 +103,6 @@ Vehicle *CheckClickOnVehicle(const struct ViewPort *vp, int x, int y);
 void DrawVehicleImage(const Vehicle *v, int left, int right, int y, VehicleID selection, EngineImageType image_type, int skip);
 void SetMouseCursorVehicle(const Vehicle *v, EngineImageType image_type);
 
+void ShowTripHistoryWindow(const Vehicle *v);
+
 #endif /* VEHICLE_GUI_H */
diff --git a/src/video/sdl_v.cpp b/src/video/sdl_v.cpp
index 8493ae89f..2a716e4c0 100644
--- a/src/video/sdl_v.cpp
+++ b/src/video/sdl_v.cpp
@@ -733,8 +733,10 @@ void VideoDriver_SDL::MainLoop()
 			next_tick = cur_ticks + MILLISECONDS_PER_TICK;
 
 			bool old_ctrl_pressed = _ctrl_pressed;
+			bool old_alt_pressed = _alt_pressed;
 
 			_ctrl_pressed  = !!(mod & KMOD_CTRL);
+			_alt_pressed = !!(mod & KMOD_ALT);
 			_shift_pressed = !!(mod & KMOD_SHIFT);
 
 			/* determine which directional keys are down */
diff --git a/src/video/win32_v.cpp b/src/video/win32_v.cpp
index 6cee4fef2..edf9e1207 100644
--- a/src/video/win32_v.cpp
+++ b/src/video/win32_v.cpp
@@ -1248,8 +1248,10 @@ void VideoDriver_Win32::MainLoop()
 			next_tick = cur_ticks + MILLISECONDS_PER_TICK;
 
 			bool old_ctrl_pressed = _ctrl_pressed;
+			bool old_alt_pressed = _alt_pressed;
 
 			_ctrl_pressed = _wnd.has_focus && GetAsyncKeyState(VK_CONTROL)<0;
+			_alt_pressed = _wnd.has_focus && GetAsyncKeyState(VK_MENU)<0;
 			_shift_pressed = _wnd.has_focus && GetAsyncKeyState(VK_SHIFT)<0;
 
 			/* determine which directional keys are down */
diff --git a/src/viewport.cpp b/src/viewport.cpp
index 07cecb556..806a15c99 100644
--- a/src/viewport.cpp
+++ b/src/viewport.cpp
@@ -63,6 +63,8 @@
  */
 
 #include "stdafx.h"
+#include "core/math_func.hpp"
+#include "core/smallvec_type.hpp"
 #include "landscape.h"
 #include "viewport_func.h"
 #include "station_base.h"
@@ -80,6 +82,7 @@
 #include "waypoint_func.h"
 #include "window_func.h"
 #include "tilehighlight_func.h"
+#include "zoning.h"
 #include "window_gui.h"
 #include "linkgraph/linkgraph_gui.h"
 #include "viewport_sprite_sorter.h"
@@ -153,6 +156,28 @@ typedef SmallVector<StringSpriteToDraw, 4> StringSpriteToDrawVector;
 typedef SmallVector<ParentSpriteToDraw, 64> ParentSpriteToDrawVector;
 typedef SmallVector<ChildScreenSpriteToDraw, 16> ChildScreenSpriteToDrawVector;
 
+/**
+ * Snapping point for a track.
+ *
+ * Point where a track (rail/road/other) can be snapped to while selecting tracks with RailPolyline
+ * tool (HT_POLY). Besides of x/y coordinates expressed in tile "units" it contains a set of
+ * allowed line directions.
+ */
+struct LineSnapPoint : Point {
+	uint8 dirs; ///< Allowed line directions, set of #Direction bits.
+};
+
+typedef SmallVector<LineSnapPoint, 4> LineSnapPoints; ///< Set of snapping points
+
+/** Coordinates of a RailPolyline track made of 2 connected line segments. */
+struct RailPolyline {
+	Point start;           ///< The point where the first segment starts (as given in LineSnapPoint).
+	Direction first_dir;   ///< Direction of the first line segment.
+	uint first_len;        ///< Length of the first segment - number of track pieces.
+	Direction second_dir;  ///< Direction of the second line segment.
+	uint second_len;       ///< Length of the second segment - number of track pieces.
+};
+
 /** Data structure storing rendering information */
 struct ViewportDrawer {
 	DrawPixelInfo dpi;
@@ -178,6 +203,8 @@ static void MarkViewportDirty(const ViewPort *vp, int left, int top, int right,
 static ViewportDrawer _vd;
 
 TileHighlightData _thd;
+static LineSnapPoints _rail_snap_points; ///< Set of points where a rail track will be snapped to (RailPolyline tool).
+static LineSnapPoint _current_snap_lock; ///< Start point and direction at which selected track is locked on currently (while dragging in RailPolyline mode).
 static TileInfo *_cur_ti;
 bool _draw_bounding_boxes = false;
 bool _draw_dirty_blocks = false;
@@ -780,13 +807,17 @@ static bool IsInRangeInclusive(int begin, int end, int check)
 }
 
 /**
- * Checks whether a point is inside the selected a diagonal rectangle given by _thd.size and _thd.pos
+ * Checks whether a point is inside the selected rectangle given by _thd.size, _thd.pos and _thd.diagonal
  * @param x The x coordinate of the point to be checked.
  * @param y The y coordinate of the point to be checked.
  * @return True if the point is inside the rectangle, else false.
  */
-bool IsInsideRotatedRectangle(int x, int y)
+static bool IsInsideSelectedRectangle(int x, int y)
 {
+	if (!_thd.diagonal) {
+		return IsInsideBS(x, _thd.pos.x, _thd.size.x) && IsInsideBS(y, _thd.pos.y, _thd.size.y);
+	}
+
 	int dist_a = (_thd.size.x + _thd.size.y);      // Rotated coordinate system for selected rectangle.
 	int dist_b = (_thd.size.x - _thd.size.y);      // We don't have to divide by 2. It's all relative!
 	int a = ((x - _thd.pos.x) + (y - _thd.pos.y)); // Rotated coordinate system for the point under scrutiny.
@@ -903,34 +934,26 @@ static void DrawTileSelectionRect(const TileInfo *ti, PaletteID pal)
 	DrawSelectionSprite(sel, pal, ti, 7, FOUNDATION_PART_NORMAL);
 }
 
-static bool IsPartOfAutoLine(int px, int py)
+static HighLightStyle GetPartOfAutoLine(int px, int py, const Point &selstart, const Point &selend, HighLightStyle dir)
 {
-	px -= _thd.selstart.x;
-	py -= _thd.selstart.y;
+	if (!IsInRangeInclusive(selstart.x & ~TILE_UNIT_MASK, selend.x & ~TILE_UNIT_MASK, px)) return HT_DIR_END;
+	if (!IsInRangeInclusive(selstart.y & ~TILE_UNIT_MASK, selend.y & ~TILE_UNIT_MASK, py)) return HT_DIR_END;
 
-	if ((_thd.drawstyle & HT_DRAG_MASK) != HT_LINE) return false;
+	px -= selstart.x & ~TILE_UNIT_MASK;
+	py -= selstart.y & ~TILE_UNIT_MASK;
 
-	switch (_thd.drawstyle & HT_DIR_MASK) {
-		case HT_DIR_X:  return py == 0; // x direction
-		case HT_DIR_Y:  return px == 0; // y direction
-		case HT_DIR_HU: return px == -py || px == -py - 16; // horizontal upper
-		case HT_DIR_HL: return px == -py || px == -py + 16; // horizontal lower
-		case HT_DIR_VL: return px == py || px == py + 16; // vertical left
-		case HT_DIR_VR: return px == py || px == py - 16; // vertical right
-		default:
-			NOT_REACHED();
+	switch (dir) {
+		case HT_DIR_X: return (py == 0) ? HT_DIR_X : HT_DIR_END;
+		case HT_DIR_Y: return (px == 0) ? HT_DIR_Y : HT_DIR_END;
+		case HT_DIR_HU: return (px == -py) ? HT_DIR_HU : (px == -py - (int)TILE_SIZE) ? HT_DIR_HL : HT_DIR_END;
+		case HT_DIR_HL: return (px == -py) ? HT_DIR_HL : (px == -py + (int)TILE_SIZE) ? HT_DIR_HU : HT_DIR_END;
+		case HT_DIR_VL: return (px ==  py) ? HT_DIR_VL : (px ==  py + (int)TILE_SIZE) ? HT_DIR_VR : HT_DIR_END;
+		case HT_DIR_VR: return (px ==  py) ? HT_DIR_VR : (px ==  py - (int)TILE_SIZE) ? HT_DIR_VL : HT_DIR_END;
+		default: NOT_REACHED(); break;
 	}
-}
 
-/* [direction][side] */
-static const HighLightStyle _autorail_type[6][2] = {
-	{ HT_DIR_X,  HT_DIR_X },
-	{ HT_DIR_Y,  HT_DIR_Y },
-	{ HT_DIR_HU, HT_DIR_HL },
-	{ HT_DIR_HL, HT_DIR_HU },
-	{ HT_DIR_VL, HT_DIR_VR },
-	{ HT_DIR_VR, HT_DIR_VL }
-};
+	return HT_DIR_END;
+}
 
 #include "table/autorail.h"
 
@@ -938,18 +961,18 @@ static const HighLightStyle _autorail_type[6][2] = {
  * Draws autorail highlights.
  *
  * @param *ti TileInfo Tile that is being drawn
- * @param autorail_type Offset into _AutorailTilehSprite[][]
+ * @param autorail_type \c HT_DIR_XXX, offset into _AutorailTilehSprite[][]
+ * @param pal Palette to use, -1 to autodetect
  */
-static void DrawAutorailSelection(const TileInfo *ti, uint autorail_type)
+static void DrawAutorailSelection(const TileInfo *ti, HighLightStyle autorail_type, PaletteID pal = -1)
 {
 	SpriteID image;
-	PaletteID pal;
 	int offset;
 
 	FoundationPart foundation_part = FOUNDATION_PART_NORMAL;
 	Slope autorail_tileh = RemoveHalftileSlope(ti->tileh);
 	if (IsHalftileSlope(ti->tileh)) {
-		static const uint _lower_rail[4] = { 5U, 2U, 4U, 3U };
+		static const HighLightStyle _lower_rail[CORNER_END] = { HT_DIR_VR, HT_DIR_HU, HT_DIR_VL, HT_DIR_HL }; // CORNER_W, CORNER_S, CORNER_E, CORNER_N
 		Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
 		if (autorail_type != _lower_rail[halftile_corner]) {
 			foundation_part = FOUNDATION_PART_HALFTILE;
@@ -958,16 +981,17 @@ static void DrawAutorailSelection(const TileInfo *ti, uint autorail_type)
 		}
 	}
 
+	assert(autorail_type < HT_DIR_END);
 	offset = _AutorailTilehSprite[autorail_tileh][autorail_type];
 	if (offset >= 0) {
 		image = SPR_AUTORAIL_BASE + offset;
-		pal = PAL_NONE;
+		if (pal == (PaletteID)-1) pal = _thd.make_square_red ? PALETTE_SEL_TILE_RED : PAL_NONE;
 	} else {
 		image = SPR_AUTORAIL_BASE - offset;
-		pal = PALETTE_SEL_TILE_RED;
+		if (pal == (PaletteID)-1) pal = PALETTE_SEL_TILE_RED;
 	}
 
-	DrawSelectionSprite(image, _thd.make_square_red ? PALETTE_SEL_TILE_RED : pal, ti, 7, foundation_part);
+	DrawSelectionSprite(image, pal, ti, 7, foundation_part);
 }
 
 /**
@@ -980,66 +1004,61 @@ static void DrawTileSelection(const TileInfo *ti)
 	bool is_redsq = _thd.redsq == ti->tile;
 	if (is_redsq) DrawTileSelectionRect(ti, PALETTE_TILE_RED_PULSATING);
 
-	/* No tile selection active? */
-	if ((_thd.drawstyle & HT_DRAG_MASK) == HT_NONE) return;
-
-	if (_thd.diagonal) { // We're drawing a 45 degrees rotated (diagonal) rectangle
-		if (IsInsideRotatedRectangle((int)ti->x, (int)ti->y)) goto draw_inner;
-		return;
-	}
+	switch (_thd.drawstyle & HT_DRAG_MASK) {
+		default: break; // No tile selection active?
 
-	/* Inside the inner area? */
-	if (IsInsideBS(ti->x, _thd.pos.x, _thd.size.x) &&
-			IsInsideBS(ti->y, _thd.pos.y, _thd.size.y)) {
-draw_inner:
-		if (_thd.drawstyle & HT_RECT) {
-			if (!is_redsq) DrawTileSelectionRect(ti, _thd.make_square_red ? PALETTE_SEL_TILE_RED : PAL_NONE);
-		} else if (_thd.drawstyle & HT_POINT) {
-			/* Figure out the Z coordinate for the single dot. */
-			int z = 0;
-			FoundationPart foundation_part = FOUNDATION_PART_NORMAL;
-			if (ti->tileh & SLOPE_N) {
-				z += TILE_HEIGHT;
-				if (RemoveHalftileSlope(ti->tileh) == SLOPE_STEEP_N) z += TILE_HEIGHT;
+		case HT_RECT:
+			if (!is_redsq) {
+				if (IsInsideSelectedRectangle(ti->x, ti->y)) {
+					DrawTileSelectionRect(ti, _thd.make_square_red ? PALETTE_SEL_TILE_RED : PAL_NONE);
+				} else if (_thd.outersize.x > 0 &&
+						/* Check if it's inside the outer area? */
+						IsInsideBS(ti->x, _thd.pos.x + _thd.offs.x, _thd.size.x + _thd.outersize.x) &&
+						IsInsideBS(ti->y, _thd.pos.y + _thd.offs.y, _thd.size.y + _thd.outersize.y)) {
+					/* Draw a blue rect. */
+					DrawTileSelectionRect(ti, PALETTE_SEL_TILE_BLUE);
+				}
 			}
-			if (IsHalftileSlope(ti->tileh)) {
-				Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
-				if ((halftile_corner == CORNER_W) || (halftile_corner == CORNER_E)) z += TILE_HEIGHT;
-				if (halftile_corner != CORNER_S) {
-					foundation_part = FOUNDATION_PART_HALFTILE;
-					if (IsSteepSlope(ti->tileh)) z -= TILE_HEIGHT;
+			break;
+
+		case HT_POINT:
+			if (IsInsideSelectedRectangle(ti->x, ti->y)) {
+				/* Figure out the Z coordinate for the single dot. */
+				int z = 0;
+				FoundationPart foundation_part = FOUNDATION_PART_NORMAL;
+				if (ti->tileh & SLOPE_N) {
+					z += TILE_HEIGHT;
+					if (RemoveHalftileSlope(ti->tileh) == SLOPE_STEEP_N) z += TILE_HEIGHT;
+				}
+				if (IsHalftileSlope(ti->tileh)) {
+					Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
+					if ((halftile_corner == CORNER_W) || (halftile_corner == CORNER_E)) z += TILE_HEIGHT;
+					if (halftile_corner != CORNER_S) {
+						foundation_part = FOUNDATION_PART_HALFTILE;
+						if (IsSteepSlope(ti->tileh)) z -= TILE_HEIGHT;
+					}
 				}
+				DrawSelectionSprite(_cur_dpi->zoom <= ZOOM_LVL_DETAIL ? SPR_DOT : SPR_DOT_SMALL, PAL_NONE, ti, z, foundation_part);
 			}
-			DrawSelectionSprite(_cur_dpi->zoom <= ZOOM_LVL_DETAIL ? SPR_DOT : SPR_DOT_SMALL, PAL_NONE, ti, z, foundation_part);
-		} else if (_thd.drawstyle & HT_RAIL) {
-			/* autorail highlight piece under cursor */
-			HighLightStyle type = _thd.drawstyle & HT_DIR_MASK;
-			assert(type < HT_DIR_END);
-			DrawAutorailSelection(ti, _autorail_type[type][0]);
-		} else if (IsPartOfAutoLine(ti->x, ti->y)) {
-			/* autorail highlighting long line */
-			HighLightStyle dir = _thd.drawstyle & HT_DIR_MASK;
-			uint side;
-
-			if (dir == HT_DIR_X || dir == HT_DIR_Y) {
-				side = 0;
-			} else {
-				TileIndex start = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
-				side = Delta(Delta(TileX(start), TileX(ti->tile)), Delta(TileY(start), TileY(ti->tile)));
+			break;
+
+		case HT_RAIL:
+			if (ti->tile == TileVirtXY(_thd.pos.x, _thd.pos.y)) {
+				assert((_thd.drawstyle & HT_DIR_MASK) < HT_DIR_END);
+				DrawAutorailSelection(ti, _thd.drawstyle & HT_DIR_MASK);
 			}
+			break;
 
-			DrawAutorailSelection(ti, _autorail_type[dir][side]);
+		case HT_LINE: {
+			HighLightStyle type = GetPartOfAutoLine(ti->x, ti->y, _thd.selstart, _thd.selend, _thd.drawstyle & HT_DIR_MASK);
+			if (type < HT_DIR_END) {
+				DrawAutorailSelection(ti, type);
+			} else if ((_thd.drawstyle & HT_POLY) && _thd.dir2 < HT_DIR_END) {
+				type = GetPartOfAutoLine(ti->x, ti->y, _thd.selstart2, _thd.selend2, _thd.dir2);
+				if (type < HT_DIR_END) DrawAutorailSelection(ti, type, PALETTE_SEL_TILE_BLUE);
+			}
+			break;
 		}
-		return;
-	}
-
-	/* Check if it's inside the outer area? */
-	if (!is_redsq && _thd.outersize.x > 0 &&
-			IsInsideBS(ti->x, _thd.pos.x + _thd.offs.x, _thd.size.x + _thd.outersize.x) &&
-			IsInsideBS(ti->y, _thd.pos.y + _thd.offs.y, _thd.size.y + _thd.outersize.y)) {
-		/* Draw a blue rect. */
-		DrawTileSelectionRect(ti, PALETTE_SEL_TILE_BLUE);
-		return;
 	}
 }
 
@@ -1166,7 +1185,10 @@ static void ViewportAddLandscape()
 				_vd.last_foundation_child[1] = NULL;
 
 				_tile_type_procs[tile_type]->draw_tile_proc(&tile_info);
-				if (tile_info.tile != INVALID_TILE) DrawTileSelection(&tile_info);
+                                if (tile_info.tile != INVALID_TILE) {
+                                        DrawTileSelection(&tile_info);
+                                        DrawTileZoning(&tile_info);
+                                }
 			}
 		}
 	}
@@ -1221,8 +1243,7 @@ static void ViewportAddTownNames(DrawPixelInfo *dpi)
 	const Town *t;
 	FOR_ALL_TOWNS(t) {
 		ViewportAddString(dpi, ZOOM_LVL_OUT_16X, &t->cache.sign,
-				_settings_client.gui.population_in_label ? STR_VIEWPORT_TOWN_POP : STR_VIEWPORT_TOWN,
-				STR_VIEWPORT_TOWN_TINY_WHITE, STR_VIEWPORT_TOWN_TINY_BLACK,
+				t->Label(), t->SmallLabel(), STR_VIEWPORT_TOWN_TINY_BLACK,
 				t->index, t->cache.population);
 	}
 }
@@ -1808,7 +1829,7 @@ static void SetSelectionTilesDirty()
 		int x_start = _thd.pos.x;
 		int y_start = _thd.pos.y;
 
-		if (_thd.outersize.x != 0) {
+		if (_thd.outersize.x != 0 || _thd.outersize.y != 0) {
 			x_size  += _thd.outersize.x;
 			x_start += _thd.offs.x;
 			y_size  += _thd.outersize.y;
@@ -2031,7 +2052,7 @@ static void PlaceObject()
 }
 
 
-bool HandleViewportClicked(const ViewPort *vp, int x, int y)
+bool HandleViewportClicked(const ViewPort *vp, int x, int y, bool double_click)
 {
 	const Vehicle *v = CheckClickOnVehicle(vp, x, y);
 
@@ -2039,6 +2060,13 @@ bool HandleViewportClicked(const ViewPort *vp, int x, int y)
 		if (v != NULL && VehicleClicked(v)) return true;
 	}
 
+	/* Double-clicking finishes current RailPolyline and starts new one. */
+	if (double_click && (_thd.place_mode & HT_POLY)) {
+		ClearRailPlacementEndpoints();
+		SetTileSelectSize(1, 1);
+		return true;
+	}
+
 	/* Vehicle placement mode already handled above. */
 	if ((_thd.place_mode & HT_DRAG_MASK) != HT_NONE) {
 		PlaceObject();
@@ -2055,7 +2083,8 @@ bool HandleViewportClicked(const ViewPort *vp, int x, int y)
 		if (IsCompanyBuildableVehicleType(v)) {
 			v = v->First();
 			if (_ctrl_pressed && v->owner == _local_company) {
-				StartStopVehicle(v, true);
+				if (_settings_client.gui.enable_ctrl_click_start_stop )
+					StartStopVehicle(v, true);
 			} else {
 				ShowVehicleViewWindow(v);
 			}
@@ -2167,8 +2196,8 @@ void SetTileSelectSize(int w, int h)
 
 void SetTileSelectBigSize(int ox, int oy, int sx, int sy)
 {
-	_thd.offs.x = ox * TILE_SIZE;
-	_thd.offs.y = oy * TILE_SIZE;
+	_thd.new_offs.x = ox * TILE_SIZE;
+	_thd.new_offs.y = oy * TILE_SIZE;
 	_thd.new_outersize.x = sx * TILE_SIZE;
 	_thd.new_outersize.y = sy * TILE_SIZE;
 }
@@ -2208,7 +2237,36 @@ Window *TileHighlightData::GetCallbackWnd()
 	return FindWindowById(this->window_class, this->window_number);
 }
 
-
+static HighLightStyle CalcPolyrailDrawstyle(Point pt, bool dragging);
+
+static inline void CalcNewRailPolylineOutersize()
+{
+	/* use the 'outersize' to mark the second (blue) part of a RailPolyline selection */
+	if (_thd.dir2 < HT_DIR_END) {
+		/* get bounds of the second part */
+		int outer_x1 = _thd.selstart2.x & ~TILE_UNIT_MASK;
+		int outer_y1 = _thd.selstart2.y & ~TILE_UNIT_MASK;
+		int outer_x2 = _thd.selend2.x & ~TILE_UNIT_MASK;
+		int outer_y2 = _thd.selend2.y & ~TILE_UNIT_MASK;
+		if (outer_x1 > outer_x2) Swap(outer_x1, outer_x2);
+		if (outer_y1 > outer_y2) Swap(outer_y1, outer_y2);
+		/* include the first part */
+		outer_x1 = min<int>(outer_x1, _thd.new_pos.x);
+		outer_y1 = min<int>(outer_y1, _thd.new_pos.y);
+		outer_x2 = max<int>(outer_x2, _thd.new_pos.x + _thd.new_size.x - TILE_SIZE);
+		outer_y2 = max<int>(outer_y2, _thd.new_pos.y + _thd.new_size.y - TILE_SIZE);
+		/* write new values */
+		_thd.new_offs.x = outer_x1 - _thd.new_pos.x;
+		_thd.new_offs.y = outer_y1 - _thd.new_pos.y;
+		_thd.new_outersize.x = outer_x2 - outer_x1 + TILE_SIZE - _thd.new_size.x;
+		_thd.new_outersize.y = outer_y2 - outer_y1 + TILE_SIZE - _thd.new_size.y;
+	} else {
+		_thd.new_offs.x = 0;
+		_thd.new_offs.y = 0;
+		_thd.new_outersize.x = 0;
+		_thd.new_outersize.y = 0;
+	}
+}
 
 /**
  * Updates tile highlighting for all cases.
@@ -2248,6 +2306,9 @@ void UpdateTileSelection()
 				_thd.new_size.x += TILE_SIZE;
 				_thd.new_size.y += TILE_SIZE;
 			}
+			if (_thd.place_mode & HT_POLY) {
+				CalcNewRailPolylineOutersize();
+			}
 			new_drawstyle = _thd.next_drawstyle;
 		}
 	} else if ((_thd.place_mode & HT_DRAG_MASK) != HT_NONE) {
@@ -2265,10 +2326,39 @@ void UpdateTileSelection()
 					y1 += TILE_SIZE / 2;
 					break;
 				case HT_RAIL:
-					/* Draw one highlighted tile in any direction */
-					new_drawstyle = GetAutorailHT(pt.x, pt.y);
-					break;
 				case HT_LINE:
+					/* HT_POLY */
+					if (_thd.place_mode & HT_POLY) {
+						if (_rail_snap_points.Length() > 0) {
+						new_drawstyle = CalcPolyrailDrawstyle(pt, false);
+						if (new_drawstyle != HT_NONE) {
+							x1 = _thd.selstart.x & ~TILE_UNIT_MASK;
+							y1 = _thd.selstart.y & ~TILE_UNIT_MASK;
+							int x2 = _thd.selend.x & ~TILE_UNIT_MASK;
+							int y2 = _thd.selend.y & ~TILE_UNIT_MASK;
+							if (x1 > x2) Swap(x1, x2);
+							if (y1 > y2) Swap(y1, y2);
+							_thd.new_pos.x = x1;
+							_thd.new_pos.y = y1;
+							_thd.new_size.x = x2 - x1 + TILE_SIZE;
+							_thd.new_size.y = y2 - y1 + TILE_SIZE;
+							CalcNewRailPolylineOutersize();
+							}
+							break;
+						}
+						_thd.new_offs.x = 0;
+						_thd.new_offs.y = 0;
+						_thd.new_outersize.x = 0;
+						_thd.new_outersize.y = 0;
+						_thd.dir2 = HT_DIR_END;
+					}
+					/* HT_RAIL */
+					if (_thd.place_mode & HT_RAIL) {
+						/* Draw one highlighted tile in any direction */
+						new_drawstyle = GetAutorailHT(pt.x, pt.y);
+						break;
+					}
+					/* HT_LINE */
 					switch (_thd.place_mode & HT_DIR_MASK) {
 						case HT_DIR_X: new_drawstyle = HT_LINE | HT_DIR_X; break;
 						case HT_DIR_Y: new_drawstyle = HT_LINE | HT_DIR_Y; break;
@@ -2287,6 +2377,8 @@ void UpdateTileSelection()
 					}
 					_thd.selstart.x = x1 & ~TILE_UNIT_MASK;
 					_thd.selstart.y = y1 & ~TILE_UNIT_MASK;
+					_thd.selend.x = x1;
+					_thd.selend.y = y1;
 					break;
 				default:
 					NOT_REACHED();
@@ -2300,6 +2392,7 @@ void UpdateTileSelection()
 	if (_thd.drawstyle != new_drawstyle ||
 			_thd.pos.x != _thd.new_pos.x || _thd.pos.y != _thd.new_pos.y ||
 			_thd.size.x != _thd.new_size.x || _thd.size.y != _thd.new_size.y ||
+			_thd.offs.x != _thd.new_offs.x || _thd.offs.y != _thd.new_offs.y ||
 			_thd.outersize.x != _thd.new_outersize.x ||
 			_thd.outersize.y != _thd.new_outersize.y ||
 			_thd.diagonal    != new_diagonal) {
@@ -2309,6 +2402,7 @@ void UpdateTileSelection()
 		_thd.drawstyle = new_drawstyle;
 		_thd.pos = _thd.new_pos;
 		_thd.size = _thd.new_size;
+		_thd.offs = _thd.new_offs;
 		_thd.outersize = _thd.new_outersize;
 		_thd.diagonal = new_diagonal;
 		_thd.dirty = 0xff;
@@ -2363,6 +2457,7 @@ void VpStartPlaceSizing(TileIndex tile, ViewportPlaceMethod method, ViewportDrag
 	} else if (_thd.place_mode & (HT_RAIL | HT_LINE)) {
 		_thd.place_mode = HT_SPECIAL | others;
 		_thd.next_drawstyle = _thd.drawstyle | others;
+		_current_snap_lock.x = -1;
 	} else {
 		_thd.place_mode = HT_SPECIAL | others;
 		_thd.next_drawstyle = HT_POINT | others;
@@ -2558,7 +2653,32 @@ static int CalcHeightdiff(HighLightStyle style, uint distance, TileIndex start_t
 	return (int)(h1 - h0) * TILE_HEIGHT_STEP;
 }
 
-static const StringID measure_strings_length[] = {STR_NULL, STR_MEASURE_LENGTH, STR_MEASURE_LENGTH_HEIGHTDIFF};
+//static void ShowLengthMeasurement(HighLightStyle style, TileIndex start_tile, TileIndex end_tile, TooltipCloseCondition close_cond = TCC_LEFT_CLICK, bool show_single_tile_length = false)
+static void ShowLengthMeasurement(HighLightStyle style, TileIndex start_tile, TileIndex end_tile, TooltipCloseCondition close_cond = TCC_RIGHT_CLICK, bool show_single_tile_length = false)
+{
+	static const StringID measure_strings_length[] = {STR_NULL, STR_MEASURE_LENGTH, STR_MEASURE_LENGTH_HEIGHTDIFF};
+
+	if (_settings_client.gui.measure_tooltip) {
+		uint distance = DistanceManhattan(start_tile, end_tile) + 1;
+		byte index = 0;
+		uint64 params[2];
+
+		if (show_single_tile_length || distance != 1) {
+			int heightdiff = CalcHeightdiff(style, distance, start_tile, end_tile);
+			/* If we are showing a tooltip for horizontal or vertical drags,
+			 * 2 tiles have a length of 1. To bias towards the ceiling we add
+			 * one before division. It feels more natural to count 3 lengths as 2 */
+			if ((style & HT_DIR_MASK) != HT_DIR_X && (style & HT_DIR_MASK) != HT_DIR_Y) {
+				distance = CeilDiv(distance, 2);
+			}
+
+			params[index++] = distance;
+			if (heightdiff != 0) params[index++] = heightdiff;
+		}
+
+		ShowMeasurementTooltips(measure_strings_length[index], index, params, close_cond);
+	}
+}
 
 /**
  * Check for underflowing the map.
@@ -2589,6 +2709,162 @@ static void CheckOverflow(int &test, int &other, int max, int mult)
 	test = max;
 }
 
+static const uint X_DIRS = (1 << DIR_NE) | (1 << DIR_SW);
+static const uint Y_DIRS = (1 << DIR_SE) | (1 << DIR_NW);
+static const uint HORZ_DIRS = (1 << DIR_W) | (1 << DIR_E);
+static const uint VERT_DIRS = (1 << DIR_N) | (1 << DIR_S);
+
+Trackdir PointDirToTrackdir(const Point &pt, Direction dir)
+{
+	Trackdir ret;
+
+	if (IsDiagonalDirection(dir)) {
+		ret = DiagDirToDiagTrackdir(DirToDiagDir(dir));
+	} else {
+		int x = pt.x & TILE_UNIT_MASK;
+		int y = pt.y & TILE_UNIT_MASK;
+		int ns = x + y;
+		int we = y - x;
+		if (HasBit(HORZ_DIRS, dir)) {
+			ret = TrackDirectionToTrackdir(ns < (int)TILE_SIZE ? TRACK_UPPER : TRACK_LOWER, dir);
+		} else {
+			ret = TrackDirectionToTrackdir(we < 0 ? TRACK_LEFT : TRACK_RIGHT, dir);
+		}
+	}
+
+	return ret;
+}
+
+static bool FindRailPolyline(const Point &pt, const LineSnapPoint &start, RailPolyline *ret)
+{
+	/* relative coordinats of the mouse point (offset against the snap point) */
+	int x = pt.x - start.x;
+	int y = pt.y - start.y;
+	int we = y - x;
+	int ns = x + y;
+
+	/* in-tile alignment of the snap point (there are two variants: [0, 8] or [8, 0]) */
+	uint align_x = start.x & TILE_UNIT_MASK;
+	uint align_y = start.y & TILE_UNIT_MASK;
+	assert((align_x == TILE_SIZE / 2 && align_y == 0 && !(start.dirs & X_DIRS)) || (align_x == 0 && align_y == TILE_SIZE / 2 && !(start.dirs & Y_DIRS)));
+
+	/* absolute distance between points (in tiles) */
+	uint d_x = abs(RoundDivSU(x < 0 ? x - align_y : x + align_y, TILE_SIZE));
+	uint d_y = abs(RoundDivSU(y < 0 ? y - align_x : y + align_x, TILE_SIZE));
+	uint d_ns = abs(RoundDivSU(ns, TILE_SIZE));
+	uint d_we = abs(RoundDivSU(we, TILE_SIZE));
+
+	/* Find on which quadrant is the mouse point (reltively to the snap point).
+	 * Numeration (clockwise like in Direction):
+	 * ortho            diag
+	 *   \   2   /       2 | 3
+	 *     \   /         --+---> [we]
+	 *  1    X    3      1 | 0
+	 *     /   \           v
+	 *  [x]  0  [y]       [ns]          */
+	uint ortho_quadrant = 2 * (x < 0) + ((x < 0) != (y < 0)); // implicit cast: false/true --> 0/1
+	uint diag_quadrant = 2 * (ns < 0) + ((ns < 0) != (we < 0));
+
+	/* direction from the snap point to the mouse point */
+	Direction ortho_line_dir = ChangeDir(DIR_S, (DirDiff)(2 * ortho_quadrant)); // DIR_S is the middle of the ortho quadrant no. 0
+	Direction diag_line_dir = ChangeDir(DIR_SE, (DirDiff)(2 * diag_quadrant));  // DIR_SE is the middle of the diag quadrant no. 0
+	if (!HasBit(start.dirs, ortho_line_dir) && !HasBit(start.dirs, diag_line_dir)) return false;
+
+	/* length of booth segments of auto line (choosing orthogonal direction first) */
+	uint ortho_len = 0, ortho_len2 = 0;
+	if (HasBit(start.dirs, ortho_line_dir)) {
+		bool is_len_even = (align_x != 0) ? d_x >= d_y : d_x <= d_y;
+		ortho_len = 2 * min(d_x, d_y) - (int)is_len_even;
+		assert((int)ortho_len >= 0);
+		if (d_ns == 0 || d_we == 0) { // just single segment?
+			ortho_len++;
+		} else {
+			ortho_len2 = abs((int)d_x - (int)d_y) + (int)is_len_even;
+		}
+	}
+
+	/* length of booth segments of auto line (choosing diagonal direction first) */
+	uint diag_len = 0, diag_len2 = 0;
+	if (HasBit(start.dirs, diag_line_dir)) {
+		if (d_x == 0 || d_y == 0) { // just single segment?
+			diag_len = d_x + d_y;
+		} else {
+			diag_len = min(d_ns, d_we);
+			diag_len2 = d_x + d_y - diag_len;
+		}
+	}
+
+	/* choose the best variant */
+	if (ortho_len != 0 && diag_len != 0) {
+		/* in the first place, choose this line whose first segment ends up closer
+		 * to the mouse point (thus the second segment is shorter) */
+		int cmp = ortho_len2 - diag_len2;
+		/* if equeal, choose the shorter line */
+		if (cmp == 0) cmp = ortho_len - diag_len;
+		/* finally look at small "units" and choose the line which is closer to the mouse point */
+		if (cmp == 0) cmp = min(abs(we), abs(ns)) - min(abs(x), abs(y));
+		/* based on comparison, disable one of variants */
+		if (cmp > 0) {
+			ortho_len = 0;
+		} else {
+			diag_len = 0;
+		}
+	}
+
+	/* store results */
+	if (ortho_len != 0) {
+		ret->first_dir = ortho_line_dir;
+		ret->first_len = ortho_len;
+		ret->second_dir = (ortho_len2 != 0) ? diag_line_dir : INVALID_DIR;
+		ret->second_len = ortho_len2;
+	} else if (diag_len != 0) {
+		ret->first_dir = diag_line_dir;
+		ret->first_len = diag_len;
+		ret->second_dir = (diag_len2 != 0) ? ortho_line_dir : INVALID_DIR;
+		ret->second_len = diag_len2;
+	} else {
+		return false;
+	}
+
+	ret->start = start;
+	return true;
+}
+
+/**
+ * Calculate squared euclidean distance between two points.
+ * @param a the first point
+ * @param b the second point
+ * @return |b - a| ^ 2
+ */
+static inline uint SqrDist(const Point &a, const Point &b)
+{
+	return (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);
+}
+
+static LineSnapPoint *FindBestRailPolyline(const Point &pt, LineSnapPoint *snap_points, uint num_points, RailPolyline *ret)
+{
+	while (num_points > 0) {
+		/* run a single bubble sort loop to find the closest snap point (push it to the and of the array) */
+		uint prev_dist = SqrDist(snap_points[0], pt);
+		for (uint i = 1; i < num_points; i++) {
+			uint next_dist = SqrDist(snap_points[i], pt);
+			if (prev_dist < next_dist) {
+				Swap(snap_points[i], snap_points[i - 1]);
+			} else {
+				prev_dist = next_dist;
+			}
+		}
+
+		/* try to fit a line */
+		if (FindRailPolyline(pt, snap_points[num_points - 1], ret)) return &snap_points[num_points - 1];
+
+		/* repeat procedure for the rest of snap points */
+		--num_points;
+	}
+
+	return NULL;
+}
+
 /** while dragging */
 static void CalcRaildirsDrawstyle(int x, int y, int method)
 {
@@ -2775,32 +3051,78 @@ static void CalcRaildirsDrawstyle(int x, int y, int method)
 		}
 	}
 
-	if (_settings_client.gui.measure_tooltip) {
-		TileIndex t0 = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
-		TileIndex t1 = TileVirtXY(x, y);
-		uint distance = DistanceManhattan(t0, t1) + 1;
-		byte index = 0;
-		uint64 params[2];
+	_thd.selend.x = x;
+	_thd.selend.y = y;
+	_thd.next_drawstyle = b;
 
-		if (distance != 1) {
-			int heightdiff = CalcHeightdiff(b, distance, t0, t1);
-			/* If we are showing a tooltip for horizontal or vertical drags,
-			 * 2 tiles have a length of 1. To bias towards the ceiling we add
-			 * one before division. It feels more natural to count 3 lengths as 2 */
-			if ((b & HT_DIR_MASK) != HT_DIR_X && (b & HT_DIR_MASK) != HT_DIR_Y) {
-				distance = CeilDiv(distance, 2);
-			}
+	ShowLengthMeasurement(b, TileVirtXY(_thd.selstart.x, _thd.selstart.y), TileVirtXY(_thd.selend.x, _thd.selend.y));
+}
 
-			params[index++] = distance;
-			if (heightdiff != 0) params[index++] = heightdiff;
+static HighLightStyle CalcPolyrailDrawstyle(Point pt, bool dragging)
+{
+	/* find the best track */
+	RailPolyline line;
+
+	HighLightStyle ret = HT_LINE | HT_POLY;
+
+	if (!dragging) {
+		_current_snap_lock.x = -1;
+		if (FindBestRailPolyline(pt, _rail_snap_points.Begin(), _rail_snap_points.Length(), &line) == NULL) ret = HT_NONE; // no match
+	} else if (_current_snap_lock.x != -1) {
+		if (FindBestRailPolyline(pt, &_current_snap_lock, 1, &line) == NULL) ret = HT_NONE; // no match
+	} else {
+		const LineSnapPoint *snap_point = FindBestRailPolyline(pt, _rail_snap_points.Begin(), _rail_snap_points.Length(), &line);
+		if (snap_point == NULL) {
+			ret = HT_NONE; // no match
+		} else  {
+			_current_snap_lock = *snap_point;
+			_current_snap_lock.dirs &= (1 << line.first_dir) | (1 << ReverseDir(line.first_dir)); // lock direction
 		}
+	}
 
-		ShowMeasurementTooltips(measure_strings_length[index], index, params);
+	if (ret == HT_NONE) {
+		_thd.selstart.x = -1;
+		_thd.selend.x = -1;
+		_thd.selstart2.x = -1;
+		_thd.selend2.x = -1;
+		_thd.dir2 = HT_DIR_END;
+		return ret;
+	}
+
+	TileIndexDiffC first_dir = TileIndexDiffCByDir(line.first_dir);
+	_thd.selstart.x  = line.start.x;
+	_thd.selstart.y  = line.start.y;
+	_thd.selend.x    = _thd.selstart.x + line.first_len * first_dir.x * (IsDiagonalDirection(line.first_dir) ? TILE_SIZE : TILE_SIZE / 2);
+	_thd.selend.y    = _thd.selstart.y + line.first_len * first_dir.y * (IsDiagonalDirection(line.first_dir) ? TILE_SIZE : TILE_SIZE / 2);
+	_thd.selstart2.x = _thd.selend.x;
+	_thd.selstart2.y = _thd.selend.y;
+	_thd.selstart.x  += first_dir.x;
+	_thd.selstart.y  += first_dir.y;
+	_thd.selend.x    -= first_dir.x;
+	_thd.selend.y    -= first_dir.y;
+	Trackdir seldir = PointDirToTrackdir(_thd.selstart, line.first_dir);
+	_thd.selstart.x  &= ~TILE_UNIT_MASK;
+	_thd.selstart.y  &= ~TILE_UNIT_MASK;
+	ret |= (HighLightStyle)TrackdirToTrack(seldir);
+
+	if (line.second_len != 0) {
+		TileIndexDiffC second_dir = TileIndexDiffCByDir(line.second_dir);
+		_thd.selend2.x   = _thd.selstart2.x + line.second_len * second_dir.x * (IsDiagonalDirection(line.second_dir) ? TILE_SIZE : TILE_SIZE / 2);
+		_thd.selend2.y   = _thd.selstart2.y + line.second_len * second_dir.y * (IsDiagonalDirection(line.second_dir) ? TILE_SIZE : TILE_SIZE / 2);
+		_thd.selstart2.x += second_dir.x;
+		_thd.selstart2.y += second_dir.y;
+		_thd.selend2.x   -= second_dir.x;
+		_thd.selend2.y   -= second_dir.y;
+		Trackdir seldir2 = PointDirToTrackdir(_thd.selstart2, line.second_dir);
+		_thd.selstart2.x &= ~TILE_UNIT_MASK;
+		_thd.selstart2.y &= ~TILE_UNIT_MASK;
+		_thd.dir2 = (HighLightStyle)TrackdirToTrack(seldir2);
+	} else {
+		_thd.dir2 = HT_DIR_END;
 	}
 
-	_thd.selend.x = x;
-	_thd.selend.y = y;
-	_thd.next_drawstyle = b;
+	ShowLengthMeasurement(ret, TileVirtXY(_thd.selstart.x, _thd.selstart.y), TileVirtXY(_thd.selend.x, _thd.selend.y), TCC_HOVER, true);
+	return ret;
 }
 
 /**
@@ -2820,6 +3142,12 @@ void VpSelectTilesWithMethod(int x, int y, ViewportPlaceMethod method)
 		return;
 	}
 
+	if ((_thd.place_mode & HT_POLY) && _rail_snap_points.Length() > 0) {
+		Point pt = { x, y };
+		_thd.next_drawstyle = CalcPolyrailDrawstyle(pt, true);
+		return;
+	}
+
 	/* Special handling of drag in any (8-way) direction */
 	if (method & (VPM_RAILDIRS | VPM_SIGNALDIRS)) {
 		_thd.selend.x = x;
@@ -2872,28 +3200,54 @@ calc_heightdiff_single_direction:;
 				x = sx + Clamp(x - sx, -limit, limit);
 				y = sy + Clamp(y - sy, -limit, limit);
 			}
-			if (_settings_client.gui.measure_tooltip) {
-				TileIndex t0 = TileVirtXY(sx, sy);
-				TileIndex t1 = TileVirtXY(x, y);
-				uint distance = DistanceManhattan(t0, t1) + 1;
-				byte index = 0;
-				uint64 params[2];
-
-				if (distance != 1) {
-					/* With current code passing a HT_LINE style to calculate the height
-					 * difference is enough. However if/when a point-tool is created
-					 * with this method, function should be called with new_style (below)
-					 * instead of HT_LINE | style case HT_POINT is handled specially
-					 * new_style := (_thd.next_drawstyle & HT_RECT) ? HT_LINE | style : _thd.next_drawstyle; */
-					int heightdiff = CalcHeightdiff(HT_LINE | style, 0, t0, t1);
+			/* With current code passing a HT_LINE style to calculate the height
+			 * difference is enough. However if/when a point-tool is created
+			 * with this method, function should be called with new_style (below)
+			 * instead of HT_LINE | style case HT_POINT is handled specially
+			 * new_style := (_thd.next_drawstyle & HT_RECT) ? HT_LINE | style : _thd.next_drawstyle; */
+			ShowLengthMeasurement(HT_LINE | style, TileVirtXY(sx, sy), TileVirtXY(x, y));
+			break;
 
-					params[index++] = distance;
-					if (heightdiff != 0) params[index++] = heightdiff;
+    case VPM_A_B_LINE: { // drag an A to B line
+			TileIndex t0 = TileVirtXY(sx, sy);
+			TileIndex t1 = TileVirtXY(x, y);
+			uint dx = Delta(TileX(t0), TileX(t1)) + 1;
+			uint dy = Delta(TileY(t0), TileY(t1)) + 1;
+			byte index = 0;
+			uint64 params[5];
+			memset( params, 0, sizeof( params ) );
+
+			/* If dragging an area (eg dynamite tool) and it is actually a single
+			 * row/column, change the type to 'line' to get proper calculation for height */
+			style = (HighLightStyle)_thd.next_drawstyle;
+			if (style & HT_RECT) {
+				if (dx == 1) {
+					style = HT_LINE | HT_DIR_Y;
+				} else if (dy == 1) {
+					style = HT_LINE | HT_DIR_X;
 				}
+			}
 
-				ShowMeasurementTooltips(measure_strings_length[index], index, params);
+			int heightdiff = 0;
+
+			if (dx != 1 || dy != 1) {
+				heightdiff = CalcHeightdiff(style, 0, t0, t1);
+				params[index++] = DistanceManhattan(t0, t1);
+				params[index++] = sqrtl(dx * dx + dy * dy); //DistanceSquare does not like big numbers
+				
+			} else {
+				index += 2;
 			}
+			
+			params[index++] = DistanceFromEdge(t1);
+			//params[index++] = GetTileMaxZ(t1) / TILE_HEIGHT * TILE_HEIGHT_STEP; //changed ^^
+			params[index++] = GetTileMaxZ(t1) * TILE_HEIGHT_STEP;
+			params[index++] = heightdiff;
+			//Show always the measurement tooltip
+			//GuiShowTooltips(_thd.GetCallbackWnd(),STR_MEASURE_DIST_HEIGHTDIFF, index, params, TCC_LEFT_CLICK);
+			GuiShowTooltips(_thd.GetCallbackWnd(),STR_MEASURE_DIST_HEIGHTDIFF, index, params, TCC_RIGHT_CLICK);
 			break;
+		}
 
 		case VPM_X_AND_Y_LIMITED: // Drag an X by Y constrained rect area.
 			limit = (_thd.sizelimit - 1) * TILE_SIZE;
@@ -3003,7 +3357,7 @@ EventState VpHandlePlaceSizingDrag()
 	} else if (_thd.select_method & VPM_SIGNALDIRS) {
 		_thd.place_mode = HT_RECT | others;
 	} else if (_thd.select_method & VPM_RAILDIRS) {
-		_thd.place_mode = (_thd.select_method & ~VPM_RAILDIRS) ? _thd.next_drawstyle : (HT_RAIL | others);
+		_thd.place_mode = (_thd.select_method & ~VPM_RAILDIRS ? _thd.next_drawstyle : HT_RAIL) | others;
 	} else {
 		_thd.place_mode = HT_POINT | others;
 	}
@@ -3090,6 +3444,69 @@ void ResetObjectToPlace()
 	SetObjectToPlace(SPR_CURSOR_MOUSE, PAL_NONE, HT_NONE, WC_MAIN_WINDOW, 0);
 }
 
+static LineSnapPoint LineSnapPointAtRailTrackEndpoint(TileIndex tile, DiagDirection exit_dir, bool bidirectional)
+{
+	LineSnapPoint ret;
+	ret.x = (TILE_SIZE / 2) * (uint)(2 * TileX(tile) + TileIndexDiffCByDiagDir(exit_dir).x + 1);
+	ret.y = (TILE_SIZE / 2) * (uint)(2 * TileY(tile) + TileIndexDiffCByDiagDir(exit_dir).y + 1);
+
+	ret.dirs = 0;
+	SetBit(ret.dirs, DiagDirToDir(exit_dir));
+	SetBit(ret.dirs, ChangeDir(DiagDirToDir(exit_dir), DIRDIFF_45LEFT));
+	SetBit(ret.dirs, ChangeDir(DiagDirToDir(exit_dir), DIRDIFF_45RIGHT));
+	if (bidirectional) ret.dirs |= ROR<uint8>(ret.dirs, DIRDIFF_REVERSE);
+
+	return ret;
+}
+
+/**
+ * Store the position of lastly built rail track; for highlighting purposes.
+ *
+ * In "RailPolyline" highlighting mode, the stored end point will be used as a snapping point for new
+ * tracks allowing to place multi-segment RailPolylines.
+ *
+ * @param start_tile         tile where the track starts
+ * @param end_tile           tile where the track ends
+ * @param start_track        track piece on the start_tile
+ * @param bidirectional_exit whether to allow to highlight next track in any direction; otherwise new track will have to fallow the stored one (usefull when placing tunnels and bridges)
+ */
+void StoreRailPlacementEndpoints(TileIndex start_tile, TileIndex end_tile, Track start_track, bool bidirectional_exit)
+{
+	if (start_tile != INVALID_TILE && end_tile != INVALID_TILE) {
+		/* calculate trackdirs at booth ends of the track */
+		Trackdir exit_trackdir_at_start = TrackToTrackdir(start_track);
+		Trackdir exit_trackdir_at_end = ReverseTrackdir(TrackToTrackdir(start_track));
+		if (start_tile != end_tile) { // multi-tile case
+			/* determine proper direction (pointing outside of the track) */
+			uint distance = DistanceManhattan(start_tile, end_tile);
+			if (distance > DistanceManhattan(TileAddByDiagDir(start_tile, TrackdirToExitdir(exit_trackdir_at_start)), end_tile)) {
+				Swap(exit_trackdir_at_start, exit_trackdir_at_end);
+			}
+			/* determine proper track on the end tile - switch between upper/lower or left/right based on the length */
+			if (distance % 2 != 0) exit_trackdir_at_end = NextTrackdir(exit_trackdir_at_end);
+		}
+
+		LineSnapPoint snap_start = LineSnapPointAtRailTrackEndpoint(start_tile, TrackdirToExitdir(exit_trackdir_at_start), bidirectional_exit);
+		LineSnapPoint snap_end = LineSnapPointAtRailTrackEndpoint(end_tile, TrackdirToExitdir(exit_trackdir_at_end), bidirectional_exit);
+		/* Find if we already had these coordinates before. */
+		LineSnapPoint *snap;
+		for (snap = _rail_snap_points.Begin(); snap != _rail_snap_points.End(); snap++) {
+			/* Coordinates found - remove the snap point as it was already used. */
+			if (snap->x == snap_start.x && snap->y == snap_start.y) snap_start.dirs = 0;
+			if (snap->x == snap_end.x && snap->y == snap_end.y) snap_end.dirs = 0;
+		}
+		/* Create new snap point set. */
+		_rail_snap_points.Clear();
+		if (snap_start.dirs != 0) *_rail_snap_points.Append() = snap_start;
+		if (snap_end.dirs != 0) *_rail_snap_points.Append() = snap_end;
+	}
+}
+
+void ClearRailPlacementEndpoints()
+{
+	_rail_snap_points.Clear();
+}
+
 Point GetViewportStationMiddle(const ViewPort *vp, const Station *st)
 {
 	int x = TileX(st->xy) * TILE_SIZE;
diff --git a/src/viewport_func.h b/src/viewport_func.h
index 11fd2fed2..dd8553a74 100644
--- a/src/viewport_func.h
+++ b/src/viewport_func.h
@@ -60,7 +60,7 @@ void ViewportAddString(const DrawPixelInfo *dpi, ZoomLevel small_from, const Vie
 void StartSpriteCombine();
 void EndSpriteCombine();
 
-bool HandleViewportClicked(const ViewPort *vp, int x, int y);
+bool HandleViewportClicked(const ViewPort *vp, int x, int y, bool double_click);
 void SetRedErrorSquare(TileIndex tile);
 void SetTileSelectSize(int w, int h);
 void SetTileSelectBigSize(int ox, int oy, int sx, int sy);
diff --git a/src/viewport_gui.cpp b/src/viewport_gui.cpp
index 9c89a85f8..4ebc88af0 100644
--- a/src/viewport_gui.cpp
+++ b/src/viewport_gui.cpp
@@ -16,6 +16,12 @@
 #include "strings_func.h"
 #include "zoom_func.h"
 #include "window_func.h"
+#include "gfx_func.h"
+#include "industry.h"
+#include "town_map.h"
+#include "station_gui.h"
+#include "station_base.h"
+#include "cargotype.h"
 
 #include "widgets/viewport_widget.h"
 
@@ -154,6 +160,98 @@ public:
 		/* Only handle zoom message if intended for us (msg ZOOM_IN/ZOOM_OUT) */
 		HandleZoomMessage(this, this->viewport, WID_EV_ZOOM_IN, WID_EV_ZOOM_OUT);
 	}
+
+  virtual void OnMouseOver(Point pt, int widget)
+	{
+		/* Show tooltip with last month production or town name */
+		if (pt.x != -1 && _settings_client.gui.enable_extra_tooltips) {
+			GuiPrepareTooltipsExtra(this);
+		} else if (pt.x != -1) {
+			TileIndex tile;
+			const bool viewport_is_in_map_mode = (this->viewport->zoom > ZOOM_LVL_MAX);
+			//const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_MAX);
+			//const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_DRAW_MAP);
+			if (viewport_is_in_map_mode) {
+        // Disabled, for now :)
+				/*NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(WID_EV_VIEWPORT);
+				const int a = ((ScaleByZoom(pt.x - nvp->pos_x, this->viewport->zoom) + this->viewport->virtual_left) >> 2) / ZOOM_LVL_BASE;
+				const int b = ((ScaleByZoom(pt.y - nvp->pos_y, this->viewport->zoom) + this->viewport->virtual_top) >> 1) / ZOOM_LVL_BASE;
+				tile = TileVirtXY(b - a, b + a);*/
+			} else {
+				const Point p = GetTileBelowCursor();
+				tile = TileVirtXY(p.x, p.y);
+			}
+			if (tile >= MapSize()) return;
+
+			switch (GetTileType(tile)) {
+				case MP_ROAD:
+					if (IsRoadDepot(tile)) return;
+					/* FALL THROUGH */
+				case MP_HOUSE: {
+					if (HasBit(_display_opt, DO_SHOW_TOWN_NAMES)) return; // No need for a town name tooltip when it is already displayed
+					if (!viewport_is_in_map_mode) return;
+					const TownID tid = GetTownIndex(tile);
+					if (!tid) return;
+					SetDParam(0, tid);
+					GuiShowTooltips(this, STR_TOWN_NAME_TOOLTIP, 0, NULL, TCC_HOVER);
+					break;
+				}
+				case MP_INDUSTRY: {
+					const Industry *ind = Industry::GetByTile(tile);
+					const IndustrySpec *indsp = GetIndustrySpec(ind->type);
+
+					StringID str = STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP;
+					uint prm_count = 0;
+					SetDParam(prm_count++, indsp->name);
+					for (byte i = 0; i < lengthof(ind->produced_cargo); i++) {
+						if (ind->produced_cargo[i] != CT_INVALID) {
+							SetDParam(prm_count++, ind->produced_cargo[i]);
+							SetDParam(prm_count++, ind->last_month_production[i]);
+							SetDParam(prm_count++, ToPercent8(ind->last_month_pct_transported[i]));
+							str++;
+						}
+					}
+					if (prm_count <= 19) {
+            GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+          }
+					break;
+				}
+				case MP_STATION: {
+          if (!IsRailWaypoint(tile)) {
+            if (!HasTileWaterGround(tile)) {
+              const Station *st = Station::GetByTile(tile);
+              StringID str = STR_STATION_VIEW_TRANSPORTED_TOOLTIP;
+              uint prm_count = 0;
+              SetDParam(prm_count++, st->index);
+              for (int i = 0; i < _sorted_standard_cargo_specs_size; i++) {
+                const CargoSpec *cs = _sorted_cargo_specs[i];
+                //const CargoSpec *cs = CargoSpec::Get(i);
+                if(cs == NULL) continue;
+                int cargoid = cs->Index();
+                //if (HasBit(st->goods[i].status,GoodsEntry::GES_RATING)) {
+                if (HasBit(st->goods[cargoid].status, GoodsEntry::GES_RATING)) {
+                  SetDParam(prm_count++, cs->Index());
+                  SetDParam(prm_count++, st->goods[cargoid].cargo.TotalCount());
+                  SetDParam(prm_count++, ToPercent8(st->goods[cargoid].rating));
+                  str++;
+                  if (prm_count == 19) {
+                    str++;
+                    i = _sorted_standard_cargo_specs_size;
+                  }
+                }
+              }
+              if (prm_count <= 19) {
+                GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+              }
+            }
+          }
+					break;
+				}
+				default:
+					return;
+			}
+		}
+	}
 };
 
 static WindowDesc _extra_view_port_desc(
diff --git a/src/viewport_type.h b/src/viewport_type.h
index 74cd88d95..d26419bc2 100644
--- a/src/viewport_type.h
+++ b/src/viewport_type.h
@@ -15,6 +15,7 @@
 #include "zoom_type.h"
 #include "strings_type.h"
 #include "table/strings.h"
+#include "math.h"
 
 class LinkGraphOverlay;
 
@@ -85,6 +86,7 @@ enum ViewportPlaceMethod {
 	VPM_FIX_VERTICAL    =    6, ///< drag only in vertical direction
 	VPM_X_LIMITED       =    7, ///< Drag only in X axis with limited size
 	VPM_Y_LIMITED       =    8, ///< Drag only in Y axis with limited size
+	VPM_A_B_LINE        =    9, ///< Drag a line from tile A to tile B
 	VPM_RAILDIRS        = 0x40, ///< all rail directions
 	VPM_SIGNALDIRS      = 0x80, ///< similar to VMP_RAILDIRS, but with different cursor
 };
@@ -105,6 +107,7 @@ enum ViewportDragDropSelectionProcess {
 	DDSP_CREATE_RIVER,         ///< Create rivers
 	DDSP_PLANT_TREES,          ///< Plant trees
 	DDSP_BUILD_BRIDGE,         ///< Bridge placement
+	DDSP_MEASURE,              ///< Measurement tool
 
 	/* Rail specific actions */
 	DDSP_PLACE_RAIL,           ///< Rail placement
diff --git a/src/watch_gui_1.cpp b/src/watch_gui_1.cpp
new file mode 100644
index 000000000..3cae681c2
--- /dev/null
+++ b/src/watch_gui_1.cpp
@@ -0,0 +1,535 @@
+/* $Id: watch_gui.cpp  17678 2009-10-07 20:54:05  muxy $ */
+
+/** @file watch_gui.cpp GUI that follow other company building. */
+
+#include "stdafx.h"
+#include "watch_gui_1.h"
+#include "widget_type.h"
+#include "gfx_type.h"
+#include "gfx_func.h"
+#include "company_base.h"
+#include "company_gui.h"
+#include "viewport_func.h"
+#include "window_func.h"
+#include "strings_func.h"
+#include "zoom_func.h"
+#include "map_func.h"
+#include "base64.h"
+#include "error.h"
+
+#include "industry.h"
+#include "town_map.h"
+#include "station_gui.h"
+#include "station_base.h"
+#include "cargotype.h"
+#include "widgets/viewport_widget.h"
+
+#include "network/network.h"
+#include "network/network_func.h"
+#include "network/network_base.h"
+#include "network/network_gui.h"
+
+#include "table/sprites.h"
+#include "table/strings.h"
+
+#include "safeguards.h"
+
+/** Make the widgets columns for company button, has_client and activity Blot.
+ * @param biggest_index Storage for collecting the biggest index used in the returned tree.
+ * @return Horizontal container with butons columns.
+ * @post \c *biggest_index contains the largest used index in the tree.
+ */
+static NWidgetBase *MakeCompanyButtons(int *biggest_index)
+{
+	NWidgetHorizontal *widget_container_horiz = NULL;         // Storage for all cols.
+	NWidgetVertical *widget_container_company_number = NULL;         // Storage for company number.
+	NWidgetVertical *widget_container_company = NULL;         // Storage for company Col.
+	NWidgetVertical *widget_container_hasclient = NULL;       // Storage for Has Client Blot.
+	NWidgetVertical *widget_container_activity = NULL;        // Storage for Activity Blot.
+	//NWidgetVertical *widget_container_action1 = NULL;         // Storage for Action 1
+
+	widget_container_horiz = new NWidgetHorizontal( );
+	widget_container_company_number = new NWidgetVertical( );
+	widget_container_company = new NWidgetVertical( );
+	widget_container_hasclient  = new NWidgetVertical( );
+	widget_container_activity = new NWidgetVertical( );
+	//widget_container_action1 = new NWidgetVertical( );
+
+	Dimension company_sprite_size = GetSpriteSize( SPR_COMPANY_ICON );
+	company_sprite_size.width  += WD_MATRIX_LEFT + WD_MATRIX_RIGHT;
+	company_sprite_size.height += WD_MATRIX_TOP + WD_MATRIX_BOTTOM + 1; // 1 for the 'offset' of being pressed
+
+	Dimension blot_sprite_size = GetSpriteSize( SPR_BLOT );
+	blot_sprite_size.width  += WD_MATRIX_LEFT + WD_MATRIX_RIGHT;
+	blot_sprite_size.height += WD_MATRIX_TOP + WD_MATRIX_BOTTOM + 1; // 1 for the 'offset' of being pressed
+
+
+	for (int company_num = COMPANY_FIRST; company_num < MAX_COMPANIES; company_num++ ) {
+
+    /* Manage Company Buttons */
+		NWidgetBackground *company_panel = new NWidgetBackground( WWT_PANEL, COLOUR_GREY, EWW_PB_COMPANY_FIRST1 + company_num );
+		company_panel->SetMinimalSize( company_sprite_size.width, company_sprite_size.height );
+		company_panel->SetResize( 0, 0 );
+		company_panel->SetFill( 1, 0 );
+		company_panel->SetDataTip( 0x0, STR_WATCH_CLICK_TO_WATCH_COMPANY );
+		widget_container_company->Add( company_panel );
+
+    /* Manage Company Number Buttons */
+		NWidgetBackground *company_number_panel = new NWidgetBackground( WWT_PANEL, COLOUR_GREY, EWW_PB_COMPANY_NUMBER_FIRST1 + company_num );
+		//company_number_panel->SetMinimalSize( blot_sprite_size.width, blot_sprite_size.height );
+		company_panel->SetMinimalSize( blot_sprite_size.width, blot_sprite_size.height );
+		company_panel->SetResize( 0, 0 );
+		company_panel->SetFill( 1, 0 );
+		company_number_panel->SetDataTip( 0x0, STR_WATCH_CLICK_TO_OPEN_COMPANY );
+		widget_container_company_number->Add( company_number_panel );
+
+		/* Manage Has Client Blot */
+		NWidgetBackground *hasclient_panel = new NWidgetBackground( WWT_PANEL, COLOUR_GREY, EWW_HAS_CLIENT_FIRST1 + company_num );
+		company_panel->SetMinimalSize( blot_sprite_size.width, blot_sprite_size.height );
+		company_panel->SetResize( 0, 0 );
+		company_panel->SetFill( 1, 0 );
+		widget_container_hasclient->Add( hasclient_panel );
+	}
+
+	/* Add the verticals widgets to the horizontal container */
+	widget_container_horiz->Add( widget_container_company_number );
+	widget_container_horiz->Add( widget_container_company );
+	widget_container_horiz->Add( widget_container_hasclient );
+
+	/* return the horizontal widget container */
+	return widget_container_horiz;
+}
+
+
+/**
+ * Watch Company Window Widgets Array
+ * The Company Button, Has Client Blot and Activity Blot Columns
+ * Are made through a function regarding MAX_COMPANIES value
+ */
+static const NWidgetPart _nested_watch_company_widgets1[] = {
+	/* Title Bar with close box, title, shade and stick boxes */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, EWW_CAPTION1 ), SetDataTip(STR_WATCH_WINDOW_TITLE2, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_DEFSIZEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer( ),
+	NWidget( NWID_HORIZONTAL ),
+		NWidget( NWID_VERTICAL ),
+			NWidgetFunction( MakeCompanyButtons ),
+			/* Buton Zoom Out, In, Scrollto */
+			NWidget(NWID_HORIZONTAL),
+				NWidget( WWT_PUSHIMGBTN, COLOUR_GREY, EWW_ZOOMOUT1 ), SetDataTip( SPR_IMG_ZOOMOUT, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_OUT),
+				NWidget( WWT_PUSHIMGBTN, COLOUR_GREY, EWW_ZOOMIN1 ),  SetDataTip( SPR_IMG_ZOOMIN, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_IN),
+				NWidget( WWT_PUSHIMGBTN, COLOUR_GREY, EWW_CENTER1 ),  SetDataTip( SPR_CENTRE_VIEW_VEHICLE, STR_EXTRA_VIEW_MOVE_MAIN_TO_VIEW_TT),
+				NWidget( WWT_PANEL, COLOUR_GREY, EWW_NEW_WINDOW1 ),   SetDataTip( 0, STR_WATCH_CLICK_NEW_WINDOW ), EndContainer( ),
+			EndContainer( ),
+			/* Background panel for resize purpose */
+			NWidget( WWT_PANEL, COLOUR_GREY ), SetResize( 0, 1 ), EndContainer( ),
+		EndContainer( ),
+		/* Watch Pannel */
+		NWidget(WWT_PANEL, COLOUR_GREY),
+			NWidget(NWID_VIEWPORT, INVALID_COLOUR, EWW_WATCH1), SetPadding(2, 2, 2, 2), SetResize(1, 1), SetFill(1, 1),
+		EndContainer( ),
+	EndContainer( ),
+	/* Status Bar with resize buton */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PANEL, COLOUR_GREY), SetFill(1, 1), SetResize(1, 0), EndContainer(),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer( ),
+};
+
+/**
+ * Watch Company Window Descriptor
+ */
+static WindowDesc _watch_company_desc(
+	WDP_AUTO, "watch_company", 330, 257,
+	WC_WATCH_COMPANY1, WC_NONE,
+	0,
+	_nested_watch_company_widgets1, lengthof( _nested_watch_company_widgets1 )
+);
+
+//static int WatchCompany::button1_state[MAX_COMPANIES];
+
+/** Watch Company Class Constructor
+ * @param desc Window Descriptor The Window Descriptor
+ * @param window_number The window number for the class
+ * @param company_to_watch Company ID for watching a particular company
+ */
+WatchCompany1::WatchCompany1(WindowDesc *desc, int window_number, CompanyID company_to_watch = INVALID_COMPANY ) : Window(desc)
+{
+	this->watched_company = company_to_watch;
+
+	this->InitNested(window_number);
+	this->owner = this->watched_company;
+
+	/* Reset activity and client count for all companies */
+	for (CompanyID i = COMPANY_FIRST; i < MAX_COMPANIES; i++) {
+		this->company_activity[i] = 0;
+		this->company_count_client[i] = 0;
+	}
+	
+	GetString( this->company_name, STR_JUST_NOTHING, lastof(this->company_name) );
+	
+	/* Init the viewport area */
+	NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(EWW_WATCH1);
+	//nvp->InitializeViewport(this, 0, ZOOM_LVL_NORMAL);
+	nvp->InitializeViewport(this, 0, ZOOM_LVL_OUT_8X);
+	
+	Point pt;
+	/* the main window with the main view */
+	const Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
+	
+	/* center on same place as main window (zoom is maximum, no adjustment needed) */
+	pt.x = w->viewport->scrollpos_x + w->viewport->virtual_width / 2;
+	pt.y = w->viewport->scrollpos_y + w->viewport->virtual_height / 2;
+
+	this->viewport->scrollpos_x = pt.x - this->viewport->virtual_width / 2;
+	this->viewport->scrollpos_y = pt.y - this->viewport->virtual_height / 2;
+	this->viewport->dest_scrollpos_x = this->viewport->scrollpos_x;
+	this->viewport->dest_scrollpos_y = this->viewport->scrollpos_y;
+
+	if ( this->watched_company != INVALID_COMPANY ) {
+		Company *c = Company::Get( this->watched_company );
+		this->ScrollToTile( c->last_build_coordinate );
+	}
+	this->InvalidateData( );
+}
+
+void WatchCompany1::SetStringParameters(int widget) const
+{
+	switch (widget) {
+		case EWW_CAPTION1:
+			SetDParamStr( 0, this->company_name );
+      SetDParam( 1, this->watched_company + 1 );
+			break;
+	}
+}
+
+void WatchCompany1::DrawWidget(const Rect &r, int widget) const
+{
+	/* draw the widget */
+	/* Company Number Button */
+	if (IsInsideMM(widget, EWW_PB_COMPANY_NUMBER_FIRST1, EWW_PB_COMPANY_NUMBER_LAST1 + 1)) {
+		if (this->IsWidgetDisabled(widget)) return;
+		if ( Company::IsValidID( widget - EWW_PB_COMPANY_NUMBER_FIRST1 ) ) {
+		    CompanyID cid = (CompanyID)(widget - ( EWW_PB_COMPANY_NUMBER_FIRST1 ) );
+		    Dimension sprite_size = GetSpriteSize(SPR_BLOT);
+		    SetDParam(0, widget);
+		    DrawString(r.left, r.right, (r.top + r.bottom - sprite_size.height) / 2, STR_WATCH_CLICK_TO_WATCH_COMPANY_NUMBER, TC_FROMSTRING, SA_CENTER);
+		}
+		return;
+	}
+	/* Company Button */
+	if (IsInsideMM(widget, EWW_PB_COMPANY_FIRST1, EWW_PB_COMPANY_LAST1 + 1)) {
+		if (this->IsWidgetDisabled(widget)) return;
+		if ( Company::IsValidID( widget - EWW_PB_COMPANY_FIRST1 ) ) {
+		    CompanyID cid = (CompanyID)(widget - ( EWW_PB_COMPANY_FIRST1 ) );
+		    int offset = (cid == this->watched_company) ? 1 : 0;
+		    Dimension sprite_size = GetSpriteSize(SPR_COMPANY_ICON);
+		    DrawCompanyIcon(cid, (r.left + r.right - sprite_size.width) / 2 + offset, (r.top + r.bottom - sprite_size.height) / 2 + offset);
+		}
+		return;
+	}
+	/* Has Client Blot */
+	if (IsInsideMM( widget, EWW_HAS_CLIENT_FIRST1, EWW_HAS_CLIENT_LAST1 + 1 )) {
+		if ( Company::IsValidID( widget-EWW_HAS_CLIENT_FIRST1 ) ) {
+			/* Draw the Blot only if Company Exists */
+			Dimension sprite_size = GetSpriteSize(SPR_BLOT);
+#ifdef ENABLE_NETWORK
+			if (!_networking) { // Local game, draw the Blot
+				DrawSprite(SPR_BLOT, Company::IsValidAiID(widget-EWW_HAS_CLIENT_FIRST1)?PALETTE_TO_ORANGE:PALETTE_TO_GREEN, (r.left + r.right - sprite_size.width) / 2, (r.top + r.bottom - sprite_size.height) / 2 );
+			} else { // Network game, draw the blot according to company client count
+				DrawSprite(SPR_BLOT, this->company_count_client[widget-EWW_HAS_CLIENT_FIRST1]>0?(company_activity[widget-EWW_HAS_CLIENT_FIRST1]>0?PALETTE_TO_RED:PALETTE_TO_GREEN):PALETTE_TO_GREY, (r.left + r.right - sprite_size.width) / 2, (r.top + r.bottom - sprite_size.height) / 2 );
+			}
+#else
+			DrawSprite(SPR_BLOT, Company::IsValidAiID(widget-EWW_HAS_CLIENT_FIRST1)?PALETTE_TO_ORANGE:PALETTE_TO_GREEN, (r.left + r.right - sprite_size.width) / 2, (r.top + r.bottom - sprite_size.height) / 2 );
+#endif
+		}
+	}
+}
+
+void WatchCompany1::OnResize()
+{
+	if (this->viewport != NULL) {
+		NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(EWW_WATCH1);
+		nvp->UpdateViewportCoordinates(this);
+	}
+}
+
+void WatchCompany1::OnScroll(Point delta)
+{
+	const ViewPort *vp = IsPtInWindowViewport(this, _cursor.pos.x, _cursor.pos.y);
+	if (vp == NULL) return;
+
+	this->viewport->scrollpos_x += ScaleByZoom(delta.x, vp->zoom);
+	this->viewport->scrollpos_y += ScaleByZoom(delta.y, vp->zoom);
+	this->viewport->dest_scrollpos_x = this->viewport->scrollpos_x;
+	this->viewport->dest_scrollpos_y = this->viewport->scrollpos_y;
+}
+
+void WatchCompany1::OnMouseWheel( int wheel )
+{
+	ZoomInOrOutToCursorWindow(wheel < 0, this);
+}
+
+void WatchCompany1::OnClick(Point pt, int widget, int click_count)
+{
+	if (IsInsideMM(widget, EWW_PB_COMPANY_FIRST1, EWW_PB_COMPANY_LAST1 + 1)) {
+		/* Click on Company Button */
+		if (!this->IsWidgetDisabled(widget)) {
+			if (this->watched_company != INVALID_COMPANY) {
+				/* Raise the watched company button  */
+				this->RaiseWidget(this->watched_company + EWW_PB_COMPANY_FIRST1);
+			}
+			if (this->watched_company == (CompanyID)(widget - EWW_PB_COMPANY_FIRST1)) {
+				/* Stop watching watched_company */
+				this->watched_company = INVALID_COMPANY;
+                                GetString( this->company_name, STR_JUST_NOTHING, lastof(this->company_name) );
+			} else {
+				/* Lower the new watched company button */
+				this->watched_company = (CompanyID)(widget - EWW_PB_COMPANY_FIRST1);
+				this->LowerWidget(this->watched_company + EWW_PB_COMPANY_FIRST1);
+				Company *c = Company::Get( this->watched_company );
+				SetDParam( 0, c->index );
+				GetString( this->company_name, STR_COMPANY_NAME, lastof(this->company_name) );
+				
+				this->ScrollToTile( c->last_build_coordinate );
+			}
+			this->owner = this->watched_company;
+			this->SetDirty();
+		}
+	} else if ( IsInsideMM(widget, EWW_PB_ACTION1_FIRST1, EWW_PB_ACTION1_LAST1 + 1)) {
+		if ( !this->IsWidgetDisabled(widget) ) {
+			this->ToggleWidgetLoweredState( widget );
+			this->SetDirty();
+		}
+	} // Handle when clicking on company numbers to open Company window
+		else if (IsInsideMM(widget, EWW_PB_COMPANY_NUMBER_FIRST1, EWW_PB_COMPANY_NUMBER_LAST1 + 1)) {
+      if (!this->IsWidgetDisabled(widget)) {
+        this->watched_company_window = (CompanyID)(widget - EWW_PB_COMPANY_NUMBER_FIRST1);
+        ShowCompany(this->watched_company_window);
+      }
+      ////////////////////
+    }
+#ifdef ENABLE_NETWORK
+	else if ( IsInsideMM(widget, EWW_HAS_CLIENT_FIRST1, EWW_HAS_CLIENT_LAST1 + 1)) {
+		if(_networking && Company::IsValidID(widget - EWW_HAS_CLIENT_FIRST1)){
+			ShowNetworkChatQueryWindow(DESTTYPE_TEAM, widget - EWW_HAS_CLIENT_FIRST1);
+		}
+	}
+#endif
+  else {
+		switch (widget) {
+			case EWW_ZOOMOUT1: DoZoomInOutWindow(ZOOM_OUT, this); break;
+			case EWW_ZOOMIN1: DoZoomInOutWindow(ZOOM_IN,  this); break;
+
+			case EWW_CENTER1: { // location button (move main view to same spot as this view) 'Center Main View'
+				Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
+				int x = this->viewport->scrollpos_x; // Where is the watch looking at
+				int y = this->viewport->scrollpos_y;
+
+				/* set the main view to same location. Based on the center, adjusting for zoom */
+				w->viewport->dest_scrollpos_x =  x - (w->viewport->virtual_width -  this->viewport->virtual_width) / 2;
+				w->viewport->dest_scrollpos_y =  y - (w->viewport->virtual_height - this->viewport->virtual_height) / 2;
+			} break;
+				
+			case EWW_NEW_WINDOW1:
+				ShowWatchWindow1( this->watched_company );
+				break;
+		}
+	}
+}
+
+void WatchCompany1::OnMouseOver(Point pt, int widget)
+	{
+		/* Show tooltip with last month production or town name */
+		if (pt.x != -1) {
+			TileIndex tile;
+			const bool viewport_is_in_map_mode = (this->viewport->zoom > ZOOM_LVL_MAX);
+			//const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_MAX);
+			//const bool viewport_is_in_map_mode = (this->viewport->zoom >= ZOOM_LVL_DRAW_MAP);
+			if (viewport_is_in_map_mode) {
+        // Disabled, for now :)
+				/*NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(WID_EV_VIEWPORT);
+				const int a = ((ScaleByZoom(pt.x - nvp->pos_x, this->viewport->zoom) + this->viewport->virtual_left) >> 2) / ZOOM_LVL_BASE;
+				const int b = ((ScaleByZoom(pt.y - nvp->pos_y, this->viewport->zoom) + this->viewport->virtual_top) >> 1) / ZOOM_LVL_BASE;
+				tile = TileVirtXY(b - a, b + a);*/
+			} else {
+				const Point p = GetTileBelowCursor();
+				tile = TileVirtXY(p.x, p.y);
+			}
+			if (tile >= MapSize()) return;
+
+			switch (GetTileType(tile)) {
+				case MP_ROAD:
+					if (IsRoadDepot(tile)) return;
+					/* FALL THROUGH */
+				case MP_HOUSE: {
+					if (HasBit(_display_opt, DO_SHOW_TOWN_NAMES)) return; // No need for a town name tooltip when it is already displayed
+					if (!viewport_is_in_map_mode) return;
+					const TownID tid = GetTownIndex(tile);
+					if (!tid) return;
+					SetDParam(0, tid);
+					GuiShowTooltips(this, STR_TOWN_NAME_TOOLTIP, 0, NULL, TCC_HOVER);
+					break;
+				}
+				case MP_INDUSTRY: {
+					const Industry *ind = Industry::GetByTile(tile);
+					const IndustrySpec *indsp = GetIndustrySpec(ind->type);
+
+					StringID str = STR_INDUSTRY_VIEW_TRANSPORTED_TOOLTIP;
+					uint prm_count = 0;
+					SetDParam(prm_count++, indsp->name);
+					for (byte i = 0; i < lengthof(ind->produced_cargo); i++) {
+						if (ind->produced_cargo[i] != CT_INVALID) {
+							SetDParam(prm_count++, ind->produced_cargo[i]);
+							SetDParam(prm_count++, ind->last_month_production[i]);
+							SetDParam(prm_count++, ToPercent8(ind->last_month_pct_transported[i]));
+							str++;
+						}
+					}
+					if (prm_count <= 19) {
+            GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+          }
+					break;
+				}
+				case MP_STATION: {
+          if (!IsRailWaypoint(tile)) {
+            if (!HasTileWaterGround(tile)) {
+              const Station *st = Station::GetByTile(tile);
+              StringID str = STR_STATION_VIEW_TRANSPORTED_TOOLTIP;
+              uint prm_count = 0;
+              SetDParam(prm_count++, st->index);
+              for (int i = 0; i < _sorted_standard_cargo_specs_size; i++) {
+                const CargoSpec *cs = _sorted_cargo_specs[i];
+                //const CargoSpec *cs = CargoSpec::Get(i);
+                if(cs == NULL) continue;
+                int cargoid = cs->Index();
+                //if (HasBit(st->goods[i].status,GoodsEntry::GES_RATING)) {
+                if (HasBit(st->goods[cargoid].status, GoodsEntry::GES_RATING)) {
+                  SetDParam(prm_count++, cs->Index());
+                  SetDParam(prm_count++, st->goods[cargoid].cargo.TotalCount());
+                  SetDParam(prm_count++, ToPercent8(st->goods[cargoid].rating));
+                  str++;
+                  if (prm_count == 19) {
+                    str++;
+                    i = _sorted_standard_cargo_specs_size;
+                  }
+                }
+              }
+              if (prm_count <= 19) {
+                GuiShowTooltips(this, str, 0, NULL, TCC_HOVER);
+              }
+            }
+          }
+					break;
+				}
+				default:
+					return;
+			}
+		}
+	}
+
+void WatchCompany1::OnInvalidateData(int data, bool gui_scope)
+{
+	/* Disable the companies who are not active */
+	for (CompanyID i = COMPANY_FIRST; i < MAX_COMPANIES; i++) {
+		this->SetWidgetDisabledState(EWW_PB_COMPANY_FIRST1 + i , !Company::IsValidID(i) );
+		this->SetWidgetDisabledState(EWW_PB_ACTION1_FIRST1 + i , !Company::IsValidID(i) );
+	}
+	/* Check if the currently selected company is still active. */
+	if (this->watched_company != INVALID_COMPANY) {
+		/* Make sure the widget is lowered */
+		this->LowerWidget(EWW_PB_COMPANY_FIRST1 + this->watched_company);
+		/* Check if the watched Company is still a valid one */
+		if (!Company::IsValidID(this->watched_company)) {
+			/* Invalid Company Raise the associated widget. */
+			this->RaiseWidget(this->watched_company + EWW_PB_COMPANY_FIRST1 );
+			this->watched_company = INVALID_COMPANY;
+			GetString( this->company_name, STR_JUST_NOTHING, lastof(this->company_name) );
+		} else {
+			Company *c = Company::Get( this->watched_company );
+			SetDParam( 0, c->index );
+			GetString( this->company_name, STR_COMPANY_NAME, lastof(this->company_name) );
+		}
+	} else {
+		GetString( this->company_name, STR_JUST_NOTHING, lastof(this->company_name) );
+	  
+	}
+#ifdef ENABLE_NETWORK
+	if (_networking) { // Local game, draw the Blot
+		/* Reset company count - network only */
+		for (CompanyID i = COMPANY_FIRST; i < MAX_COMPANIES; i++) {
+			this->company_count_client[i] = 0;
+		}
+		/* Calculate client count into company - network only */
+		NetworkClientInfo *ci;
+		FOR_ALL_CLIENT_INFOS( ci ) {
+			if (Company::IsValidID(ci->client_playas)) {
+				company_count_client[ci->client_playas]+=1;
+			}
+		}
+	}
+#endif
+	HandleZoomMessage(this, this->viewport, EWW_ZOOMIN1, EWW_ZOOMOUT1);
+}
+
+void WatchCompany1::ScrollToTile( TileIndex tile )
+{
+	/* Scroll window to the tile, only if not zero */
+	if (tile != 0) {
+		ScrollWindowTo( TileX(tile) * TILE_SIZE + TILE_SIZE / 2, TileY(tile) * TILE_SIZE + TILE_SIZE / 2, -1, this );
+	}
+}
+
+/** OnDoCommand function - Called by the DoCommand
+ *  @param company The company ID who's client is building
+ *  @param tile The tile number where action took place
+ */
+void WatchCompany1::OnDoCommand( CompanyByte company, TileIndex tile )
+{
+	/* Check if its my company */
+	if (this->watched_company == company)
+	{
+		this->ScrollToTile( tile );
+	}
+	/* set the company_activity to its max in order to paint the BLOT in red
+	 * This will result by having the activity blot set to red for all companies
+	 * even the one watched. To avoid this behaviour and not to light the blot of
+	 * the watched company, the code can be moved just after the ScrollToTile call.
+	 */
+	if (tile != 0) {
+		this->company_activity[company] = MAX_ACTIVITY;
+		this->SetDirty( );
+	}
+}
+
+/** Used to decrement the activity counter
+ *
+ */
+void WatchCompany1::OnTick()
+{
+	bool set_dirty = false;
+	for (CompanyID i = COMPANY_FIRST; i < MAX_COMPANIES; i++) {
+		if ( this->company_activity[i]>0 ) {
+			this->company_activity[i]--;
+			if ( this->company_activity[i]==0 ) {
+				set_dirty = true;
+			}
+		}
+	}
+	/* If one company_activity reaches 0, then redraw */
+	if (set_dirty) {
+		this->SetDirty();
+	}
+}
+
+void ShowWatchWindow1(CompanyID company_to_watch = INVALID_COMPANY)
+{
+  int i = 0;
+  /* find next free window number for watch viewport */
+  while (FindWindowById(WC_WATCH_COMPANY1, i) != NULL) i++;
+  new WatchCompany1(&_watch_company_desc, i, company_to_watch);
+}
diff --git a/src/watch_gui_1.h b/src/watch_gui_1.h
new file mode 100644
index 000000000..21c6f1576
--- /dev/null
+++ b/src/watch_gui_1.h
@@ -0,0 +1,67 @@
+/* $Id: watch_gui.h 17678 2009-10-07 20:54:05  muxy $ */
+
+/** @file watch_gui.h GUI Functions related to watching. */
+
+#ifndef WATCH_GUI_1_H
+#define WATCH_GUI_1_H
+
+#include "window_gui.h"
+#include "company_base.h"
+
+#define MAX_ACTIVITY 30
+
+enum WatchCompany1Widgets {
+	EWW_CAPTION1,
+	EWW_PB_COMPANY_NUMBER_FIRST1,
+	EWW_PB_COMPANY_NUMBER_LAST1  = EWW_PB_COMPANY_NUMBER_FIRST1 + MAX_COMPANIES - 1,
+	EWW_PB_COMPANY_FIRST1,
+	EWW_PB_COMPANY_LAST1  = EWW_PB_COMPANY_FIRST1 + MAX_COMPANIES - 1,
+	EWW_HAS_CLIENT_FIRST1,
+	EWW_HAS_CLIENT_LAST1 = EWW_HAS_CLIENT_FIRST1 + MAX_COMPANIES - 1,
+	EWW_ACTIVITY_FIRST1,
+	EWW_ACTIVITY_LAST1 = EWW_ACTIVITY_FIRST1 + MAX_COMPANIES - 1,
+	EWW_PB_ACTION1_FIRST1,
+	EWW_PB_ACTION1_LAST1 = EWW_PB_ACTION1_FIRST1 + MAX_COMPANIES - 1,
+	EWW_WATCH1,
+	EWW_ZOOMIN1,
+	EWW_ZOOMOUT1,
+	EWW_CENTER1,
+	EWW_NEW_WINDOW1
+};
+
+class WatchCompany1 : public Window
+{
+
+protected:
+
+	CompanyID watched_company;                            // Company ID beeing watched.
+	CompanyID watched_company_window;                            // Company ID to open Company window.
+	int company_activity[MAX_COMPANIES];                  // int array for activity blot.
+	int company_count_client[MAX_COMPANIES];              // company client count.
+	char company_name[MAX_LENGTH_COMPANY_NAME_CHARS];     // company name for title display
+
+	void SetWatchWindowTitle( );
+	void ScrollToTile( TileIndex tile );
+
+
+public:
+
+	WatchCompany1(WindowDesc *desc, int window_number, CompanyID company_to_watch );
+
+	virtual void SetStringParameters(int widget) const;
+	//virtual void OnPaint( );
+	virtual void DrawWidget(const Rect &r, int widget) const;
+	virtual void OnClick(Point pt, int widget, int click_count);
+	virtual void OnResize( );
+	virtual void OnScroll(Point delta);
+	virtual void OnMouseWheel(int wheel);
+	virtual void OnInvalidateData(int data, bool gui_scope );
+	virtual void OnTick( );
+	virtual void OnMouseOver(Point pt, int widget);
+	
+	void OnDoCommand( CompanyByte company, TileIndex tile );
+};
+
+void ShowWatchWindow1( CompanyID company_to_watch );
+
+#endif // WATCH_GUI_1_H
diff --git a/src/widget.cpp b/src/widget.cpp
index 11149d67b..471392b11 100644
--- a/src/widget.cpp
+++ b/src/widget.cpp
@@ -1841,6 +1841,7 @@ void NWidgetBackground::Draw(const Window *w)
 
 	switch (this->type) {
 		case WWT_PANEL:
+      //Disabled for Betas and RC's??
 			assert(this->widget_data == 0);
 			DrawFrameRect(r.left, r.top, r.right, r.bottom, this->colour, this->IsLowered() ? FR_LOWERED : FR_NONE);
 			break;
diff --git a/src/widgets/cargo_table_widget.h b/src/widgets/cargo_table_widget.h
new file mode 100644
index 000000000..f39e6ab3d
--- /dev/null
+++ b/src/widgets/cargo_table_widget.h
@@ -0,0 +1,21 @@
+/* $Id: cargo_table_widget.h 23600 2011-12-19 20:46:17Z TheDude $ */
+
+/** @file cargo_table_widget.h Types related to the cargos widgets. */
+
+#ifndef WIDGETS_CARGO_TABLE_WIDGET_H
+#define WIDGETS_CARGO_TABLE_WIDGET_H
+
+/** Widgets of the #CargosWindow class. */
+enum CargosWidgets {
+	WID_CT_BACKGROUND,  ///< Caption of the window.
+	WID_CT_CAPTION,
+	WID_CT_HEADER_CARGO,
+	WID_CT_HEADER_AMOUNT,
+	WID_CT_HEADER_INCOME,
+	WID_CT_TOTAL,
+	WID_CT_LIST,
+	WID_CT_AMOUNT,
+	WID_CT_INCOME,
+};
+
+#endif /* WIDGETS_CARGO_TABLE_WIDGET_H */
diff --git a/src/widgets/industry_widget.h b/src/widgets/industry_widget.h
index 711694db7..8c4b39fba 100644
--- a/src/widgets/industry_widget.h
+++ b/src/widgets/industry_widget.h
@@ -34,6 +34,8 @@ enum IndustryViewWidgets {
 enum IndustryDirectoryWidgets {
 	WID_ID_DROPDOWN_ORDER,    ///< Dropdown for the order of the sort.
 	WID_ID_DROPDOWN_CRITERIA, ///< Dropdown for the criteria of the sort.
+	WID_ID_DROPDOWN_FILTER_TRANSPORTED,   ///< Dropdown for filtering on industry is transported or not
+	WID_ID_DROPDOWN_FILTER_INDUSTRY_TYPE, ///< Dropdown for filtering on industry type
 	WID_ID_INDUSTRY_LIST,     ///< Industry list.
 	WID_ID_SCROLLBAR,         ///< Scrollbar of the list.
 };
diff --git a/src/widgets/intro_widget.h b/src/widgets/intro_widget.h
index ae48827ed..6ba6e486e 100644
--- a/src/widgets/intro_widget.h
+++ b/src/widgets/intro_widget.h
@@ -35,6 +35,55 @@ enum SelectGameIntroWidgets {
 	WID_SGI_CONTENT_DOWNLOAD,      ///< Content Download button.
 	WID_SGI_AI_SETTINGS,           ///< AI button.
 	WID_SGI_EXIT,                  ///< Exit button.
+
+	WID_SGI_CC_HEADER,
+	
+	WID_SGI_SERVERS_FORUM,
+	WID_SGI_WEBSITE,
+	WID_SGI_IRC_CHAT,
+	WID_SGI_IRC_SERVERS_CHAT,
+	WID_SGI_SERVER_RULES,
+	WID_SGI_SERVER_WIKI,
+	WID_SGI_SERVER_VIP,
+
+	WID_SGI_CC_USER,
+	WID_SGI_CC_USER_ENTER,
+	WID_SGI_CC_PASSWORD,
+	WID_SGI_CC_SELECT_NICE,
+	WID_SGI_CC_SELECT_BTPRO,
+	WID_SGI_CC_SERVERS,
+	
+	WID_SGI_SERVERS,
+	WID_SGI_CC1,
+	WID_SGI_CC2,
+	WID_SGI_CC3,
+	WID_SGI_CC4,
+	WID_SGI_CC5,
+	WID_SGI_CC6,
+	WID_SGI_CC7,
+	WID_SGI_CC8,
+	WID_SGI_CC9,
+	WID_SGI_CC10,
+	WID_SGI_CC11,
+	WID_SGI_CC12,
+	WID_SGI_CC13,
+	WID_SGI_CC14,
+	WID_SGI_CC15,
+	WID_SGI_CC16,
+	WID_SGI_CC17,
+	WID_SGI_CC18,
+	WID_SGI_CC19,
+	WID_SGI_CC20,
+	WID_SGI_CC21,
+	WID_SGI_CC22,
+	WID_SGI_CC23,
+	WID_SGI_CC24,
+	WID_SGI_CC25,
+};
+
+enum SelectGameQuery {
+	SGQ_CC_USER,
+	SGQ_CC_PASSWORD,
 };
 
 #endif /* WIDGETS_INTRO_WIDGET_H */
diff --git a/src/widgets/network_widget.h b/src/widgets/network_widget.h
index f5773b8ea..ecbe95e96 100644
--- a/src/widgets/network_widget.h
+++ b/src/widgets/network_widget.h
@@ -51,6 +51,11 @@ enum NetworkGameWidgets {
 	WID_NG_ADD,                ///< 'Add server' button.
 	WID_NG_START,              ///< 'Start server' button.
 	WID_NG_CANCEL,             ///< 'Cancel' button.
+
+  WID_NG_CC_NICE,            ///< n-ice filter
+	WID_NG_CC_BTPRO,           ///< btpro filter
+	WID_NG_CC_REDDIT,          ///< reddit filter
+	WID_NG_CC_CITYMANIA,       ///< citymania filter
 };
 
 /** Widgets of the #NetworkStartServerWindow class. */
diff --git a/src/widgets/rail_widget.h b/src/widgets/rail_widget.h
index f977f4480..b45dcad51 100644
--- a/src/widgets/rail_widget.h
+++ b/src/widgets/rail_widget.h
@@ -21,6 +21,7 @@ enum RailToolbarWidgets {
 	WID_RAT_BUILD_EW,       ///< Build rail along the game view X axis.
 	WID_RAT_BUILD_Y,        ///< Build rail along the game grid Y axis.
 	WID_RAT_AUTORAIL,       ///< Autorail tool.
+	WID_RAT_POLYRAIL,       ///< Polyline rail tool.
 	WID_RAT_DEMOLISH,       ///< Destroy something with dynamite!
 	WID_RAT_BUILD_DEPOT,    ///< Build a depot.
 	WID_RAT_BUILD_WAYPOINT, ///< Build a waypoint.
@@ -103,6 +104,7 @@ enum BuildRailDepotWidgets {
 	WID_BRAD_DEPOT_SE, ///< Build a depot with the entrance in the south east.
 	WID_BRAD_DEPOT_SW, ///< Build a depot with the entrance in the south west.
 	WID_BRAD_DEPOT_NW, ///< Build a depot with the entrance in the north west.
+	WID_BRAD_DEPOT_AUTO, ///< Build a depot, autoselect entrance.
 };
 
 /** Widgets of the #BuildRailWaypointWindow class. */
diff --git a/src/widgets/road_widget.h b/src/widgets/road_widget.h
index f022489e5..40de864f2 100644
--- a/src/widgets/road_widget.h
+++ b/src/widgets/road_widget.h
@@ -36,6 +36,7 @@ enum BuildRoadDepotWidgets {
 	WID_BROD_DEPOT_SE,  ///< Depot with SE entry.
 	WID_BROD_DEPOT_SW,  ///< Depot with SW entry.
 	WID_BROD_DEPOT_NW,  ///< Depot with NW entry.
+	WID_BROD_DEPOT_AUTO, ///< Depot, autodetect entry.
 };
 
 /** Widgets of the #BuildRoadStationWindow class. */
@@ -49,6 +50,8 @@ enum BuildRoadStationWidgets {
 	WID_BROS_STATION_NW,    ///< Terminal station with NW entry.
 	WID_BROS_STATION_X,     ///< Drive-through station in x-direction.
 	WID_BROS_STATION_Y,     ///< Drive-through station in y-direction.
+	WID_BROS_STATION_AUTO,     ///< Terminal station, autoselect entry.
+	WID_BROS_STATION_XY_AUTO,  ///< Drive-through station, autoselect direction.
 	WID_BROS_LT_OFF,        ///< Turn off area highlight.
 	WID_BROS_LT_ON,         ///< Turn on area highlight.
 	WID_BROS_INFO,          ///< Station acceptance info.
diff --git a/src/widgets/statusbar_widget.h b/src/widgets/statusbar_widget.h
index 1cfbe7ff2..2e4878504 100644
--- a/src/widgets/statusbar_widget.h
+++ b/src/widgets/statusbar_widget.h
@@ -17,6 +17,8 @@ enum StatusbarWidgets {
 	WID_S_LEFT,   ///< Left part of the statusbar; date is shown there.
 	WID_S_MIDDLE, ///< Middle part; current news or company name or *** SAVING *** or *** PAUSED ***.
 	WID_S_RIGHT,  ///< Right part; bank balance.
+	WID_S_RULES,
+	WID_S_USER,
 };
 
 #endif /* WIDGETS_STATUSBAR_WIDGET_H */
diff --git a/src/widgets/terraform_widget.h b/src/widgets/terraform_widget.h
index 7f8a4c4d1..d79665262 100644
--- a/src/widgets/terraform_widget.h
+++ b/src/widgets/terraform_widget.h
@@ -22,6 +22,7 @@ enum TerraformToolbarWidgets {
 	WID_TT_DEMOLISH,                          ///< Demolish aka dynamite button.
 	WID_TT_BUY_LAND,                          ///< Buy land button.
 	WID_TT_PLANT_TREES,                       ///< Plant trees button (note: opens separate window, no place-push-button).
+	WID_TT_MEASUREMENT_TOOL,                  ///< Ruler tool button
 	WID_TT_PLACE_SIGN,                        ///< Place sign button.
 	WID_TT_PLACE_OBJECT,                      ///< Place object button.
 };
diff --git a/src/widgets/toolbar_widget.h b/src/widgets/toolbar_widget.h
index c317fc957..66234c92c 100644
--- a/src/widgets/toolbar_widget.h
+++ b/src/widgets/toolbar_widget.h
@@ -23,6 +23,7 @@ enum ToolbarNormalWidgets {
 	WID_TN_SUBSIDIES,     ///< Subsidy menu.
 	WID_TN_STATIONS,      ///< Station menu.
 	WID_TN_FINANCES,      ///< Finance menu.
+	WID_TN_CARGOS,        ///< Transported cargo menu
 	WID_TN_COMPANIES,     ///< Company menu.
 	WID_TN_STORY,         ///< Story menu.
 	WID_TN_GOAL,          ///< Goal menu.
diff --git a/src/widgets/town_widget.h b/src/widgets/town_widget.h
index 4f5443c36..eefc4ec27 100644
--- a/src/widgets/town_widget.h
+++ b/src/widgets/town_widget.h
@@ -19,6 +19,7 @@ enum TownDirectoryWidgets {
 	WID_TD_LIST,             ///< List of towns.
 	WID_TD_SCROLLBAR,        ///< Scrollbar for the town list.
 	WID_TD_WORLD_POPULATION, ///< The world's population.
+	TDW_CAPTION_TEXT,
 };
 
 /** Widgets of the #TownAuthorityWindow class. */
@@ -41,6 +42,7 @@ enum TownViewWidgets {
 	WID_TV_CHANGE_NAME,    ///< Change the name of this town.
 	WID_TV_EXPAND,         ///< Expand this town (scenario editor only).
 	WID_TV_DELETE,         ///< Delete this town (scenario editor only).
+	WID_TV_CB,
 };
 
 /** Widgets of the #FoundTownWindow class. */
@@ -62,4 +64,33 @@ enum TownFoundingWidgets {
 	WID_TF_LAYOUT_RANDOM,     ///< Selection for a randomly chosen town layout.
 };
 
+enum TownHK {
+	HK_SADVERT,
+	HK_MADVERT,
+	HK_LADVERT,
+	HK_ROADS,
+	HK_STATUE,
+	HK_FUND,
+};
+
+enum CBTownWidgets {
+	WID_CB_LOCATION,
+	WID_CB_ADVERT,
+	WID_CB_ADVERT_REGULAR,
+	WID_CB_FUND,
+	WID_CB_FUND_REGULAR,
+	WID_CB_POWERFUND,
+	WID_CB_DETAILS,
+	WID_CB_CARGO_NAME,
+	WID_CB_CARGO_AMOUNT,
+	WID_CB_CARGO_REQ,
+	WID_CB_CARGO_PREVIOUS,
+	WID_CB_CARGO_STORE,
+	WID_CB_CARGO_STORE_PCT,
+	WID_CB_CARGO_FROM,
+	WID_CB_CENTER_VIEW,
+	WID_CB_TOWN_VIEW,
+	WID_CB_SHOW_AUTHORITY,
+};
+
 #endif /* WIDGETS_TOWN_WIDGET_H */
diff --git a/src/widgets/transparency_widget.h b/src/widgets/transparency_widget.h
index 87618fcb6..4b5917c89 100644
--- a/src/widgets/transparency_widget.h
+++ b/src/widgets/transparency_widget.h
@@ -25,6 +25,7 @@ enum TransparencyToolbarWidgets {
 	WID_TT_STRUCTURES,               ///< Object structure transparency toggle button.
 	WID_TT_CATENARY,                 ///< Catenary transparency toggle button.
 	WID_TT_LOADING,                  ///< Loading indicators transparency toggle button.
+	WID_TT_TUNNELS,
 	WID_TT_END,                      ///< End of toggle buttons.
 
 	/* Panel with buttons for invisibility */
diff --git a/src/widgets/vehicle_widget.h b/src/widgets/vehicle_widget.h
index a0902dab4..2d658d454 100644
--- a/src/widgets/vehicle_widget.h
+++ b/src/widgets/vehicle_widget.h
@@ -45,6 +45,7 @@ enum VehicleRefitWidgets {
 /** Widgets of the #VehicleDetailsWindow class. */
 enum VehicleDetailsWidgets {
 	WID_VD_CAPTION,                     ///< Caption of window.
+	WID_VD_TRIP_HISTORY,                ///< Show the trip history of vehicle.
 	WID_VD_RENAME_VEHICLE,              ///< Rename this vehicle.
 	WID_VD_TOP_DETAILS,                 ///< Panel with generic details.
 	WID_VD_INCREASE_SERVICING_INTERVAL, ///< Increase the servicing interval.
diff --git a/src/window.cpp b/src/window.cpp
index 52f6d4785..e8e9027c3 100644
--- a/src/window.cpp
+++ b/src/window.cpp
@@ -1213,6 +1213,7 @@ void ChangeWindowOwner(Owner old_owner, Owner new_owner)
 		switch (w->window_class) {
 			case WC_COMPANY_COLOUR:
 			case WC_FINANCES:
+			case WC_CARGOS:
 			case WC_STATION_LIST:
 			case WC_TRAINS_LIST:
 			case WC_ROADVEH_LIST:
@@ -1472,7 +1473,9 @@ void Window::InitializeData(WindowNumber window_number)
 	/* Give focus to the opened window unless a text box
 	 * of focused window has focus (so we don't interrupt typing). But if the new
 	 * window has a text box, then take focus anyway. */
-	if (!EditBoxInGlobalFocus() || this->nested_root->GetWidgetOfType(WWT_EDITBOX) != NULL) SetFocusedWindow(this);
+	//if (!EditBoxInGlobalFocus() || this->nested_root->GetWidgetOfType(WWT_EDITBOX) != NULL) SetFocusedWindow(this); //original
+	//if (!_scrolling_viewport && this->window_class != WC_OSK && (!EditBoxInGlobalFocus() || this->nested_root->GetWidgetOfType(WWT_EDITBOX) != NULL)) SetFocusedWindow(this); //removido
+	if (!_scrolling_viewport && this->window_class != WC_TOOLTIPS && this->window_class != WC_NEWS_WINDOW && this->window_class != WC_OSK && (!EditBoxInGlobalFocus() || this->nested_root->GetWidgetOfType(WWT_EDITBOX) != NULL)) SetFocusedWindow(this);
 
 	/* Insert the window into the correct location in the z-ordering. */
 	AddWindowToZOrdering(this);
@@ -2903,7 +2906,7 @@ static void MouseLoop(MouseClick click, int mousewheel)
 		switch (click) {
 			case MC_DOUBLE_LEFT:
 			case MC_LEFT:
-				if (HandleViewportClicked(vp, x, y)) return;
+				if (HandleViewportClicked(vp, x, y, click == MC_DOUBLE_LEFT)) return;
 				if (!(w->flags & WF_DISABLE_VP_SCROLL) &&
 						_settings_client.gui.scroll_mode == VSM_MAP_LMB) {
 					_scrolling_viewport = true;
diff --git a/src/window_gui.h b/src/window_gui.h
index b2bba675b..45f5aab00 100644
--- a/src/window_gui.h
+++ b/src/window_gui.h
@@ -886,6 +886,7 @@ Wcls *AllocateWindowDescFront(WindowDesc *desc, int window_number, bool return_e
 void RelocateAllWindows(int neww, int newh);
 
 void GuiShowTooltips(Window *parent, StringID str, uint paramcount = 0, const uint64 params[] = NULL, TooltipCloseCondition close_tooltip = TCC_HOVER);
+void GuiPrepareTooltipsExtra(Window *parent);
 
 /* widget.cpp */
 int GetWidgetFromPos(const Window *w, int x, int y);
diff --git a/src/window_type.h b/src/window_type.h
index 7185bfcb4..7f93b48f5 100644
--- a/src/window_type.h
+++ b/src/window_type.h
@@ -109,6 +109,7 @@ enum WindowClass {
 	 *   - 0 = #ToolTipsWidgets
 	 */
 	WC_TOOLTIPS,
+        WC_TOOLTIPS_EXTRA,
 
 	/**
 	 * Query string window; %Window numbers:
@@ -218,6 +219,12 @@ enum WindowClass {
 	 */
 	WC_VEHICLE_TIMETABLE,
 
+	/**
+	 * Vehicle trip history; %Window numbers:
+	 *   - #VehicleID = #VehicleTripHistoryWidgets
+	 */
+	WC_VEHICLE_TRIP_HISTORY,
+
 	/**
 	 * Company colour selection; %Window numbers:
 	 *   - #CompanyID = #SelectCompanyLiveryWidgets
@@ -516,6 +523,7 @@ enum WindowClass {
 	 *   - #CompanyID = #CompanyWidgets
 	 */
 	WC_FINANCES,
+	WC_CARGOS,
 
 	/**
 	 * Income graph; %Window numbers:
@@ -668,6 +676,8 @@ enum WindowClass {
 	 *   - 0 = #SpriteAlignerWidgets
 	 */
 	WC_SPRITE_ALIGNER,
+	WC_ZONING_TOOLBAR,
+        WC_CB_TOWN,
 
 	/**
 	 * Linkgraph legend; %Window numbers:
@@ -693,6 +703,9 @@ enum WindowClass {
 	 */
 	WC_FRAMETIME_GRAPH,
 
+	WC_CC_TOKENLOGIN,
+	WC_WATCH_COMPANY1,
+
 	WC_INVALID = 0xFFFF, ///< Invalid window.
 };
 
diff --git a/src/zoning.h b/src/zoning.h
new file mode 100644
index 000000000..935595560
--- /dev/null
+++ b/src/zoning.h
@@ -0,0 +1,33 @@
+/** @file zoning.h */
+
+#ifndef ZONING_H_
+#define ZONING_H_
+
+#include "tile_cmd.h"
+
+enum EvaluationMode {
+       CHECKNOTHING = 0,
+       CHECKOPINION = 1,  ///< Check the local authority's opinion.
+       CHECKBUILD = 2,    ///< Check wither or not the player can build.
+       CHECKSTACATCH = 3, ///< Check catchment area for stations
+       CHECKBULUNSER = 4, ///< Check for unserved buildings
+       CHECKINDUNSER = 5, ///< Check for unserved industries
+       CHECKTOWNZONES = 6,  ///< Town zones (Tz*)
+       CHECKCBBORDERS = 7,  ///< Citybuilder cargo acceptment zone
+       CHECKCBTOWNBORDERS = 8,  ///< Citybuilder server town borders
+       CHECKTOWNADZONES = 9,  ///< Town advertisement zone
+       CHECKTOWNGROWTHTILES = 10 ///< Town growth tiles (new house, skipped/removed house)
+};
+
+struct Zoning {
+       EvaluationMode inner;
+       EvaluationMode outer;
+};
+
+extern Zoning _zoning;
+
+SpriteID TileZoningSpriteEvaluation(TileIndex tile, Owner owner, EvaluationMode ev_mode);
+void DrawTileZoning(const TileInfo *ti);
+void ShowZoningToolbar();
+
+#endif /*ZONING_H_*/
diff --git a/src/zoning_cmd.cpp b/src/zoning_cmd.cpp
new file mode 100644
index 000000000..ae6cf732a
--- /dev/null
+++ b/src/zoning_cmd.cpp
@@ -0,0 +1,295 @@
+/** @file zoning_cmd.cpp */
+#include "stdafx.h"
+#include "station_base.h"
+#include "industry.h"
+#include "viewport_func.h"
+#include "town.h"
+#include "zoning.h"
+
+Zoning _zoning = {CHECKNOTHING, CHECKNOTHING};
+static const SpriteID INVALID_SPRITE_ID = UINT_MAX;
+//RED GREEN BLACK LIGHT_BLUE ORANGE WHITE YELLOW PURPLE
+
+/**
+ * Draw the zoning sprites.
+ * @param SpriteID image
+ *        the image
+ * @param SpriteID colour
+ *        the colour of the zoning
+ * @param TileInfo ti
+ *        the tile
+ */
+const byte _tileh_to_sprite[32] = {
+       0, 1, 2, 3, 4, 5, 6,  7, 8, 9, 10, 11, 12, 13, 14, 0,
+       0, 0, 0, 0, 0, 0, 0, 16, 0, 0,  0, 17,  0, 15, 18, 0,
+};
+
+void DrawZoningSprites(SpriteID image, SpriteID colour, const TileInfo *ti) {
+       if (colour != INVALID_SPRITE_ID){
+               AddSortableSpriteToDraw(image + _tileh_to_sprite[ti->tileh], colour, ti->x, ti->y, 0x10, 0x10, 1, ti->z + 7);
+       }
+}
+
+/**
+ * Detect whether this area is within the acceptance of any station.
+ * @param TileArea area
+ *        the area to search by
+ * @return true if a station is found
+ */
+bool IsAreaWithinAcceptanceZoneOfStation(TileArea area) {
+       int catchment = _settings_game.station.station_spread + (_settings_game.station.modified_catchment ? MAX_CATCHMENT : CA_UNMODIFIED);
+
+       StationFinder morestations(TileArea(TileXY(TileX(area.tile) - catchment / 2, TileY(area.tile) - catchment / 2),
+               TileX(area.tile) + area.w + catchment, TileY(area.tile) + area.h + catchment));
+
+       for (Station * const *st_iter = morestations.GetStations()->Begin(); st_iter != morestations.GetStations()->End(); ++st_iter) {
+               Station *st = *st_iter;
+               Rect rect = st->GetCatchmentRect();
+               return TileArea(TileXY(rect.left, rect.top), TileXY(rect.right, rect.bottom)).Intersects(area);
+       }
+       return false;
+}
+
+/**
+ * Detect whether this tile is within the acceptance of any station.
+ * @param TileIndex tile
+ *        the tile to search by
+ * @return true if a station is found
+ */
+bool IsTileWithinAcceptanceZoneOfStation(TileIndex tile) {
+       int catchment = _settings_game.station.station_spread + (_settings_game.station.modified_catchment ? MAX_CATCHMENT : CA_UNMODIFIED);
+
+       StationFinder morestations(TileArea(TileXY(TileX(tile) - catchment / 2, TileY(tile) - catchment / 2),
+               catchment, catchment));
+
+       for (Station * const *st_iter = morestations.GetStations()->Begin(); st_iter != morestations.GetStations()->End(); ++st_iter) {
+               Station *st = *st_iter;
+               Rect rect = st->GetCatchmentRect();
+               if ((uint)rect.left <= TileX(tile) && TileX(tile) <= (uint)rect.right
+                       && (uint)rect.top <= TileY(tile) && TileY(tile) <= (uint)rect.bottom )
+               {
+                       return true;
+               }
+       }
+       return false;
+}
+
+//Check the opinion of the local authority in the tile.
+SpriteID TileZoneCheckOpinionEvaluation(TileIndex tile, Owner owner) {
+       Town *town = ClosestTownFromTile(tile, _settings_game.economy.dist_local_authority);
+
+       if (town == NULL) return INVALID_SPRITE_ID; // no town
+       else if (HasBit(town->have_ratings, owner)) {  // good : bad
+               int16 rating = town->ratings[owner];
+               if(rating <= RATING_APPALLING) return SPR_PALETTE_ZONING_RED;
+               if(rating <= RATING_POOR) return SPR_PALETTE_ZONING_ORANGE;
+               if(rating <= RATING_MEDIOCRE) return SPR_PALETTE_ZONING_YELLOW;
+               if(rating <= RATING_GOOD) return SPR_PALETTE_ZONING_WHITE;
+               if(rating <= RATING_VERYGOOD) return SPR_PALETTE_ZONING_PURPLE;
+               if(rating <= RATING_EXCELLENT) return SPR_PALETTE_ZONING_LIGHT_BLUE;
+               return SPR_PALETTE_ZONING_GREEN;
+       }
+       else {
+               return SPR_PALETTE_ZONING_BLACK;      // no opinion
+       }
+}
+
+//Check whether the player can build in tile.
+SpriteID TileZoneCheckBuildEvaluation(TileIndex tile, Owner owner) {
+       /* Let's first check for the obvious things you cannot build on */
+       switch ( GetTileType(tile) ) {
+               case MP_INDUSTRY:
+               case MP_OBJECT:
+               case MP_HOUSE:
+                       return SPR_PALETTE_ZONING_RED; //can't build
+               case MP_STATION:
+               case MP_TUNNELBRIDGE:
+               case MP_ROAD:
+               case MP_RAILWAY: {
+                       if (GetTileOwner(tile) != owner) return SPR_PALETTE_ZONING_RED; //can't build
+                       else return INVALID_SPRITE_ID;
+               }
+               default: return INVALID_SPRITE_ID;
+       }
+}
+
+//Detect whether the tile is within the catchment zone of a station.
+//black if within, light blue if only in acceptance zone and nothing if no nearby station.
+ SpriteID TileZoneCheckStationCatchmentEvaluation(TileIndex tile) {
+       // Never on a station.
+       if (IsTileType(tile, MP_STATION)){
+               return INVALID_SPRITE_ID;
+       }
+       // For provided goods
+       StationFinder stations(TileArea(tile, 1, 1));
+       if (stations.GetStations()->Length() > 0) {
+               return SPR_PALETTE_ZONING_GREEN;
+       }
+       // For accepted goods
+       if (IsTileWithinAcceptanceZoneOfStation(tile)){
+               return SPR_PALETTE_ZONING_LIGHT_BLUE;
+       }
+       return INVALID_SPRITE_ID;
+}
+
+//Detect whether a building is unserved by a station of owner.
+//return red if unserved, orange if only accepting, nothing if served or not a building
+SpriteID TileZoneCheckUnservedBuildingsEvaluation(TileIndex tile) {
+       CargoArray dat;
+
+       if (IsTileType (tile, MP_HOUSE))
+               //&& ( ( memset(&dat, 0, sizeof(dat)), AddAcceptedCargo(tile, dat, NULL), (dat[CT_MAIL] + dat[CT_PASSENGERS] > 0) )
+               //      || ( memset(&dat, 0, sizeof(dat)), AddProducedCargo(tile, dat), (dat[CT_MAIL] + dat[CT_PASSENGERS] > 0) ) ) )
+       {
+               StationFinder stations(TileArea(tile, 1, 1));
+
+               if (stations.GetStations()->Length() > 0) {
+                       return INVALID_SPRITE_ID;
+               }
+               // For accepted goods
+               if (IsTileWithinAcceptanceZoneOfStation(tile)){
+                       return SPR_PALETTE_ZONING_ORANGE;
+               }
+               return SPR_PALETTE_ZONING_RED;
+       }
+       return INVALID_SPRITE_ID;
+}
+
+//Detect whether an industry is unserved by a station of owner.
+//return red if unserved, orange if only accepting, nothing if served or not a building
+SpriteID TileZoneCheckUnservedIndustriesEvaluation(TileIndex tile) {
+       if (IsTileType(tile, MP_INDUSTRY)) {
+               Industry *ind = Industry::GetByTile(tile);
+               StationFinder stations(ind->location);
+
+               if (stations.GetStations()->Length() > 0){
+                       return INVALID_SPRITE_ID;
+               }
+
+               // For accepted goods
+               if (IsAreaWithinAcceptanceZoneOfStation(ind->location)){
+                       return SPR_PALETTE_ZONING_ORANGE;
+               }
+               return SPR_PALETTE_ZONING_RED;
+       }
+       return INVALID_SPRITE_ID;
+}
+
+//Check which town zone tile belongs to.
+SpriteID TileZoneCheckTownZones(TileIndex tile) {
+       HouseZonesBits next_zone = HZB_BEGIN, tz = HZB_END;
+
+       Town *town;
+       FOR_ALL_TOWNS(town) {
+               while (next_zone < HZB_END
+                       && (town->cache.squared_town_zone_radius[next_zone] == 0
+                               || DistanceSquare(tile, town->xy) <= town->cache.squared_town_zone_radius[next_zone])
+               ){
+                       if(town->cache.squared_town_zone_radius[next_zone] != 0)  tz = next_zone;
+                       next_zone++;
+               }
+       }
+
+       switch (tz) {
+               case HZB_TOWN_EDGE:         return SPR_PALETTE_ZONING_LIGHT_BLUE; // Tz0
+               case HZB_TOWN_OUTSKIRT:     return SPR_PALETTE_ZONING_RED; // Tz1
+               case HZB_TOWN_OUTER_SUBURB: return SPR_PALETTE_ZONING_YELLOW; // Tz2
+               case HZB_TOWN_INNER_SUBURB: return SPR_PALETTE_ZONING_GREEN; // Tz3
+               case HZB_TOWN_CENTRE:       return SPR_PALETTE_ZONING_WHITE; // Tz4 - center
+               default:                    return INVALID_SPRITE_ID; // no town
+       }
+       return INVALID_SPRITE_ID;
+}
+
+//Check CB town acceptance area
+SpriteID TileZoneCheckCBBorders(TileIndex tile) {
+       Town *town = CalcClosestTownFromTile(tile);
+
+       if (town != NULL) {
+               if (DistanceManhattan(town->xy, tile) <= _settings_client.gui.cb_distance_check) {
+                       return SPR_PALETTE_ZONING_LIGHT_BLUE; //cb catchment
+               }
+       }
+       return INVALID_SPRITE_ID; // no town
+}
+
+//Check whether the tile is within citybuilder server town border (where houses could be built)
+SpriteID TileZoneCheckCBTownBorders(TileIndex tile) {
+       Town *town;
+       FOR_ALL_TOWNS(town) {
+               uint32 distMax = DistanceMax(town->xy, tile);
+               if (distMax * distMax < town->cache.squared_town_zone_radius[0]){
+                       return SPR_PALETTE_ZONING_GREEN;
+               }
+       }
+       return INVALID_SPRITE_ID;
+}
+
+//Check which advertisement zone(small, medium, large) tile belongs to
+SpriteID TileZoneCheckTownAdvertisementZones(TileIndex tile) {
+       Town *town = CalcClosestTownFromTile(tile, 21U);
+       if (town == NULL) return INVALID_SPRITE_ID; //nothing
+
+       uint dist = DistanceManhattan(town->xy, tile);
+
+       if (dist <= 10) return SPR_PALETTE_ZONING_GREEN;
+       if (dist <= 15) return SPR_PALETTE_ZONING_YELLOW;
+       if (dist <= 20) return SPR_PALETTE_ZONING_LIGHT_BLUE;
+       return INVALID_SPRITE_ID;
+}
+
+//Checks for tile in growth tiles info
+SpriteID TileZoneCheckTownsGrowthTiles(TileIndex tile) {
+       switch (max(_towns_growth_tiles[tile], _towns_growth_tiles_last_month[tile])) {
+               case TGTS_CB_HOUSE_REMOVED_NOGROW: return SPR_PALETTE_ZONING_LIGHT_BLUE;
+               case TGTS_RH_REMOVED:              return SPR_PALETTE_ZONING_LIGHT_BLUE;
+               case TGTS_RH_REBUILT:              return SPR_PALETTE_ZONING_WHITE;
+               case TGTS_NEW_HOUSE:               return SPR_PALETTE_ZONING_GREEN;
+               case TGTS_CYCLE_SKIPPED:           return SPR_PALETTE_ZONING_ORANGE;
+               case TGTS_HOUSE_SKIPPED:           return SPR_PALETTE_ZONING_YELLOW;
+               case TGTS_CB_HOUSE_REMOVED:        return SPR_PALETTE_ZONING_RED;
+               default: return INVALID_SPRITE_ID;
+       }
+}
+
+/**
+ * General evaluation function; calls all the other functions depending on
+ * evaluation mode.
+ * @param TileIndex tile
+ *        Tile to be evaluated.
+ * @param EvaluationMode ev_mode
+ *        The current evaluation mode.
+ * @return The colour returned by the evaluation functions (none if no ev_mode).
+ */
+SpriteID TileZoningSpriteEvaluation(TileIndex tile, Owner owner, EvaluationMode ev_mode) {
+       switch (ev_mode) {
+               case CHECKOPINION:     return TileZoneCheckOpinionEvaluation(tile, owner);
+               case CHECKBUILD:       return TileZoneCheckBuildEvaluation(tile, owner);
+               case CHECKSTACATCH:    return TileZoneCheckStationCatchmentEvaluation(tile);
+               case CHECKBULUNSER:    return TileZoneCheckUnservedBuildingsEvaluation(tile);
+               case CHECKINDUNSER:    return TileZoneCheckUnservedIndustriesEvaluation(tile);
+               case CHECKTOWNZONES:   return TileZoneCheckTownZones(tile);
+               case CHECKCBBORDERS:   return TileZoneCheckCBBorders(tile);
+               case CHECKCBTOWNBORDERS: return TileZoneCheckCBTownBorders(tile);
+               case CHECKTOWNADZONES: return TileZoneCheckTownAdvertisementZones(tile);
+               case CHECKTOWNGROWTHTILES: return TileZoneCheckTownsGrowthTiles(tile);
+               default:               return INVALID_SPRITE_ID;
+       }
+}
+
+/**
+ * Draw the the zoning on the tile.
+ * @param TileInfo ti
+ *        the tile to draw on.
+ */
+void DrawTileZoning(const TileInfo *ti) {
+       if(_zoning.outer == CHECKNOTHING && _zoning.inner == CHECKNOTHING) return; //nothing to do
+       if (_game_mode != GM_NORMAL || ti->tile >= MapSize() || IsTileType(ti->tile, MP_VOID)) return; //check invalid
+       if (_zoning.outer != CHECKNOTHING){
+               DrawZoningSprites(SPR_SELECT_TILE, TileZoningSpriteEvaluation(ti->tile, _local_company, _zoning.outer), ti);
+       }
+       if (_zoning.inner != CHECKNOTHING){
+               DrawZoningSprites(SPR_INNER_HIGHLIGHT_BASE, TileZoningSpriteEvaluation(ti->tile, _local_company, _zoning.inner), ti);
+       }
+}
+
diff --git a/src/zoning_gui.cpp b/src/zoning_gui.cpp
new file mode 100644
index 000000000..c0e0d0c92
--- /dev/null
+++ b/src/zoning_gui.cpp
@@ -0,0 +1,198 @@
+/** @file zoning_gui.cpp */
+#include "stdafx.h"
+#include "widgets/dropdown_func.h"
+#include "table/strings.h"
+#include "strings_func.h"
+#include "gfx_func.h"
+#include "core/geometry_func.hpp"
+#include "zoning.h"
+#include "hotkeys.h"
+
+const StringID _zone_types[] = {
+	//STR_ZONING_NO_ZONING,
+	STR_ZONING_AUTHORITY,
+	STR_ZONING_CAN_BUILD,
+	STR_ZONING_STA_CATCH,
+	STR_ZONING_BUL_UNSER,
+	STR_ZONING_IND_UNSER,
+	STR_ZONING_TOWN_ZONES,
+	STR_ZONING_CB_BORDERS,
+	STR_ZONING_CB_TOWN_BORDERS,
+	STR_ZONING_ADVERTISEMENT_ZONES,
+	STR_ZONING_TOWN_GROWTH_TILES,
+};
+
+enum ZoningToolbarWidgets {
+	ZTW_CAPTION,
+	ZTW_OUTER_FIRST,
+	ZTW_INNER_FIRST = ZTW_OUTER_FIRST + 10,
+	ZTW_INNER_END = ZTW_INNER_FIRST + 10,
+};
+
+struct ZoningWindow : public Window {
+	uint maxwidth;
+	uint maxheight;
+
+	ZoningWindow(WindowDesc *desc, int window_number) : Window(desc) {
+		int zone_types_size = lengthof(_zone_types);
+		Dimension dim;
+		this->maxwidth = 0;
+		this->maxheight = 0;
+		for (int i = 0; i < zone_types_size; i++) {
+			dim = GetStringBoundingBox(_zone_types[i]);
+			this->maxwidth = max(this->maxwidth, dim.width);
+			this->maxheight = max(this->maxheight, dim.height);
+		}
+
+		this->InitNested(window_number);
+		this->InvalidateData();
+		if(_zoning.outer != CHECKNOTHING) this->LowerWidget(ZTW_OUTER_FIRST + _zoning.outer - 1); //-1:skip CHECKNOTHING
+		if(_zoning.inner != CHECKNOTHING) this->LowerWidget(ZTW_INNER_FIRST + _zoning.inner - 1);
+	}
+
+	virtual void OnPaint() {
+		this->DrawWidgets();
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count) {
+		bool outer = true;
+		bool deselect = false;
+		EvaluationMode clicked;
+		if (widget >= ZTW_OUTER_FIRST && widget < ZTW_INNER_FIRST){
+			clicked = (EvaluationMode)(widget - ZTW_OUTER_FIRST + 1); //+1:skip CHECKNOTHING
+			deselect = _zoning.outer == clicked;
+			_zoning.outer = deselect ? CHECKNOTHING : clicked;
+		}
+		else if (widget >= ZTW_INNER_FIRST && widget < ZTW_INNER_END){
+			clicked = (EvaluationMode)(widget - ZTW_INNER_FIRST + 1);
+			deselect = _zoning.inner == clicked;
+			_zoning.inner = deselect ? CHECKNOTHING : clicked;
+			outer = false;
+		}
+		else return;
+
+		this->RaiseAllWidgets(outer);
+		if(!deselect) this->ToggleWidgetLoweredState(widget);
+		this->InvalidateData();
+		MarkWholeScreenDirty();
+	}
+
+	void DrawWidget(const Rect &r, int widget) const
+	{
+		StringID strid = STR_EMPTY;
+		if (widget >= ZTW_OUTER_FIRST && widget < ZTW_INNER_FIRST){
+			strid = _zone_types[widget - ZTW_OUTER_FIRST];
+		}
+		else if (widget >= ZTW_INNER_FIRST && widget < ZTW_INNER_END){
+			strid = _zone_types[widget - ZTW_INNER_FIRST];
+		}
+		else return;
+
+		bool rtl = _current_text_dir == TD_RTL;
+		byte clk_dif = this->IsWidgetLowered(widget) ? 1 : 0;
+		int x = r.left + WD_FRAMERECT_LEFT;
+		int y = r.top;
+
+		DrawString(rtl ? r.left : x + clk_dif + 1, (rtl ? r.right + clk_dif : r.right), y + 1 + clk_dif, strid, TC_FROMSTRING, SA_LEFT);
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize) {
+		if (widget >= ZTW_OUTER_FIRST && widget < ZTW_INNER_END){
+			size->width = this->maxwidth + padding.width + 8;
+			size->height = this->maxheight + 2;
+		}
+	}
+
+	void RaiseAllWidgets(bool outer){
+		byte start = outer ? ZTW_OUTER_FIRST : ZTW_INNER_FIRST;
+		byte end = outer ? ZTW_INNER_FIRST : ZTW_INNER_END;
+		for(byte i = start; i < end; i++){
+			if(this->IsWidgetLowered(i)){
+				this->ToggleWidgetLoweredState(i);
+				break;
+			}
+		}
+	}
+
+	virtual EventState OnHotkey(int hotkey)
+	{
+		return Window::OnHotkey(hotkey);
+	}
+
+	static HotkeyList hotkeys;
+};
+
+
+static EventState ZoningWindowGlobalHotkeys(int hotkey) {
+	EvaluationMode zoning = (EvaluationMode)(hotkey - ZTW_OUTER_FIRST + 1); // +1:skip CHECKNOTHING
+	bool deselect = (_zoning.outer == zoning);
+	_zoning.outer = deselect ? CHECKNOTHING : zoning;
+	MarkWholeScreenDirty();
+	return ES_HANDLED;
+}
+
+static Hotkey zoning_hotkeys[] = {
+	Hotkey(WKC_SHIFT | '1', "authority", ZTW_OUTER_FIRST),
+	Hotkey(WKC_SHIFT | '2', "build_status", ZTW_OUTER_FIRST + 1),
+	Hotkey(WKC_SHIFT | '3', "station_catchment", ZTW_OUTER_FIRST + 2),
+	Hotkey(WKC_SHIFT | '4', "unserved_buildings", ZTW_OUTER_FIRST + 3),
+	Hotkey(WKC_SHIFT | '5', "unserved_industries", ZTW_OUTER_FIRST + 4),
+	Hotkey(WKC_SHIFT | '6', "town_zone", ZTW_OUTER_FIRST + 5),
+	Hotkey(WKC_SHIFT | '7', "CB_acceptance", ZTW_OUTER_FIRST + 6),
+	Hotkey(WKC_SHIFT | '8', "CB_build_borders", ZTW_OUTER_FIRST + 7),
+	Hotkey(WKC_SHIFT | '9', "advertisement", ZTW_OUTER_FIRST + 8),
+	Hotkey(WKC_SHIFT | '0', "growth_tiles", ZTW_OUTER_FIRST + 9),
+	HOTKEY_LIST_END
+};
+
+HotkeyList ZoningWindow::hotkeys("zoning_gui", zoning_hotkeys, ZoningWindowGlobalHotkeys);
+
+
+/** Construct the row containing the digit keys. */
+static NWidgetBase *MakeZoningButtons(int *biggest_index)
+{
+	NWidgetHorizontal *hor = new NWidgetHorizontal(NC_EQUALSIZE);
+	int zone_types_size = lengthof(_zone_types);
+	hor->SetPadding(1, 1, 1, 1);
+
+	for(int i = 0; i < 2; i++){
+		NWidgetVertical *ver = new NWidgetVertical;
+
+		int offset = (i == 0) ? ZTW_OUTER_FIRST : ZTW_INNER_FIRST;
+
+		for (int j = 0; j < zone_types_size; j++) {
+			NWidgetBackground *leaf = new NWidgetBackground(WWT_PANEL, i==0 ? COLOUR_ORANGE : COLOUR_YELLOW, offset + j, NULL);
+			leaf->SetFill(1, 0);
+			leaf->SetPadding(0, 0, 0, 0);
+			ver->Add(leaf);
+		}
+		hor->Add(ver);
+	}
+	*biggest_index = ZTW_INNER_END - 1;
+	return hor;
+}
+
+static const NWidgetPart _nested_zoning_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, ZTW_CAPTION), SetDataTip(STR_ZONING_TOOLBAR, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY),
+		NWidgetFunction(MakeZoningButtons),
+	EndContainer()
+};
+
+static WindowDesc _zoning_desc (
+	WDP_AUTO, NULL, 0, 0,
+	WC_ZONING_TOOLBAR, WC_NONE,
+	0,
+	_nested_zoning_widgets, lengthof(_nested_zoning_widgets),
+	&ZoningWindow::hotkeys
+);
+
+void ShowZoningToolbar() {
+	AllocateWindowDescFront<ZoningWindow>(&_zoning_desc, 0);
+}
+
diff --git a/src/zoom_type.h b/src/zoom_type.h
index ea8302761..32b7f817b 100644
--- a/src/zoom_type.h
+++ b/src/zoom_type.h
@@ -32,7 +32,7 @@ enum ZoomLevel {
 	ZOOM_LVL_COUNT = ZOOM_LVL_END - ZOOM_LVL_BEGIN, ///< Number of zoom levels.
 
 	/* Here we define in which zoom viewports are */
-	ZOOM_LVL_VIEWPORT = ZOOM_LVL_OUT_4X, ///< Default zoom level for viewports.
+	ZOOM_LVL_VIEWPORT = ZOOM_LVL_OUT_8X, ///< Default zoom level for viewports.
 	ZOOM_LVL_NEWS     = ZOOM_LVL_OUT_4X, ///< Default zoom level for the news messages.
 	ZOOM_LVL_INDUSTRY = ZOOM_LVL_OUT_8X, ///< Default zoom level for the industry view.
 	ZOOM_LVL_TOWN     = ZOOM_LVL_OUT_8X, ///< Default zoom level for the town view.
@@ -46,6 +46,7 @@ enum ZoomLevel {
 
 	ZOOM_LVL_MIN      = ZOOM_LVL_NORMAL, ///< Minimum zoom level.
 	ZOOM_LVL_MAX      = ZOOM_LVL_OUT_32X, ///< Maximum zoom level.
+	//ZOOM_LVL_DRAW_MAP = ZOOM_LVL_OUT_32X,      ///< All zoomlevels above or equal to this are rendered with map style
 };
 DECLARE_POSTFIX_INCREMENT(ZoomLevel)
 
